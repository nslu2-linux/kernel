diff -Naur linux-2.6.18.orig/drivers/net/ixp4xx/mac.h linux-2.6.18/drivers/net/ixp4xx/mac.h
--- linux-2.6.18.orig/drivers/net/ixp4xx/mac.h	2006-09-28 13:29:00.037515750 +0000
+++ linux-2.6.18/drivers/net/ixp4xx/mac.h	2006-09-28 13:31:20.219593750 +0000
@@ -191,9 +191,8 @@
 {
 	int i;
 	u32 data = 0;
-	u8 *bytes = (u8*)&data;
 	for(i=0; i<4; i++) {
-		bytes[3-i] = mac_read_reg(mac, offset + i) & 0xff;
+		data |= (mac_read_reg(mac, offset + i) & 0xff) << (i*8);
 	}
 	return data;
 }
diff -Naur linux-2.6.18.orig/drivers/net/ixp4xx/mac_driver.c linux-2.6.18/drivers/net/ixp4xx/mac_driver.c
--- linux-2.6.18.orig/drivers/net/ixp4xx/mac_driver.c	2006-09-28 13:29:00.037515750 +0000
+++ linux-2.6.18/drivers/net/ixp4xx/mac_driver.c	2006-09-28 13:31:50.249470500 +0000
@@ -84,8 +84,7 @@
 	npe_mh_setportaddr(npe, mac->plat, dev->dev_addr);
 	npe_mh_disable_firewall(npe, mac->plat);
 	for (i=0; i<dev->addr_len; i++)
-		mac_write_reg(mac, MAC_UNI_ADDR + 4 * i,
-				dev->dev_addr[i]);
+		mac_write_reg(mac, MAC_UNI_ADDR + i, dev->dev_addr[i]);
 }
 
 static void update_duplex_mode(struct net_device *dev)
@@ -173,8 +172,8 @@
 			aclear[j] = aset[j] | ~aclear[j];
 		}
 		for (i=0; i<dev->addr_len; i++) {
-			mac_write_reg(mac, MAC_ADDR + 4*i, aset[i]);
-			mac_write_reg(mac, MAC_ADDR_MASK + 4*i,
+			mac_write_reg(mac, MAC_ADDR + i, aset[i]);
+			mac_write_reg(mac, MAC_ADDR_MASK + i,
 					aset[i]);
 		}
 	}
@@ -256,7 +255,11 @@
 	if (!netif_running(dev))
 		return -EINVAL;
 
+
+	if (!try_module_get(THIS_MODULE))
+		return -ENODEV;
 	rc = generic_mii_ioctl(&mac->mii, if_mii(rq), cmd, &duplex_changed);
+	module_put(THIS_MODULE);
 	if (duplex_changed)
 		update_duplex_mode(dev);
 	return rc;
diff -Naur linux-2.6.18.orig/drivers/net/ixp4xx/npe_mh.c linux-2.6.18/drivers/net/ixp4xx/npe_mh.c
--- linux-2.6.18.orig/drivers/net/ixp4xx/npe_mh.c	2006-09-28 13:29:00.037515750 +0000
+++ linux-2.6.18/drivers/net/ixp4xx/npe_mh.c	2006-09-28 13:31:20.219593750 +0000
@@ -25,13 +25,16 @@
 static int send_message(struct npe_info *npe, struct npe_mh_msg *msg)
 {
 	int i,j;
-	u32 data[2];
+	u32 send[2], recv[2];
+
+	for (i=0; i<2; i++)
+		send[i] = be32_to_cpu(msg->u.data[i]);
 
 	if ((npe_reg_read(npe, IX_NPEDL_REG_OFFSET_STAT) &
 				IX_NPEMH_NPE_STAT_IFNE))
 		return -1;
 
-	npe_reg_write(npe, IX_NPEDL_REG_OFFSET_FIFO, msg->u.data[0]);
+	npe_reg_write(npe, IX_NPEDL_REG_OFFSET_FIFO, send[0]);
 	for(i=0; i<MAX_RETRY; i++) {
 		/* if the IFNF status bit is unset then the inFIFO is full */
 		if (npe_reg_read(npe, IX_NPEDL_REG_OFFSET_STAT) &
@@ -40,7 +43,7 @@
 	}
 	if (i>=MAX_RETRY)
 		return -1;
-	npe_reg_write(npe, IX_NPEDL_REG_OFFSET_FIFO, msg->u.data[1]);
+	npe_reg_write(npe, IX_NPEDL_REG_OFFSET_FIFO, send[1]);
 	i=0;
 	while (!(npe_reg_read(npe, IX_NPEDL_REG_OFFSET_STAT) &
 					IX_NPEMH_NPE_STAT_OFNE)) {
@@ -52,12 +55,12 @@
 	j=0;
 	while (npe_reg_read(npe, IX_NPEDL_REG_OFFSET_STAT) &
 					IX_NPEMH_NPE_STAT_OFNE) {
-		data[j&1] = npe_reg_read(npe,IX_NPEDL_REG_OFFSET_FIFO);
+		recv[j&1] = npe_reg_read(npe,IX_NPEDL_REG_OFFSET_FIFO);
 		j++;
 	}
-	if ((data[0] != msg->u.data[0]) || (data[1] != msg->u.data[1])) {
+	if ((recv[0] != send[0]) || (recv[1] != send[1])) {
 		printk("Unexpected answer: Send %08x:%08x Ret %08x:%08x\n",
-			msg->u.data[0],msg->u.data[1], data[0], data[1]);
+			send[0], send[1], recv[0], recv[1]);
 	}
 	return 0;
 }
diff -Naur linux-2.6.18.orig/drivers/net/ixp4xx/qmgr_eth.c linux-2.6.18/drivers/net/ixp4xx/qmgr_eth.c
--- linux-2.6.18.orig/drivers/net/ixp4xx/qmgr_eth.c	2006-09-28 13:29:00.041518000 +0000
+++ linux-2.6.18/drivers/net/ixp4xx/qmgr_eth.c	2006-09-28 13:32:39.340538500 +0000
@@ -43,14 +43,23 @@
 		return 0;
 
 	cont->h.skb = skb;
+#ifndef __ARMEB__
+	/* swap the payload of the SKB */
+	{
+		u32 *p = (u32*)((unsigned)skb->data & ~0x3);
+		u32 *e = (u32*)(((unsigned)skb->data + skb->len + 3) & ~0x3);
+		while (p < e)
+			*p = cpu_to_be32(*p), ++p;
+	}
+#endif
 	/* fill the NPE information record */
 	cont->ctl.eth.next = 0;
-	cont->ctl.eth.buf_len = cpu_to_be16(skb->end - skb->head);
-	cont->ctl.eth.pkt_len = cpu_to_be16(skb->len);
-	cont->ctl.eth.phys_addr = cpu_to_be32(
-		dma_map_single(queue->dev, skb->data, skb->len, DMA_TO_DEVICE));
+	cont->ctl.eth.buf_len = skb->end - skb->head;
+	cont->ctl.eth.pkt_len = skb->len;
+	cont->ctl.eth.phys_addr =
+		dma_map_single(queue->dev, skb->data, skb->len, DMA_TO_DEVICE);
 
-	queue_put_entry(queue, cpu_to_be32(cont->phys));
+	queue_put_entry(queue, cont->phys);
 
 	stat = (*(qmgr->addr + QUE_UO_STAT0 + (queue->id >> 4))	>>
 			(queue->id & 0xf)<<1) & 3;
@@ -80,12 +89,12 @@
 	skb->dev = dev;
 	cont->h.skb = skb;
 	cont->ctl.eth.next = 0;
-	cont->ctl.eth.buf_len = cpu_to_be16(len);
+	cont->ctl.eth.buf_len = len;
 	cont->ctl.eth.pkt_len = 0;
-	cont->ctl.eth.phys_addr = cpu_to_be32(
-		dma_map_single(queue->dev, skb->data, len, DMA_FROM_DEVICE));
+	cont->ctl.eth.phys_addr =
+		dma_map_single(queue->dev, skb->data, len, DMA_FROM_DEVICE);
 
-	queue_put_entry(queue, cpu_to_be32(cont->phys));
+	queue_put_entry(queue, cont->phys);
 
 	/* TODO: check quelen ?
 	 * The current use guarantees that this queues will never overflow.
@@ -95,12 +104,12 @@
 
 int queue_drain(struct qm_queue *queue)
 {
-	u32 phys = queue_get_entry(queue);
+	u32 phys = *queue->acc_reg & ~0xf;
 	struct npe_cont *cont;
 
 	if (!phys)
 		return 0;
-	cont = dma_to_virt(queue->dev, be32_to_cpu(phys));
+	cont = dma_to_virt(queue->dev, phys);
 	cont = cont->virt;
 	dev_kfree_skb_any(cont->h.skb);
 	qmgr_return_cont(dev_get_drvdata(queue->dev), cont);
@@ -109,7 +118,7 @@
 
 struct sk_buff *queue_return_skb(struct qm_queue *queue)
 {
-	u32 phys = queue_get_entry(queue);
+	u32 phys = *queue->acc_reg & ~0xf;
 	struct sk_buff *skb;
 	struct npe_cont *cont;
 	int len, buflen;
@@ -117,15 +126,24 @@
 	if (!phys)
 		return NULL;
 
-	cont = dma_to_virt(queue->dev, be32_to_cpu(phys));
+	cont = dma_to_virt(queue->dev, phys);
 	cont = cont->virt;
 	skb = cont->h.skb;
-	buflen = be16_to_cpu(cont->ctl.eth.buf_len);
-	len = be16_to_cpu(cont->ctl.eth.pkt_len);
-	dma_unmap_single(queue->dev, be32_to_cpu(cont->ctl.eth.phys_addr),
+	buflen = cont->ctl.eth.buf_len;
+	len = cont->ctl.eth.pkt_len;
+	dma_unmap_single(queue->dev, cont->ctl.eth.phys_addr,
 			buflen,	DMA_FROM_DEVICE);
 	qmgr_return_cont(dev_get_drvdata(queue->dev), cont);
 	skb_put(skb, len);
+#ifndef __ARMEB__
+	/* swap the payload of the SKB */
+	{
+		u32 *p = (u32*)((unsigned)skb->data & ~0x3);
+		u32 *e = (u32*)(((unsigned)skb->data + skb->len + 3) & ~0x3);
+		while (p < e)
+			*p = cpu_to_be32(*p), ++p;
+	}
+#endif
 	return skb;
 }
 
diff -Naur linux-2.6.18.orig/drivers/net/ixp4xx/ucode_dl.c linux-2.6.18/drivers/net/ixp4xx/ucode_dl.c
--- linux-2.6.18.orig/drivers/net/ixp4xx/ucode_dl.c	2006-09-28 13:29:00.041518000 +0000
+++ linux-2.6.18/drivers/net/ixp4xx/ucode_dl.c	2006-09-28 13:31:20.219593750 +0000
@@ -15,12 +15,13 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/firmware.h>
+#include <linux/dma-mapping.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 
 #include <linux/ixp_npe.h>
 
-#define IXNPE_VERSION "IXP4XX NPE driver Version 0.1.0"
+#define IXNPE_VERSION "IXP4XX NPE driver Version 0.1.1"
 
 #define DL_MAGIC 0xfeedf00d
 
@@ -121,6 +122,8 @@
 static int match_by_npeid(struct device *dev, void *id)
 {
 	struct npe_info *npe = dev_get_drvdata(dev);
+	if (!npe->plat)
+		return 0;
 	return (npe->plat->id == *(int*)id);
 }
 
@@ -136,10 +139,9 @@
 	struct dl_codeblock *cb;
 	struct npe_info *npe;
 	int ret=0;
-	u32 imgid = be32_to_cpu(image->id);
 
 	if (!dev) {
-		dev = get_npe_by_id( (imgid >> 24) & 0xf);
+		dev = get_npe_by_id( (image->id >> 24) & 0xf);
 		put_device(dev);
 	}
 	if (!dev)
@@ -167,7 +169,7 @@
 		if ((ret = download_block(npe, cb, blk->type)))
 			return ret;
 	}
-	*(u32*)npe->img_info = imgid;
+	*(u32*)npe->img_info = cpu_to_be32(image->id);
 	npe_start(npe);
 
 	printk(KERN_INFO "Image loaded to %s Func:%x, Rel: %x:%x, Status: %x\n",
@@ -197,11 +199,10 @@
 		char *data;
 		struct dl_image *image;
 	} u;
+	const char __user *cbuf = buf;
 
 	u.data = file->private_data;
 
-	const char __user *cbuf = buf;
-
 	while (count) {
 		int len;
 		if (*ppos < sizeof(struct dl_image)) {
@@ -252,7 +253,8 @@
 
 static void npe_firmware_probe(struct device *dev)
 {
-#if defined(CONFIG_FW_LOADER) && defined(MODULE)
+#if (defined(CONFIG_FW_LOADER) || defined(CONFIG_FW_LOADER_MODULE)) \
+	&& defined(MODULE)
 	const struct firmware *fw_entry;
 	struct npe_info *npe = dev_get_drvdata(dev);
 	struct dl_image *image;
@@ -352,11 +354,13 @@
 		goto out_rel;
 	}
 
-	npe->plat = plat;
+	pdev->dev.coherent_dma_mask = DMA_31BIT_MASK;
+
 	platform_set_drvdata(pdev, npe);
 
 	device_create_file(&pdev->dev, &dev_attr_state);
 
+	npe->plat = plat;
 	disable_npe_irq(npe);
 	if (! (npe_status(npe) & IX_NPEDL_EXCTL_STATUS_RUN))
 		npe_firmware_probe(&pdev->dev);
@@ -379,7 +383,7 @@
 
 static struct miscdevice ucode_dl_dev = {
 	.minor	= MICROCODE_MINOR,
-	.name	= "ucode_dl",
+	.name	= "ixp4xx_ucode",
 	.fops	= &ucode_dl_fops,
 };
 
@@ -396,7 +400,7 @@
 }
 
 static struct platform_driver ixp4xx_npe_driver = {
-	.driver {
+	.driver = {
 		.name	= "ixp4xx_npe",
 		.owner	= THIS_MODULE,
 	},
diff -Naur linux-2.6.18.orig/include/linux/ixp_qmgr.h linux-2.6.18/include/linux/ixp_qmgr.h
--- linux-2.6.18.orig/include/linux/ixp_qmgr.h	2006-09-28 13:29:00.045520250 +0000
+++ linux-2.6.18/include/linux/ixp_qmgr.h	2006-09-28 13:31:20.359602500 +0000
@@ -67,8 +67,13 @@
 
 struct eth_ctl {
 	u32 next;
+#ifdef __ARMEB__
 	u16 buf_len;
 	u16 pkt_len;
+#else
+	u16 pkt_len;
+	u16 buf_len;
+#endif
 	u32 phys_addr;
 	u8 dest_id;
 	u8 src_id;
@@ -124,11 +129,6 @@
 	*(queue->acc_reg) = entry;
 }
 
-static inline u32 queue_get_entry(struct qm_queue *queue)
-{
-	return *queue->acc_reg & ~0xf;
-}
-
 static inline struct npe_cont *qmgr_get_cont(struct qm_qmgr *qmgr)
 {
 	unsigned long flags;
