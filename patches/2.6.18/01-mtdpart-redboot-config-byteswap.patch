Index: linux-2.6.18/drivers/mtd/redboot.c
===================================================================
--- linux-2.6.18.orig/drivers/mtd/redboot.c	2006-09-19 20:42:06.000000000 -0700
+++ linux-2.6.18/drivers/mtd/redboot.c	2006-10-18 23:59:36.000000000 -0700
@@ -87,14 +87,41 @@
 	for (i = 0; i < numslots; i++) {
 		if (!memcmp(buf[i].name, "FIS directory", 14)) {
 			/* This is apparently the FIS directory entry for the
-			 * FIS directory itself.  The FIS directory size is
-			 * one erase block; if the buf[i].size field is
-			 * swab32(erasesize) then we know we are looking at
-			 * a byte swapped FIS directory - swap all the entries!
-			 * (NOTE: this is 'size' not 'data_length'; size is
-			 * the full size of the entry.)
+			 * FIS directory itself.  To discover whether the entries
+			 * in this are native byte sex or byte swapped look at
+			 * the flash_base field - we know the FIS directory is
+			 * at 'offset' within the flash.
 			 */
-			if (swab32(buf[i].size) == master->erasesize) {
+			int maybe_native, maybe_swapped;
+			if (fis_origin != 0) {
+				maybe_native =
+					buf[i].flash_base == fis_origin + offset;
+				maybe_swapped =
+					swab32(buf[i].flash_base) == fis_origin + offset;
+			} else if (offset != 0 || buf[i].flash_base != 0) {
+				maybe_native =
+					(buf[i].flash_base & (master->size-1)) == offset;
+				maybe_swapped =
+					(swab32(buf[i].flash_base) & (master->size-1)) == offset;
+			} else {
+				/* The FIS directory is at the start of the flash and
+				 * the 'flash_base' field is 0.  The critical case is when
+				 * we are booting off this flash, but then we don't expect
+				 * this because the boot loader is pretty much always at
+				 * the start!  Since the FIS directory is always less than
+				 * or equal to one erase block do the following:
+				 */
+				maybe_native = buf[i].size <= master->erasesize;
+				maybe_swapped = swab32(buf[i].size) <= master->erasesize;
+			}
+
+			if (maybe_native && maybe_swapped)
+				printk(KERN_WARNING "RedBoot directory 0x%lx(0x%lx) assumed native\n",
+					(unsigned long) buf[i].flash_base, (unsigned long)buf[i].size);
+			else if (!maybe_native && !maybe_swapped)
+				printk(KERN_ERR "RedBoot directory 0x%lx(0x%lx) forced native\n",
+					(unsigned long) buf[i].flash_base, (unsigned long)buf[i].size);
+			else if (maybe_swapped) {
 				int j;
 				for (j = 0; j < numslots && buf[j].name[0] != 0xff; ++j) {
 					/* The unsigned long fields were written with the
@@ -108,7 +135,11 @@
 					swab32s(&buf[j].desc_cksum);
 					swab32s(&buf[j].file_cksum);
 				}
-			}
+				printk(KERN_NOTICE "RedBoot directory 0x%lx(0x%lx) swapped\n",
+					(unsigned long)buf[i].flash_base, (unsigned long)buf[i].size);
+			} else
+				printk(KERN_NOTICE "RedBoot directory 0x%lx(0x%lx) native\n",
+					(unsigned long)buf[i].flash_base, (unsigned long)buf[i].size);
 			break;
 		}
 	}
