diff --git a/Makefile b/Makefile
index a241b79..e8a95e2 100644
--- a/Makefile
+++ b/Makefile
@@ -2477,6 +2477,9 @@ ixdp425_config	:	unconfig
 ixdpg425_config	:	unconfig
 	@$(MKCONFIG) $(@:_config=) arm ixp ixdp425
 
+nslu2_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm ixp nslu2
+
 lubbock_config	:	unconfig
 	@$(MKCONFIG) $(@:_config=) arm pxa lubbock
 
diff --git a/board/nslu2/Makefile b/board/nslu2/Makefile
new file mode 100644
index 0000000..f9799a8
--- /dev/null
+++ b/board/nslu2/Makefile
@@ -0,0 +1,53 @@
+#
+# (C) Copyright 2008
+# Rod Whitby <rod@whitby.id.au>
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= nslu2.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/nslu2/config.mk b/board/nslu2/config.mk
new file mode 100644
index 0000000..d5f5fc7
--- /dev/null
+++ b/board/nslu2/config.mk
@@ -0,0 +1,4 @@
+TEXT_BASE = 0x00200000
+
+# include NPE ethernet driver
+BOARDLIBS = cpu/ixp/npe/libnpe.a
diff --git a/board/nslu2/flash.c b/board/nslu2/flash.c
new file mode 100644
index 0000000..1d958c8
--- /dev/null
+++ b/board/nslu2/flash.c
@@ -0,0 +1,427 @@
+/*
+ * (C) Copyright 2001
+ * Kyle Harris, Nexus Technologies, Inc. kharris@nexus-tech.net
+ *
+ * (C) Copyright 2001
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <linux/byteorder/swab.h>
+
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];	/* info for FLASH chips        */
+
+/* Board support for 1 or 2 flash devices */
+#undef FLASH_PORT_WIDTH32
+#define FLASH_PORT_WIDTH16
+
+#ifdef FLASH_PORT_WIDTH16
+#define FLASH_PORT_WIDTH		ushort
+#define FLASH_PORT_WIDTHV		vu_short
+#define SWAP(x)               		x
+#else
+#define FLASH_PORT_WIDTH		ulong
+#define FLASH_PORT_WIDTHV		vu_long
+#define SWAP(x)               		__swab32(x)
+#endif
+
+#define FPW	   FLASH_PORT_WIDTH
+#define FPWV   FLASH_PORT_WIDTHV
+
+#define mb() __asm__ __volatile__ ("" : : : "memory")
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static ulong flash_get_size (FPW * addr, flash_info_t * info);
+static int write_data (flash_info_t * info, ulong dest, FPW data);
+static void flash_get_offsets (ulong base, flash_info_t * info);
+void inline spin_wheel (void);
+
+/*-----------------------------------------------------------------------
+ */
+
+unsigned long flash_init (void)
+{
+	int i;
+	ulong size = 0;
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
+		switch (i) {
+		case 0:
+			flash_get_size ((FPW *) PHYS_FLASH_1, &flash_info[i]);
+			flash_get_offsets (PHYS_FLASH_1, &flash_info[i]);
+			break;
+		default:
+			panic ("configured too many flash banks!\n");
+			break;
+		}
+		size += flash_info[i].size;
+	}
+
+	/* Protect monitor and environment sectors
+	 */
+	flash_protect (FLAG_PROTECT_SET,
+		       CFG_FLASH_BASE,
+		       CFG_FLASH_BASE + _bss_start - _armboot_start,
+		       &flash_info[0]);
+
+	flash_protect (FLAG_PROTECT_SET,
+		       CFG_ENV_ADDR,
+		       CFG_ENV_ADDR + CFG_ENV_SIZE - 1, &flash_info[0]);
+
+	return size;
+}
+
+/*-----------------------------------------------------------------------
+ */
+static void flash_get_offsets (ulong base, flash_info_t * info)
+{
+	int i;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		return;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL) {
+		for (i = 0; i < info->sector_count; i++) {
+			info->start[i] = base + (i * PHYS_FLASH_SECT_SIZE);
+			info->protect[i] = 0;
+		}
+	}
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		printf ("missing or unknown FLASH type\n");
+		return;
+	}
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case FLASH_MAN_INTEL:
+		printf ("INTEL ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case FLASH_28F128J3A:
+		printf ("28F128J3A\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+		info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; ++i) {
+		if ((i % 5) == 0)
+			printf ("\n   ");
+		printf (" %08lX%s",
+			info->start[i], info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+	return;
+}
+
+/*
+ * The following code cannot be run from FLASH!
+ */
+static ulong flash_get_size (FPW * addr, flash_info_t * info)
+{
+	volatile FPW value;
+
+	/* Write auto select command: read Manufacturer ID */
+	addr[0x5555] = (FPW) 0x00AA00AA;
+	addr[0x2AAA] = (FPW) 0x00550055;
+	addr[0x5555] = (FPW) 0x00900090;
+
+	mb ();
+	value = addr[0];
+
+	switch (value) {
+
+	case (FPW) INTEL_MANUFACT:
+		info->flash_id = FLASH_MAN_INTEL;
+		break;
+
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		addr[0] = (FPW) 0x00FF00FF;	/* restore read mode */
+		return (0);	/* no or unknown flash  */
+	}
+
+	mb ();
+	value = addr[1];	/* device ID            */
+
+	switch (value) {
+
+	case (FPW) INTEL_ID_28F128J3A:
+		info->flash_id += FLASH_28F128J3A;
+		info->sector_count = 128;
+		info->size = 0x02000000;
+		break;		/* => 16 MB     */
+
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		break;
+	}
+
+	if (info->sector_count > CFG_MAX_FLASH_SECT) {
+		printf ("** ERROR: sector count %d > max (%d) **\n",
+			info->sector_count, CFG_MAX_FLASH_SECT);
+		info->sector_count = CFG_MAX_FLASH_SECT;
+	}
+
+	addr[0] = (FPW) 0x00FF00FF;	/* restore read mode */
+
+	return (info->size);
+}
+
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	int flag, prot, sect;
+	ulong type;
+	int rcode = 0;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		if (info->flash_id == FLASH_UNKNOWN) {
+			printf ("- missing\n");
+		} else {
+			printf ("- no sectors to erase\n");
+		}
+		return 1;
+	}
+
+	type = (info->flash_id & FLASH_VENDMASK);
+	if ((type != FLASH_MAN_INTEL)) {
+		printf ("Can't erase unknown flash type %08lx - aborted\n",
+			info->flash_id);
+		return 1;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+
+	if (prot) {
+		printf ("- Warning: %d protected sectors will not be erased!\n", prot);
+	} else {
+		printf ("\n");
+	}
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last; sect++) {
+		if (info->protect[sect] == 0) {	/* not protected */
+			FPWV *addr = (FPWV *) (info->start[sect]);
+			FPW status;
+
+			printf ("Erasing sector %2d ... ", sect);
+
+			/* arm simple, non interrupt dependent timer */
+			reset_timer_masked ();
+
+			*addr = (FPW) 0x00500050;	/* clear status register */
+			*addr = (FPW) 0x00200020;	/* erase setup */
+			*addr = (FPW) 0x00D000D0;	/* erase confirm */
+
+			while (((status =
+				 *addr) & (FPW) 0x00800080) !=
+			       (FPW) 0x00800080) {
+				if (get_timer_masked () >
+				    CFG_FLASH_ERASE_TOUT) {
+					printf ("Timeout\n");
+					*addr = (FPW) 0x00B000B0;	/* suspend erase         */
+					*addr = (FPW) 0x00FF00FF;	/* reset to read mode */
+					rcode = 1;
+					break;
+				}
+			}
+
+			*addr = (FPW) 0x00500050;	/* clear status register cmd.   */
+			*addr = (FPW) 0x00FF00FF;	/* resest to read mode          */
+
+			printf (" done\n");
+		}
+	}
+	return rcode;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ * 4 - Flash not identified
+ */
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong cp, wp;
+	FPW data;
+	int count, i, l, rc, port_width;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		return 4;
+	}
+
+/* get lower word aligned address */
+#ifdef FLASH_PORT_WIDTH16
+	wp = (addr & ~1);
+	port_width = 2;
+#else
+	wp = (addr & ~3);
+	port_width = 4;
+#endif
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+		for (; i < port_width && cnt > 0; ++i) {
+			data = (data << 8) | *src++;
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < port_width; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+
+		if ((rc = write_data (info, wp, SWAP (data))) != 0) {
+			return (rc);
+		}
+		wp += port_width;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	count = 0;
+	while (cnt >= port_width) {
+		data = 0;
+		for (i = 0; i < port_width; ++i) {
+			data = (data << 8) | *src++;
+		}
+		if ((rc = write_data (info, wp, SWAP (data))) != 0) {
+			return (rc);
+		}
+		wp += port_width;
+		cnt -= port_width;
+		if (count++ > 0x800) {
+			spin_wheel ();
+			count = 0;
+		}
+	}
+
+	if (cnt == 0) {
+		return (0);
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < port_width && cnt > 0; ++i, ++cp) {
+		data = (data << 8) | *src++;
+		--cnt;
+	}
+	for (; i < port_width; ++i, ++cp) {
+		data = (data << 8) | (*(uchar *) cp);
+	}
+
+	return (write_data (info, wp, SWAP (data)));
+}
+
+/*-----------------------------------------------------------------------
+ * Write a word or halfword to Flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+static int write_data (flash_info_t * info, ulong dest, FPW data)
+{
+	FPWV *addr = (FPWV *) dest;
+	ulong status;
+	int flag;
+
+	/* Check if Flash is (sufficiently) erased */
+	if ((*addr & data) != data) {
+		printf ("not erased at %08lx (%lx)\n", (ulong) addr,
+			(ulong) * addr);
+		return (2);
+	}
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts ();
+
+	*addr = (FPW) 0x00400040;	/* write setup */
+	*addr = data;
+
+	/* arm simple, non interrupt dependent timer */
+	reset_timer_masked ();
+
+	/* wait while polling the status register */
+	while (((status = *addr) & (FPW) 0x00800080) != (FPW) 0x00800080) {
+		if (get_timer_masked () > CFG_FLASH_WRITE_TOUT) {
+			*addr = (FPW) 0x00FF00FF;	/* restore read mode */
+			return (1);
+		}
+	}
+
+	*addr = (FPW) 0x00FF00FF;	/* restore read mode */
+
+	return (0);
+}
+
+void inline spin_wheel (void)
+{
+	static int p = 0;
+	static char w[] = "\\/-";
+
+	printf ("\010%c", w[p]);
+	(++p == 3) ? (p = 0) : 0;
+}
diff --git a/board/nslu2/nslu2.c b/board/nslu2/nslu2.c
new file mode 100644
index 0000000..9808517
--- /dev/null
+++ b/board/nslu2/nslu2.c
@@ -0,0 +1,106 @@
+/*
+ * (C) Copyright 2008
+ * Rod Whitby <rod@whitby.id.au>
+ *
+ * (C) Copyright 2006
+ * Stefan Roese, DENX Software Engineering, sr@denx.de.
+ *
+ * (C) Copyright 2002
+ * Kyle Harris, Nexus Technologies, Inc. kharris@nexus-tech.net
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <malloc.h>
+#include <asm/arch/ixp425.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/*
+ * Miscelaneous platform dependent initialisations
+ */
+int board_init (void)
+{
+	/* arch number of NSLU2 */
+	gd->bd->bi_arch_number = MACH_TYPE_NSLU2;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x00000100;
+
+	/*
+	 * Setup GPIO's for PCI INTA & INTB
+	 */
+	GPIO_OUTPUT_DISABLE(CFG_GPIO_PCI_INTA_N);
+	GPIO_INT_ACT_LOW_SET(CFG_GPIO_PCI_INTA_N);
+	GPIO_OUTPUT_DISABLE(CFG_GPIO_PCI_INTB_N);
+	GPIO_INT_ACT_LOW_SET(CFG_GPIO_PCI_INTB_N);
+
+	/*
+	 * Setup GPIO's for 33MHz clock output
+	 */
+	*IXP425_GPIO_GPCLKR = 0x01FF01FF;
+	GPIO_OUTPUT_ENABLE(CFG_GPIO_PCI_CLK);
+	GPIO_OUTPUT_ENABLE(CFG_GPIO_EXTBUS_CLK);
+
+	return 0;
+}
+
+/*
+ * Check Board Identity
+ */
+int checkboard(void)
+{
+	char *s = getenv("serial#");
+
+	puts("Board: NSLU2 - Linksys NSLU2");
+
+	if (s != NULL) {
+		puts(", serial# ");
+		puts(s);
+	}
+	putc('\n');
+
+	return (0);
+}
+
+int dram_init (void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size  = PHYS_SDRAM_1_SIZE;
+
+	return (0);
+}
+
+#if defined(CONFIG_CMD_PCI) || defined(CONFIG_PCI)
+extern struct pci_controller hose;
+extern void pci_ixp_init(struct pci_controller * hose);
+
+void pci_init_board(void)
+{
+	extern void pci_ixp_init (struct pci_controller *hose);
+
+	pci_ixp_init(&hose);
+}
+#endif
diff --git a/board/nslu2/u-boot.lds b/board/nslu2/u-boot.lds
new file mode 100644
index 0000000..58393d0
--- /dev/null
+++ b/board/nslu2/u-boot.lds
@@ -0,0 +1,56 @@
+/*
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-bigarm", "elf32-bigarm", "elf32-bigarm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  cpu/ixp/start.o	(.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss (NOLOAD) : { *(.bss) }
+	_end = .;
+}
diff --git a/cpu/ixp/npe/include/IxNpeMicrocode.h b/cpu/ixp/npe/include/IxNpeMicrocode.h
index 893d803..735ce4f 100644
--- a/cpu/ixp/npe/include/IxNpeMicrocode.h
+++ b/cpu/ixp/npe/include/IxNpeMicrocode.h
@@ -185,7 +185,7 @@
  *
  * @brief NPE Image Id for NPE-B with Ethernet Rx/Tx which includes: MAC_FILTERING, MAC_LEARNING, SPANNING_TREE, FIREWALL, VLAN_QOS
  */
-#define IX_NPEDL_NPEIMAGE_NPEB_ETH_LEARN_FILTER_SPAN_FIREWALL_VLAN_QOS 0x01010200
+#define IX_NPEDL_NPEIMAGE_NPEB_ETH_LEARN_FILTER_SPAN_FIREWALL_VLAN_QOS 0x01010201
 #endif
 
 #if IX_NPE_IMAGE_INCLUDE
@@ -230,7 +230,7 @@
  *
  * @brief NPE Image Id for NPE-C with Ethernet Rx/Tx which includes: MAC_FILTERING, MAC_LEARNING, SPANNING_TREE, FIREWALL, VLAN_QOS
  */
-#define IX_NPEDL_NPEIMAGE_NPEC_ETH_LEARN_FILTER_SPAN_FIREWALL_VLAN_QOS 0x02010200
+#define IX_NPEDL_NPEIMAGE_NPEC_ETH_LEARN_FILTER_SPAN_FIREWALL_VLAN_QOS 0x02010201
 #endif
 
 #if IX_NPE_IMAGE_INCLUDE
diff --git a/include/configs/nslu2.h b/include/configs/nslu2.h
new file mode 100644
index 0000000..281e435
--- /dev/null
+++ b/include/configs/nslu2.h
@@ -0,0 +1,253 @@
+/*
+ * (C) Copyright 2008
+ * Rod Whitby <rod@whitby.id.au>
+ *
+ * (C) Copyright 2005-2006
+ * Stefan Roese, DENX Software Engineering, sr@denx.de.
+ *
+ * (C) Copyright 2003
+ * Martijn de Gouw, Prodrive B.V., martijn.de.gouw@prodrive.nl
+ *
+ * Configuation settings for the NSLU2 board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_IXP425           1       /* This is an IXP425 CPU	*/
+#define CONFIG_NSLU2            1       /* on an NSLU2 Board		*/
+
+#define CONFIG_DISPLAY_CPUINFO	1	/* display cpu info (and speed)	*/
+#define CONFIG_DISPLAY_BOARDINFO 1	/* display board info		*/
+
+/*
+ * Ethernet
+ */
+#define CONFIG_IXP4XX_NPE	1	/* include IXP4xx NPE support	*/
+#define CONFIG_NET_MULTI	1
+#define	CONFIG_PHY_ADDR		4	/* NPE0 PHY address		*/
+#define CONFIG_MII		1	/* MII PHY management		*/
+#define CFG_RX_ETH_BUFFER	16	/* Number of ethernet rx buffers & descriptors */
+
+/*
+ * Misc configuration options
+ */
+#undef CONFIG_USE_IRQ			/* we don't need IRQ/FIQ stuff	*/
+#define CONFIG_USE_IRQ          1	/* we need IRQ stuff for timer	*/
+
+#define CONFIG_BOOTCOUNT_LIMIT		/* support for bootcount limit	*/
+#define CFG_BOOTCOUNT_ADDR	0x60003000 /* inside qmrg sram		*/
+
+#define CONFIG_CMDLINE_TAG	1	/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS 1
+#define CONFIG_INITRD_TAG	1
+
+/*
+ * Size of malloc() pool
+ */
+#define CFG_MALLOC_LEN		(256 << 10)
+#define CFG_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_BAUDRATE         115200
+#define CFG_IXP425_CONSOLE	IXP425_UART1   /* we use UART1 for console */
+
+
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PING
+
+/*
+#define CONFIG_PCI
+#define CONFIG_CMD_PCI
+*/
+
+#define CONFIG_ZERO_BOOTDELAY_CHECK	/* check for keypress on bootdelay==0 */
+#define CONFIG_BOOTDELAY	5	/* autoboot after 5 seconds	*/
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CFG_LONGHELP                            /* undef to save memory         */
+#define CFG_PROMPT              "=> "   /* Monitor Command Prompt       */
+#define CFG_CBSIZE              256             /* Console I/O Buffer Size      */
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size */
+#define CFG_MAXARGS             16              /* max number of command args   */
+#define CFG_BARGSIZE            CFG_CBSIZE      /* Boot Argument Buffer Size    */
+
+#define CFG_MEMTEST_START       0x00400000      /* memtest works on     */
+#define CFG_MEMTEST_END         0x00800000      /* 4 ... 8 MB in DRAM   */
+#define CFG_LOAD_ADDR           0x00010000      /* default load address */
+
+#undef  CFG_CLKS_IN_HZ          /* everything, incl board info, in Hz */
+#define CFG_HZ			1000		/* decrementer freq: 1 ms ticks */
+
+						/* valid baudrates */
+#define CFG_BAUDRATE_TABLE      { 9600, 19200, 38400, 57600, 115200 }
+
+/*
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE        (128*1024)      /* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ    (4*1024)        /* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ    (4*1024)        /* FIQ stack */
+#endif
+
+/***************************************************************
+ * Platform/Board specific defines start here.
+ ***************************************************************/
+
+/*-----------------------------------------------------------------------
+ * Default configuration (environment varibles...)
+ *----------------------------------------------------------------------*/
+#define CONFIG_PREBOOT	"echo;"	\
+	"echo Type \"run flash_nfs\" to mount root filesystem over NFS;" \
+	"echo"
+
+#undef	CONFIG_BOOTARGS
+
+#define	CONFIG_EXTRA_ENV_SETTINGS					\
+	"netdev=eth0\0"							\
+	"hostname=nslu2\0"						\
+	"nfsargs=setenv bootargs root=/dev/nfs rw "			\
+		"nfsroot=${serverip}:${rootpath}\0"			\
+	"ramargs=setenv bootargs root=/dev/ram rw\0"			\
+	"addip=setenv bootargs ${bootargs} "				\
+		"ip=${ipaddr}:${serverip}:${gatewayip}:${netmask}"	\
+		":${hostname}:${netdev}:off panic=1\0"			\
+	"addtty=setenv bootargs ${bootargs} console=ttyS0,${baudrate}\0"\
+	"flash_nfs=run nfsargs addip addtty;"				\
+		"bootm ${kernel_addr}\0"				\
+	"flash_self=run ramargs addip addtty;"				\
+		"bootm ${kernel_addr} ${ramdisk_addr}\0"		\
+	"net_nfs=tftp 200000 ${bootfile};run nfsargs addip addtty;"     \
+	        "bootm\0"						\
+	"rootpath=/opt/eldk/arm\0"					\
+	"bootfile=/tftpboot/nslu2/uImage\0"				\
+	"kernel_addr=50080000\0"					\
+	"ramdisk_addr=50200000\0"					\
+	"load=tftp 100000 /tftpboot/nslu2/u-boot.bin\0"		\
+	"update=protect off 50000000 5003ffff;era 50000000 5003ffff;"	\
+		"cp.b 100000 50000000 40000;"			        \
+		"setenv filesize;saveenv\0"				\
+	"upd=run load;run update\0"					\
+	""
+#define CONFIG_BOOTCOMMAND	"run net_nfs"
+
+/*
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS    1          /* we have 2 banks of DRAM */
+#define PHYS_SDRAM_1            0x00000000 /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE       0x02000000 /* 32 MB */
+
+#define PHYS_FLASH_1            0x50000000 /* Flash Bank #1 */
+#define PHYS_FLASH_SIZE         0x00800000 /* 8 MB */
+#define PHYS_FLASH_BANK_SIZE    0x00800000 /* 8 MB Banks */
+#define PHYS_FLASH_SECT_SIZE    0x00020000 /* 128 KB sectors (x1) */
+
+#define CFG_DRAM_BASE           0x00000000
+#define CFG_DRAM_SIZE           0x01000000
+
+#define CFG_FLASH_BASE          PHYS_FLASH_1
+#define CFG_MONITOR_BASE	CFG_FLASH_BASE
+#define CFG_MONITOR_LEN		(256 << 10)	/* Reserve 256 kB for Monitor	*/
+
+/*
+ * Expansion bus settings
+ */
+#define CFG_EXP_CS0		0xbcd23c42
+
+/*
+ * SDRAM settings
+ */
+#define CFG_SDR_CONFIG		0x18
+#define CFG_SDR_MODE_CONFIG	0x1
+#define CFG_SDRAM_REFRESH_CNT 	0x81a
+
+/*
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1       /* max number of memory banks           */
+#define CFG_MAX_FLASH_SECT      128 	/* max number of sectors on one chip    */
+
+#define CFG_FLASH_CFI				/* The flash is CFI compatible	*/
+#define CFG_FLASH_CFI_DRIVER			/* Use common CFI driver	*/
+#define	CFG_ENV_IS_IN_FLASH	1
+
+#define CFG_FLASH_USE_BUFFER_WRITE 1	/* use buffered writes (20x faster)	*/
+#define CFG_FLASH_PROTECTION	1	/* hardware flash protection		*/
+
+#define CFG_FLASH_CFI_WIDTH	FLASH_CFI_16BIT	/* no byte writes on IXP4xx	*/
+
+#define CFG_FLASH_ERASE_TOUT	120000	/* Timeout for Flash Erase (in ms)	*/
+#define CFG_FLASH_WRITE_TOUT	500	/* Timeout for Flash Write (in ms)	*/
+
+#define CFG_FLASH_EMPTY_INFO		/* print 'E' for empty sector on flinfo */
+
+#define CFG_ENV_SECT_SIZE	0x20000 	/* size of one complete sector	*/
+#define CFG_ENV_ADDR		(PHYS_FLASH_1 + 0x40000)
+#define	CFG_ENV_SIZE		0x2000	/* Total Size of Environment Sector	*/
+
+/* Address and size of Redundant Environment Sector	*/
+#define CFG_ENV_ADDR_REDUND	(CFG_ENV_ADDR + CFG_ENV_SECT_SIZE)
+#define CFG_ENV_SIZE_REDUND	(CFG_ENV_SIZE)
+
+/*
+ * GPIO settings
+ */
+#define CFG_GPIO_PCI_INTA_N	11
+#define CFG_GPIO_PCI_INTB_N	10
+#define CFG_GPIO_SWITCH_RESET_N	12
+#define CFG_GPIO_PCI_CLK	14
+#define CFG_GPIO_EXTBUS_CLK	15
+
+/*
+ * Cache Configuration
+ */
+#define CFG_CACHELINE_SIZE	32
+
+#endif  /* __CONFIG_H */
