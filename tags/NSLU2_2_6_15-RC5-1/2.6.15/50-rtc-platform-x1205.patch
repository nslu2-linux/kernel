 drivers/i2c/chips/Kconfig |    2 
 drivers/i2c/chips/x1205.c |  167 ++++++++++++++++++++++++++++++++++++++--------
 2 files changed, 139 insertions(+), 30 deletions(-)

--- linux-nslu2.orig/drivers/i2c/chips/x1205.c	2005-12-13 01:55:20.000000000 +0100
+++ linux-nslu2/drivers/i2c/chips/x1205.c	2005-12-13 02:22:50.000000000 +0100
@@ -18,13 +18,14 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/slab.h>
+#include <linux/err.h>
 #include <linux/i2c.h>
 #include <linux/string.h>
 #include <linux/bcd.h>
 #include <linux/rtc.h>
 #include <linux/delay.h>
 
-#define DRV_VERSION "1.0.1"
+#define DRV_VERSION "1.0.2"
 
 /* Addresses to scan: none. This chip is located at
  * 0x6f and uses a two bytes register addressing.
@@ -108,33 +109,6 @@ static struct i2c_driver x1205_driver = 
 	.detach_client	= &x1205_detach,
 };
 
-static const unsigned char days_in_mo[] =
-	{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
-
-#define is_leap(year) \
-	((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))
-
-/* make sure the rtc_time values are in bounds */
-static int x1205_validate_tm(struct rtc_time *tm)
-{
-	int year = tm->tm_year + 1900;
-
-	if ((tm->tm_year < 70) || (tm->tm_year > 255))
-		return -EINVAL;
-
-	if ((tm->tm_mon > 11) || (tm->tm_mday == 0))
-		return -EINVAL;
-
-	if (tm->tm_mday > days_in_mo[tm->tm_mon]
-		+ ((tm->tm_mon == 1) && is_leap(year)))
-		return -EINVAL;
-
-	if ((tm->tm_hour >= 24) || (tm->tm_min >= 60) || (tm->tm_sec >= 60))
-		return -EINVAL;
-
-	return 0;
-}
-
 /*
  * In the routines that deal directly with the x1205 hardware, we use
  * rtc_time -- month 0-11, hour 0-23, yr = calendar year-epoch
@@ -517,6 +491,120 @@ static int x1205_validate_client(struct 
 	return 0;
 }
 
+static int x1205_rtc_read_alarm(struct device *dev,
+	struct rtc_wkalrm *alrm)
+{
+	return x1205_get_datetime(to_i2c_client(dev),
+		&alrm->time, X1205_ALM0_BASE);
+}
+
+static int x1205_rtc_set_alarm(struct device *dev,
+	struct rtc_wkalrm *alrm)
+{
+	return x1205_set_datetime(to_i2c_client(dev),
+		&alrm->time, 1, X1205_ALM0_BASE);
+}
+
+static int x1205_rtc_read_time(struct device *dev,
+	struct rtc_time *tm)
+{
+	return x1205_get_datetime(to_i2c_client(dev),
+		tm, X1205_CCR_BASE);
+}
+
+static int x1205_rtc_set_time(struct device *dev,
+	struct rtc_time *tm)
+{
+	if ((rtc_valid_tm(tm)) < 0)
+		return -EINVAL;
+
+	return x1205_set_datetime(to_i2c_client(dev),
+		tm, 1, X1205_CCR_BASE);
+}
+
+static int x1205_rtc_set_mmss(struct device *dev, unsigned long secs)
+{
+	int err;
+
+	struct rtc_time new_tm, old_tm;
+
+	if ((err = x1205_rtc_read_time(dev, &old_tm) == 0))
+		return err;
+
+	/* FIXME      xtime.tv_nsec = old_tm.tm_sec * 10000000; */
+	new_tm.tm_sec  = secs % 60;
+	secs /= 60;
+	new_tm.tm_min  = secs % 60;
+	secs /= 60;
+	new_tm.tm_hour = secs % 24;
+
+       /*
+	* avoid writing when we're going to change the day
+	* of the month.  We will retry in the next minute.
+	* This basically means that if the RTC must not drift
+	* by more than 1 minute in 11 minutes.
+	*/
+	if ((old_tm.tm_hour == 23 && old_tm.tm_min == 59) ||
+	    (new_tm.tm_hour == 23 && new_tm.tm_min == 59))
+		return 1;
+
+	return x1205_rtc_set_time(dev, &new_tm);
+}
+
+static int x1205_rtc_proc(struct device *dev, char *buf)
+{
+	int err, dtrim, atrim;
+	char *p = buf;
+
+	p += sprintf(p, "24hr\t\t: yes\n");
+
+	err = x1205_get_dtrim(to_i2c_client(dev), &dtrim);
+	if (err == 0)
+		p += sprintf(p, "digital_trim\t: %d ppm\n", dtrim);
+
+	err = x1205_get_atrim(to_i2c_client(dev), &atrim);
+	if (err == 0)
+		p += sprintf(p, "analog_trim\t: %d.%02d pF\n",
+			atrim / 1000, atrim % 1000);
+
+	return p - buf;
+}
+
+struct rtc_class_ops x1205_rtc_ops = {
+	.owner = THIS_MODULE,
+	.proc = x1205_rtc_proc,
+	.read_time = x1205_rtc_read_time,
+	.set_time = x1205_rtc_set_time,
+	.read_alarm = x1205_rtc_read_alarm,
+	.set_alarm = x1205_rtc_set_alarm,
+	.set_mmss = x1205_rtc_set_mmss,
+};
+
+static ssize_t x1205_sysfs_show_atrim(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int atrim;
+
+        if (x1205_get_atrim(to_i2c_client(dev), &atrim) == 0) {
+                return sprintf(buf, "%d.%02d pF\n",
+                        atrim / 1000, atrim % 1000);        }
+        return 0;
+}
+static DEVICE_ATTR(atrim, S_IRUGO, x1205_sysfs_show_atrim, NULL);
+
+static ssize_t x1205_sysfs_show_dtrim(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int dtrim;
+
+        if (x1205_get_dtrim(to_i2c_client(dev), &dtrim) == 0) {
+                return sprintf(buf, "%d ppm\n", dtrim);
+        }
+        return 0;
+}
+static DEVICE_ATTR(dtrim, S_IRUGO, x1205_sysfs_show_dtrim, NULL);
+
+
 static int x1205_attach(struct i2c_adapter *adapter)
 {
 	dev_dbg(&adapter->dev, "%s\n", __FUNCTION__);
@@ -529,6 +617,7 @@ static int x1205_probe(struct i2c_adapte
 	int err = 0;
 	unsigned char sr;
 	struct i2c_client *client;
+	struct class_device *class_dev;
 
 	dev_dbg(&adapter->dev, "%s\n", __FUNCTION__);
 
@@ -542,7 +631,7 @@ static int x1205_probe(struct i2c_adapte
 		goto exit;
 	}
 
-	/* Initialize our structures */
+	/* I2C client */
 	client->addr = address;
 	client->driver = &x1205_driver;
 	client->adapter	= adapter;
@@ -563,6 +652,16 @@ static int x1205_probe(struct i2c_adapte
 
 	dev_info(&client->dev, "chip found, driver version " DRV_VERSION "\n");
 
+	class_dev = rtc_device_register(&client->dev, &x1205_rtc_ops);
+	if (IS_ERR(class_dev)) {
+		err = PTR_ERR(class_dev);
+		dev_err(&client->dev,
+			"unable to register the class device\n");
+		goto exit_detach;
+	}
+
+	i2c_set_clientdata(client, class_dev);
+
 	/* Check for power failures and eventualy enable the osc */
 	if ((err = x1205_get_status(client, &sr)) == 0) {
 		if (sr & X1205_SR_RTCF) {
@@ -583,8 +682,14 @@ static int x1205_probe(struct i2c_adapte
 				"unable to set the system clock\n");
 	}
 
+	device_create_file(&client->dev, &dev_attr_atrim);
+	device_create_file(&client->dev, &dev_attr_dtrim);
+
 	return 0;
 
+exit_detach:
+	i2c_detach_client(client);
+
 exit_kfree:
 	kfree(client);
 
@@ -595,9 +700,13 @@ exit:
 static int x1205_detach(struct i2c_client *client)
 {
 	int err;
+	struct class_device *class_dev = i2c_get_clientdata(client);
 
 	dev_dbg(&client->dev, "%s\n", __FUNCTION__);
 
+ 	if (class_dev)
+		rtc_device_unregister(class_dev);
+
 	if ((err = i2c_detach_client(client)))
 		return err;
 
--- linux-nslu2.orig/drivers/i2c/chips/Kconfig	2005-12-13 01:55:20.000000000 +0100
+++ linux-nslu2/drivers/i2c/chips/Kconfig	2005-12-13 01:59:16.000000000 +0100
@@ -128,7 +128,7 @@ config SENSORS_MAX6875
 
 config RTC_X1205_I2C
 	tristate "Xicor X1205 RTC chip"
-	depends on I2C && EXPERIMENTAL
+	depends on I2C && EXPERIMENTAL && RTC_CLASS
 	help
 	  If you say yes here you get support for the
 	  Xicor/Intersil X1205 RTC chip.
