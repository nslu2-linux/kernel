--- /dev/null	2005-10-05 21:35:01.000000000 +0930
+++ linux-2.6.12.2/drivers/i2c/chips/x1205-rtc.c	2005-10-11 10:56:06.955670128 +0930
@@ -0,0 +1,676 @@
+/*
+    x1205 - an 12c driver for the Xicor X1205 RTC
+    Copyright 2004 Karen Spearel
+
+    please send all reports to:
+	kas11 at tampabay dot rr dot com
+      
+    based on linux/drivers/acron/char/pcf8583.h
+    Copyright (C) 2000 Russell King
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+/*
+
+ * i2c_adapter is the structure used to identify a physical i2c bus along
+ * with the access algorithms necessary to access it.
+
+struct i2c_adapter {
+	struct module *owner;
+	unsigned int id;  == is algo->id | hwdep.struct->id, for registered values see below
+	unsigned int class;
+	struct i2c_algorithm *algo; the algorithm to access the bus
+	void *algo_data;
+
+	--- administration stuff.
+	int (*client_register)(struct i2c_client *);
+	int (*client_unregister)(struct i2c_client *);
+
+	 data fields that are valid for all devices
+	struct semaphore bus_lock;
+	struct semaphore clist_lock;
+
+	int timeout;
+	int retries;
+	struct device dev;		the adapter device 
+	struct class_device class_dev;	the class device
+
+#ifdef CONFIG_PROC_FS 
+	No need to set this when you initialize the adapter
+	int inode;
+#endif def CONFIG_PROC_FS
+
+	int nr;
+	struct list_head clients;
+	struct list_head list;
+	char name[I2C_NAME_SIZE];
+	struct completion dev_released;
+	struct completion class_dev_released;
+};
+*/
+
+
+/*========== Driver for the X1205 on the Linksys NSLU2 ==================*/
+
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/bcd.h>
+#include <linux/rtc.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/miscdevice.h>
+#include <linux/device.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <linux/moduleparam.h>
+
+#define		RTC_GETDATETIME		0
+#define		RTC_SETTIME		1
+#define		RTC_SETDATETIME		2
+
+#define		I2C_M_WR		0	// just for consistancy
+
+//  offsets into read buf - add 2 for write buf
+#define		CCR_SEC			0
+#define		CCR_MIN			1
+#define		CCR_HOUR		2
+#define		CCR_MDAY		3
+#define		CCR_MONTH		4
+#define		CCR_YEAR		5
+#define		CCR_WDAY		6
+#define		CCR_Y2K			7
+
+#define		X1205_I2C_BUS_ADDR	0x6f	// hardwired into x1205
+#define		X1205_ALM0_BASE		0x00	// Base address of the ALM0
+#define		X1205_CCR_BASE		0x30	// Base address of the CCR
+#define		X1205_SR_ADDR		0x3f	// Status Register
+#define		X1205_SR_WEL		0x02	// Write Enable Latch bit
+#define		X1205_SR_RWEL		0x04	// Register Write Enable Bit
+#define		X1205_MILBIT		0x80	// this bit set in ccr.hour for 24 hr mode
+#define		NOERR			0
+#define		RTC_NODATE		0
+#define		RTC_DATETOO		1
+
+// comment out next line is your x1205 can't do page writes
+//#define 	X1205PAGEWRITE		1
+#ifdef X1205PAGEWRITE
+#define		DRIVERNAME		"Xicor x1205 RTC Driver v0.9.3.3"
+#else
+#define		DRIVERNAME		"Xicor x1205 RTC Dvr v0.9.3.3NPW"
+#endif
+
+#define		DEBUG			KERN_DEBUG
+/* This, if defined to 1, turns on a lot of debugging meessages. */
+#if X1205_DEBUG
+#define x1205_debug(args) printk args
+#else
+#define x1205_debug(args) ((void)0)
+#endif
+
+
+static int x1205_get_datetime(struct i2c_client *client, struct rtc_time *tm, u8 reg_base);
+static int x1205_set_datetime(struct i2c_client *client, struct rtc_time *tm, int datetoo, u8 reg_base);
+static int x1205_attach(struct i2c_adapter *adapter);
+static int x1205_detach(struct i2c_client *client);
+static int x1205_validate_tm(struct rtc_time *tm, int datetoo);
+static int x1205_command(struct i2c_client *client, unsigned int cmd, void *arg);
+static int x1205_sync_rtc(void);
+static int x1205_read(struct file *file, char *buf, size_t count, loff_t *ptr);
+static int x1205_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
+static int x1205_read_proc(char *buf, char **start, off_t off, int len, int *eof, void *data);
+
+static struct i2c_driver x1205_driver = {
+	.owner		= THIS_MODULE,
+	.name		= DRIVERNAME,
+	.id		= I2C_DRIVERID_X1205,
+	.flags		= I2C_DF_NOTIFY,
+	.attach_adapter = &x1205_attach,		//we don't need to probe...x1205 is hardwired @ 0x6f
+	.detach_client	= &x1205_detach,
+	.command	= &x1205_command,		//this prolly never gets called...used internally tho
+};
+
+static struct i2c_client x1205_i2c_client = {
+	.flags		=	0,
+	.addr		=	X1205_I2C_BUS_ADDR,	// chip address - NOTE: 7bit
+	.adapter	=	NULL,			// the adapter we sit on assigned in attach
+	.driver		=	&x1205_driver,		// and our access routines
+	.usage_count	=	0,			// How many accesses currently to this client
+	.dev		=	{},			// the device structure
+	.list		=	{},
+	.name		=	DRIVERNAME,
+	.released	=	{},
+};
+
+static struct file_operations rtc_fops = {
+	owner:		THIS_MODULE,
+	ioctl:		x1205_ioctl,
+	read:		x1205_read,
+};
+
+static struct miscdevice x1205_miscdev = {
+	.minor		= RTC_MINOR,
+	.name		= "rtc",
+	.fops		= &rtc_fops,
+};
+extern int (*set_rtc)(void);
+static unsigned epoch = 1900;		//coresponds to year 0
+static unsigned  rtc_epoch = 2000;
+static const unsigned char days_in_mo[] = 
+{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
+
+//===================================CODE======================================
+// in the routines that deal directly with the x1205 hardware, we use
+// rtc_time -- month 0-11, hour 0-23, yr = calendar year-epoch
+// Epoch is inited as 2000. Time is set to UT
+//=============================================================================   
+static int x1205_get_datetime(struct i2c_client *client, struct rtc_time *tm, u8 reg_base)
+{
+	static unsigned char addr[2] = { 0,} ;
+	unsigned char buf[8];	
+	struct i2c_msg msgs[2] = {
+		{ client->addr, I2C_M_WR, 2, addr },	//msg 1 = send base address
+		{ client->addr, I2C_M_RD, 8, buf },	//msg 2 = read sequential data
+	};
+	addr[1] = reg_base;
+	if ((i2c_transfer(client->adapter, msgs, 2)) == 2) {	//did we read 2 messages?
+		x1205_debug((KERN_DEBUG "raw x1205 read data  - sec-%02x min-%02x hr-%02x mday-%02x mon-%02x year-%02x wday-%02x y2k-%02x\n", 
+			buf[0],buf[1],buf[2],buf[3],buf[4],buf[5],buf[6], buf[7]));
+		tm->tm_sec  = BCD2BIN(buf[CCR_SEC]);
+		tm->tm_min  = BCD2BIN(buf[CCR_MIN]);
+		buf[CCR_HOUR] &= ~X1205_MILBIT;
+		tm->tm_hour = BCD2BIN(buf[CCR_HOUR]);		//hr is 0-23
+		tm->tm_mday = BCD2BIN(buf[CCR_MDAY]);
+		tm->tm_mon  = BCD2BIN(buf[CCR_MONTH]);
+		rtc_epoch   = BCD2BIN(buf[CCR_Y2K]) * 100;
+		tm->tm_year = BCD2BIN(buf[CCR_YEAR]) + rtc_epoch - epoch;
+		tm->tm_wday = buf[CCR_WDAY];
+		x1205_debug((KERN_DEBUG "rtc_time output data - sec-%02d min-%02d hr-%02d mday-%02d mon-%02d year-%02d wday-%02d epoch-%d rtc_epoch-%d\n",
+			tm->tm_sec,tm->tm_min,tm->tm_hour,tm->tm_mday,tm->tm_mon,tm->tm_year,tm->tm_wday,epoch, rtc_epoch));
+	} else {
+		printk(KERN_DEBUG "i2c_transfer Read Error\n");
+		return -EIO;
+	}		
+	
+	return NOERR;
+}
+// x1205pagewrite allows writing a block of registers in msg3 even though the x1205 says
+// nothing about this in its spec. 
+// it needs more testing as it is possible some x1205s are actually not-completely-
+// functional x1226s and there is a reason for the multiple write to not be in the spec.
+// anyhow, it is enabled for the time being...and we even push out luck by sending 10 bytes
+
+static int x1205_set_datetime(struct i2c_client *client, struct rtc_time *tm, int datetoo, u8 reg_base)
+{
+	static unsigned char wel[3]   = { 0, X1205_SR_ADDR, X1205_SR_WEL };
+	static unsigned char rwel[3]  = { 0, X1205_SR_ADDR, X1205_SR_WEL | X1205_SR_RWEL };
+	static unsigned char diswe[3] = { 0, X1205_SR_ADDR, 0 };
+
+#ifdef X1205PAGEWRITE
+
+	static unsigned char buf[10]   = { 0, X1205_CCR_BASE, };		
+	struct i2c_msg msgs[4] = {
+		{ client->addr, I2C_M_WR, 3, wel   },	//msg 1 = write WEL to to ccr sr
+		{ client->addr, I2C_M_WR, 3, rwel  },	//msg 2 = write RWEL to ccr sr
+		{ client->addr, I2C_M_WR, 10, buf   },	//msg 3 = write ccr base addr +seq data
+		{ client->addr, I2C_M_WR, 3, diswe },	//msg 4 = 0 to ccr sr to disable writes
+	};
+
+	msgs[2].len = 5;					// 5 bytes + addr to set time only
+	buf [1] = reg_base;
+	buf[CCR_SEC+2]  = BIN2BCD(tm->tm_sec);
+	buf[CCR_MIN+2]  = BIN2BCD(tm->tm_min);
+	buf[CCR_HOUR+2] = BIN2BCD(tm->tm_hour) | X1205_MILBIT; // set 24 hour format
+	if (datetoo == 1) {
+		buf[CCR_MDAY+2]  = BIN2BCD(tm->tm_mday);
+		buf[CCR_MONTH+2] = BIN2BCD(tm->tm_mon);		// input is 0-11	
+		buf[CCR_YEAR+2]  = BIN2BCD((tm->tm_year + epoch - rtc_epoch));	// input is yrs since 1900
+		buf[CCR_WDAY+2]  = tm->tm_wday & 7;
+		buf[CCR_Y2K+2]   = BIN2BCD((rtc_epoch/100));
+		msgs[2].len += 5;				//5 more bytes to set date
+	}
+	x1205_debug((KERN_DEBUG "rtc_time input - sec-%02d min-%02d hour-%02d mday-%02d mon-%02d year-%02d wday-%02d epoch-%d rtc_epoch-%d\n",
+		tm->tm_sec,tm->tm_min,tm->tm_hour,tm->tm_mday,tm->tm_mon,tm->tm_year,tm->tm_wday, epoch, rtc_epoch));
+	x1205_debug((KERN_DEBUG "BCD write data - sec-%02x min-%02x hour-%02x mday-%02x mon-%02x year-%02x wday-%02x y2k-%02x\n",
+		buf[2],buf[3],buf[4],buf[5],buf[6], buf[7], buf[8], buf[9]));
+
+	if ((i2c_transfer(client->adapter, msgs, 4)) != 4)
+		return -EIO;
+	return NOERR;
+	
+#else		//do this if page writes aren't working
+
+	int i,xfer,count;
+	static unsigned char data[3]  = { 0,};
+	static unsigned char buf[8];
+
+	buf[CCR_SEC]  = BIN2BCD(tm->tm_sec);
+	buf[CCR_MIN]  = BIN2BCD(tm->tm_min);
+	buf[CCR_HOUR] = BIN2BCD(tm->tm_hour) | X1205_MILBIT; // set 24 hour format
+	count = CCR_HOUR+1;
+	if (datetoo == 1) {
+		buf[CCR_MDAY]  = BIN2BCD(tm->tm_mday);
+		buf[CCR_MONTH] = BIN2BCD(tm->tm_mon);		// input is 0-11	
+		buf[CCR_YEAR]  = BIN2BCD((tm->tm_year + epoch - rtc_epoch));	// input is yrs since 1900
+		buf[CCR_WDAY]  = tm->tm_wday & 7;
+		buf[CCR_Y2K]   = BIN2BCD((rtc_epoch/100));
+		count = CCR_Y2K+1;
+	}
+	x1205_debug((KERN_DEBUG "rtc_time input - sec-%02d min-%02d hour-%02d mday-%02d mon-%02d year-%02d wday-%02d epoch-%d rtc_epoch-%d\n",
+		tm->tm_sec,tm->tm_min,tm->tm_hour,tm->tm_mday,tm->tm_mon,tm->tm_year,tm->tm_wday, epoch, rtc_epoch));
+
+	xfer = i2c_master_send(client, wel, 3);
+	x1205_debug((KERN_DEBUG "wen - %x\n", xfer));
+	if (xfer != 3)
+		return -EIO;
+
+	xfer = i2c_master_send(client, rwel, 3);
+	x1205_debug((KERN_DEBUG "wenb - %x\n", xfer));
+	if (xfer != 3)
+		return -EIO;
+
+	for (i = 0; i < count; i++) {
+		data[1] = i + reg_base;
+		data[2] =  buf[i];
+		xfer = i2c_master_send(client, data, 3);
+		x1205_debug((KERN_DEBUG "xfer - %d addr - %02x  data - %02x\n", xfer, data[1], data[2]));
+		if (xfer != 3)
+			return -EIO;
+	};
+
+	xfer = i2c_master_send(client, diswe, 3);
+	x1205_debug((KERN_DEBUG "wdis - %x\n", xfer));
+	if (xfer != 3)
+		return -EIO;
+	return NOERR;
+#endif
+}
+//=============================================================================
+
+static int x1205_attach(struct i2c_adapter *adapter)
+{
+	struct rtc_time tm;
+	struct timespec tv;
+	int errno;
+		
+	x1205_i2c_client.adapter = adapter;
+
+	if ((x1205_get_datetime(&x1205_i2c_client, &tm, X1205_CCR_BASE)) != NOERR)	//test for functional driver 
+		return -EIO;
+	
+	if ((errno = i2c_attach_client(&x1205_i2c_client)) != NOERR)
+		return errno;
+
+	/* IMPORTANT: the RTC only stores whole seconds.  It is arbitrary whether
+	 * it stores the most close value or the value with partial seconds
+	 * truncated, however it is important for x1205_sync_rtc that it be
+	 * defined to store the truncated value.  This is because otherwise it
+	 * is necessary to read both xtime.tv_sec and xtime.tv_nsec in the
+	 * sync function, and atomic reads of >32bits on ARM are not possible.
+	 * So storing the most close value would slow down the sync API.  So
+	 * Here we have the truncated value and the best guess is to add 0.5s
+	 */
+	tv.tv_nsec = NSEC_PER_SEC >> 1;
+	/* WARNING: this is not the C library 'mktime' call, it is a built in
+	 * inline function from include/linux/time.h.  It expects (requires)
+	 * the month to be in the range 1-12
+	 */
+	tv.tv_sec  = mktime(tm.tm_year+epoch, tm.tm_mon+1, tm.tm_mday, tm.tm_hour,
+						tm.tm_min, tm.tm_sec);
+	do_settimeofday(&tv);
+	set_rtc = x1205_sync_rtc;
+	
+	printk(KERN_DEBUG "%s attached on adapter %s\n",x1205_i2c_client.name,
+		x1205_i2c_client.adapter->name); //why is this name a null string?
+
+	return NOERR;
+}
+
+static int x1205_detach(struct i2c_client *client)
+{
+	int errno;
+	
+	if ((errno = i2c_detach_client(client)) != 0) {
+		printk(KERN_DEBUG "i2c_detach failed - errno = %d\n", errno);
+		return errno;
+	}
+
+	return NOERR;
+}
+
+// make sure the rtc_time values are in bounds
+static int x1205_validate_tm(struct rtc_time *tm, int datetoo)
+{
+	if (datetoo) {
+		/* This used to be 1900, not epoch, but all the read APIs subtract
+		 * epoch, not 1900, and the result of these APIs *is* fed back in
+		 * to x1205_command (which calls this.)
+		 */
+		tm->tm_year += epoch;
+
+		/* The RTC uses a byte containing a BCD year value, so this is
+		 * limited to the range 0..99 from rtc_epoch.
+		 */
+		if ((tm->tm_year < rtc_epoch || tm->tm_year > rtc_epoch + 99) ||
+			((tm->tm_mon > 11) || tm->tm_mon < 0 || (tm->tm_mday <= 0)) ||
+			(tm->tm_mday > (days_in_mo[tm->tm_mon] + ( (tm->tm_mon == 1) && 
+			((!(tm->tm_year % 4) && (tm->tm_year % 100) ) || !(tm->tm_year % 400)))))
+			) {
+			printk(KERN_DEBUG "x1205_validate_tm: invalid date:\t%04d,%02d,%02d\n",
+					tm->tm_year, tm->tm_mon, tm->tm_mday);
+			return -EINVAL;
+		}
+
+		tm->tm_year -= epoch;
+	}
+
+	if (((tm->tm_hour < 0) || (tm->tm_min < 0) || (tm->tm_sec < 0)) ||
+		((tm->tm_hour >= 24) || (tm->tm_min >= 60) || (tm->tm_sec >= 60))) {
+		printk(KERN_DEBUG "x1205_validate_tm: invalid time:\t%02d,%02d,%02d\n",
+			tm->tm_hour, tm->tm_min, tm->tm_sec);
+		return -EINVAL;
+	}
+
+	return NOERR;
+}
+
+static int x1205_command(struct i2c_client *client, unsigned int cmd, void *tm)
+{
+	int errno, dodate = RTC_DATETOO;
+
+	if (client == NULL || tm == NULL)
+		return -EINVAL;
+	if (!capable(CAP_SYS_TIME))
+		return -EACCES;
+
+	x1205_debug((KERN_DEBUG "x1205_command %d\n", cmd));
+
+	switch (cmd) {
+	case RTC_GETDATETIME:
+		return x1205_get_datetime(client, tm, X1205_CCR_BASE);
+
+	case RTC_SETTIME:		// note fall thru
+		dodate = RTC_NODATE;
+	case RTC_SETDATETIME:
+		if ((errno = x1205_validate_tm(tm, dodate)) < NOERR)
+			return errno;
+		return x1205_set_datetime(client, tm, dodate, X1205_CCR_BASE);
+
+	default:
+		return -EINVAL;
+	}
+}
+
+static int x1205_sync_rtc(void)
+{
+	/* sync to xtime, tv_nsec is ignored (see the command above about
+	 * use of the truncated value) so this is pretty easy.  kas11's
+	 * code took are to do RTC_SETTIME - i.e. not set the date.  My
+	 * assumption is that this may be because date setting is slow, so
+	 * this feature is retained.  NTP does a sync when the time is
+	 * changed, including significant changes.  The sync needs to
+	 * set the date correctly if necessary.
+	 */
+	struct rtc_time tm;
+	time_t new_s, old_s, div, rem;
+	unsigned int cmd;
+
+	x1205_debug((KERN_DEBUG "x1205_sync_rtc entry\n"));
+
+	{
+		int err = x1205_command(&x1205_i2c_client, RTC_GETDATETIME, &tm);
+		if (err != NOERR) {
+			printk(KERN_DEBUG "x1205_sync_rtc exit (failed to get date)\n");
+			return err;
+		}
+	}
+
+	old_s = mktime(tm.tm_year+epoch, tm.tm_mon+1, tm.tm_mday,
+			tm.tm_hour, tm.tm_min, tm.tm_sec);
+	new_s = xtime.tv_sec;
+
+	/* Optimisation, the clock only stores seconds so it's pointless
+	 * to reset it if it is within 1s of now.
+	 */
+	if (old_s - 1 <= new_s && new_s <= old_s + 1) {
+		x1205_debug((KERN_DEBUG "x1205_sync_rtc exit (RTC in sync)\n"));
+		return NOERR;
+	}
+
+	div = new_s / 60;
+	tm.tm_sec = new_s - div*60;
+	rem = div;
+	div /= 60;
+	tm.tm_min = rem - div*60;
+	rem = div;
+	div /= 24;
+	tm.tm_hour = rem - div*24;
+
+	/* Now subtract the result from the original 'new' value.  This
+	 * should be zero, if not an mday change is required.  Notice
+	 * that this will tend to fire for small drifts close to UTC midnight.
+	 */
+	cmd = RTC_SETTIME;
+	rem = new_s - mktime(tm.tm_year+epoch, tm.tm_mon+1, tm.tm_mday,
+				tm.tm_hour, tm.tm_min, tm.tm_sec);
+	if (rem != 0) {
+		int dif;
+
+		/* Make an approximation to year/month/day. */
+		rem = div;
+		div = (2*div)/61;  // 30.5 days/month
+		tm.tm_mday = 1 + rem - (div*61)/2;
+		rem = div;
+		div /= 12;
+		rem -= 12*div;
+		while (tm.tm_mday > days_in_mo[rem]) {
+			tm.tm_mday -= days_in_mo[rem];
+			if (++rem >= 12) {
+				rem -= 12;
+				++div;
+			}
+		}
+		tm.tm_mon = rem;
+		div += 1970;       // base of tv_sec
+
+		/* Calculate the error in the approximation as a signed
+		 * int value.
+		 */
+		dif = new_s - mktime(div, tm.tm_mon+1, tm.tm_mday,
+				tm.tm_hour, tm.tm_min, tm.tm_sec);
+		while (dif < 0) {
+			--(tm.tm_mday);
+			dif += 86400;
+		}
+		while (dif >= 86400) {
+			++(tm.tm_mday);
+			dif -= 86400;
+		}
+		if (dif != 0)
+			printk(KERN_ERR "x1205_sync_rtc (error in date %d)\n", dif);
+
+		/* Normalise the result. */
+		while (tm.tm_mday <= 0) {
+			if (--(tm.tm_mon) < 0) {
+				tm.tm_mon += 12;
+				--div;
+			}
+			tm.tm_mday += days_in_mo[tm.tm_mon] + (tm.tm_mon==1 &&
+				((!(div % 4) && (div % 100) ) || !(div % 400)));
+		}
+
+		do {
+			rem = days_in_mo[tm.tm_mon] + (tm.tm_mon==1 &&
+				((!(div % 4) && (div % 100) ) || !(div % 400)));
+			if (tm.tm_mday > rem) {
+				tm.tm_mday -= rem;
+				if (++(tm.tm_mon) >= 12) {
+					tm.tm_mon -= 12;
+					++div;
+				}
+			} else {
+				break;
+			}
+		} while (1);
+
+		tm.tm_year = div-epoch;
+		cmd = RTC_SETDATETIME;
+		printk(KERN_DEBUG "x1205_sync_rtc exit (change date %d)\n", new_s-old_s);
+	} else {
+		printk(KERN_DEBUG "x1205_sync_rtc exit (change seconds %d)\n", new_s-old_s);
+		/* But avoid the race condition when the date is about to
+		 * change.
+		 */
+		if (tm.tm_min == 59 && tm.tm_hour == 23)
+			cmd = RTC_SETDATETIME;
+	}
+
+	return x1205_command(&x1205_i2c_client, cmd, &tm);
+}
+
+static int x1205_read(struct file *file, char *buf, size_t count, loff_t *ptr)
+{
+	struct rtc_time tm;
+
+	if ((x1205_get_datetime(&x1205_i2c_client, &tm, X1205_CCR_BASE)) < NOERR)
+		return -EIO;
+	return copy_to_user(buf, &tm, sizeof(tm)) ? -EFAULT : NOERR;
+}
+
+//==============================================================================
+
+static int x1205_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+		     unsigned long arg)
+{
+	struct rtc_time tm;
+	int errno;
+
+	x1205_debug((KERN_DEBUG "ioctl = %x\n", cmd));
+	
+	switch (cmd) {
+	case RTC_RD_TIME:
+		if ((x1205_get_datetime(&x1205_i2c_client, &tm, X1205_CCR_BASE)) < NOERR)
+			return -EIO;
+		break;
+		
+	case RTC_SET_TIME:
+		if (!capable(CAP_SYS_TIME))
+			return -EACCES;
+
+		if (copy_from_user(&tm, (struct rtc_time *) arg, sizeof(struct rtc_time))) 
+			return -EFAULT;
+		if ((errno = x1205_validate_tm(&tm, RTC_DATETOO)) < NOERR)
+			return errno;
+		return x1205_set_datetime(&x1205_i2c_client, &tm, RTC_DATETOO, X1205_CCR_BASE);
+
+	case RTC_ALM_SET:						//FIXME: set Control Regs
+		if (copy_from_user(&tm, (struct rtc_time *) arg, sizeof(struct rtc_time))) 
+			return -EFAULT;
+		return x1205_set_datetime(&x1205_i2c_client, &tm, RTC_DATETOO, X1205_ALM0_BASE);
+
+	case RTC_ALM_READ:
+		if ((x1205_get_datetime(&x1205_i2c_client, &tm, X1205_ALM0_BASE)) < NOERR)
+			return -EIO;
+		break;
+
+	case RTC_EPOCH_READ:
+
+		return put_user (epoch, (unsigned long __user *)arg);
+
+	case RTC_EPOCH_SET:
+		if (arg < 1900)
+			return -EINVAL;
+
+		if (!capable(CAP_SYS_TIME))
+			return -EACCES;
+
+		epoch = arg;
+		return 0;
+
+	default:
+		return -ENOTTY;
+	}
+	return copy_to_user((void __user *)arg, &tm, sizeof tm) ? -EFAULT : 0;
+
+}
+
+static int x1205_read_proc(char *buf, char **start, off_t off, int len, int *eof, void *data)
+{
+	struct rtc_time tm;
+	int slen, errno;
+
+	if ((errno = x1205_get_datetime(&x1205_i2c_client, &tm, X1205_CCR_BASE)) < NOERR)
+		return errno;
+
+//	here we return the real year and the month as 1-12 since it is human-readable
+	slen = sprintf(buf, "rtc_time\t: %02d:%02d:%02d\nrtc_date\t: %04d-%02d-%02d\n",
+		tm.tm_hour, tm.tm_min, tm.tm_sec, tm.tm_year + 1900, tm.tm_mon+1, tm.tm_mday);
+ 	x1205_debug((KERN_DEBUG "raw rtc_time\t: %02d:%02d:%02d\nraw rtc_date\t: %04d-%02d-%02d\n",
+		tm.tm_hour, tm.tm_min, tm.tm_sec, tm.tm_year, tm.tm_mon, tm.tm_mday));
+
+	if (slen <= off + len)
+		*eof = 1;
+	*start = buf + off;
+	slen -= off;
+	if (slen > len)
+		slen = len;
+	if ( slen < 0 )
+		slen = 0;
+
+	return slen;
+}
+
+static int __init x1205_init(void)
+{
+	struct	rtc_time tm;
+	int errno;
+	printk(KERN_INFO "LOADED %s\n", DRIVERNAME);
+
+	if ((errno = i2c_add_driver(&x1205_driver)) != NOERR) {
+		dev_dbg(x1205_i2c_client.dev, "x1205_init failed - errno = %d\n", errno);
+		return (errno);
+	}
+	if ((errno = misc_register(&x1205_miscdev)) != NOERR) {
+		dev_dbg(x1205_i2c_client.dev, "Register Misc Driver failed - errno = %d\n", errno);
+		i2c_del_driver(&x1205_driver);
+		return errno; 
+	}
+	if (create_proc_read_entry("driver/rtc", 0, NULL, x1205_read_proc, NULL) < NOERR)
+		return -ENOMEM;
+	if ((x1205_get_datetime(&x1205_i2c_client, &tm, X1205_CCR_BASE)) != NOERR)	//test for functionality
+		return -EIO;
+
+	return NOERR;	
+}
+
+static void __exit x1205_exit(void)
+{
+	remove_proc_entry("driver/rtc", NULL);
+	misc_deregister(&x1205_miscdev);
+	i2c_del_driver(&x1205_driver);
+	set_rtc = NULL;
+}
+
+MODULE_AUTHOR("Karen Spearel <kas11@tampabay.rr.com>");
+MODULE_DESCRIPTION("Xicor X1205-RTC Driver");
+MODULE_LICENSE("GPL");
+static int debug = 7;
+module_param(debug, bool, 0644);
+MODULE_PARM_DESC(debug, "Debugging enabled = 1");
+
+module_init(x1205_init);
+module_exit(x1205_exit);
--- /dev/null	2005-10-05 21:35:01.000000000 +0930
+++ linux-2.6.12.2/arch/arm/mach-ixp4xx/nslu2-io.c	2005-10-11 10:56:09.542276904 +0930
@@ -0,0 +1,698 @@
+//=============================================================================
+//
+// n2-io.c version 0.1.7
+// Author: Karen Spearel <kas11 at tampabay.rr.com>
+// please report problems/bugs directly to the address above
+//
+// Boilerplate to be added "real soon now"...it is and has always been GPL'ed per
+// MODULE_LICENSE but is offered without warrantee of any sort..use at your own risk
+//
+// NOTE: THIS IS INCOMPLETE.  INCLUDED ONLY TO KEEP FROM BREAKING THE BUILD,
+// IT BEEPS AND SENDS A MESSAGE TO /proc/poweroff.  EVENTUALLY IT
+// WILL TALK TO THE n2_pbd DAEMON.  EVENTUALLY THE LED DRIVER
+// WILL TALK TO SOME USERLAND APP BUT ***NOT*** SET_LEDS.
+// 
+//=============================================================================
+//	GPIO		Function	State
+//	0		Red LED		Status		
+//	1		Green LED	Ready = 1
+//	2		Disk 2 LED	On = 0
+//	3		Disk 1 LED	On = 0
+//	4		Buzzer
+//	5		Power Button	Pressed = 1
+//	8		Power Down	Output = 1 powers down N2
+//	12		Reset		Pressed = 0
+//=============================================================================
+// this driver is N2 specific and is purposely designed to do the minimum 
+// necessary to provide the necessary services given the limited memory resources
+// of the N2.  As OpenN2 develops, addition features will be added as
+// suggested by the community.
+//
+//=============================================================================
+
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/utsname.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/string.h>
+#include <linux/proc_fs.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/reboot.h>
+
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#include <asm/hardware.h>
+#include <asm-arm/irq.h>
+#include <asm-arm/delay.h>
+#include <asm-arm/signal.h>
+
+/* Set this to 1 to output lots of debug messages. */
+#if NSLU2_IO_DEBUG
+#define nslu2_io_debug(args) printk args
+#else
+#define nslu2_io_debug(args) ((void)0)
+#endif
+
+#define VERSION			"0.1.7"
+
+#define N2RB_MAJOR		60		//rbuttons
+#define N2PB_MAJOR		61		//pbuttons
+#define	N2BZ_MAJOR		62		//buzzer
+#define N2LM_MAJOR		126
+
+#define N2PB_IRQ		22		//gpio5
+#define	N2RB_IRQ		29		//gpio12
+
+#define N2_BEEP_DUR_LONG	2000
+#define N2_BEEP_DUR_MED		400
+#define N2_BEEP_DUR_SHORT	100
+#define N2_BEEP_PITCH_HIGH	250
+#define N2_BEEP_PITCH_MED	500
+#define N2_BEEP_PITCH_LOW	1000
+#define N2_LONG_DELAY		30000
+
+#define N2_BZ_GPIO		4
+#define N2_PB_GPIO		5
+#define N2_PO_GPIO		8		//power off
+#define N2_RB_GPIO		12
+
+#define GPIO_BZ_BM		0x0010	//b0000 0000 0001 0000
+#define GPIO_PB_BM		0x0020	//b0000 0000 0010 0000
+#define GPIO_PO_BM		0x0100  //b0000 0001 0000 0000
+#define GPIO_RB_BM		0x1000	//b0001 0000 0000 0000
+
+#define NOERR			0
+
+#define RB_DELAY		50
+#define PB_DELAY		20
+
+#define PWR_OFF_STR		"poweroff"
+
+
+// ioctls -- 'M" is used for sound cards...we don't got one so it seems safe
+
+#define N2BZ_BEEP_STOP		_IO('M',0)       //stop multi-beep at end of audible
+#define N2BZ_BEEP		_IO('M',1)       //one beep at current defaults
+#define N2BZ_BEEPS		_IOW('M',3,long) //param beeps at current defaults
+#define N2BZ_TONESET		_IOW('M',4,long) //set tone: range is high=250 to low=2000
+#define N2BZ_ONTIME		_IOW('M',5,long) //ontime for multi-beeps in jiffies
+#define	N2BZ_SILENTTIME		_IOW('M',6,long) //offtime for multi-beeps in jiffies
+#define N2BZ_REPEATCNT		_IOW('M',7,long) //number of repeats for multi-beeps 0 = forever
+#define N2BZ_COMBINED		_IOW('M',8,long) //combine all params in a long
+
+#define N2LM_OFF		_IOW('M',32,long)
+#define N2LM_ON			_IOW('M',33,long)
+#define N2LM_BLINK		_IOW('M',34,long)
+#define N2LM_ALT		_IOW('M',35,long)
+#define N2LM_ALL_ON		_IO('M',36)
+#define N2LM_ALL_OFF		_IO('M',37)
+
+#define PHYS_LEDS		4
+#define BLINK_DELAY		25
+
+//  OR Masks to turn these LEDs ON
+
+#define	RS_RED_ON	0x00000001	//0b0000 0000 0000 0010
+#define	RS_GRN_ON	0x00000002	//0b0000 0000 0000 0001
+#define RS_YEL_ON	0x00000003	//0b0000 0000 0000 0011
+
+// AND Masks to turn these LEDs OFF
+
+#define	RS_RED_OFF	0xfffffffe	//0b1111 1111 1111 1101
+#define	RS_GRN_OFF	0xfffffffd	//0b1111 1111 1111 1110
+#define RS_YEL_OFF	0xfffffffc	//0b1111 1111 1111 1100
+
+// AND Masks to turn these LEDs ON
+
+#define DISK1_ON	0xfffffff7	//0b1111 1111 1111 0111
+#define	DISK2_ON	0xfffffffb	//0b1111 1111 1111 1011
+
+// Or Masks to turn these LEDs OFF
+
+#define DISK1_OFF	0x00000008	//0b0000 0000 0000 1000
+#define	DISK2_OFF	0x00000004	//0b0000 0000 0000 0100	
+
+// EOR masks for toggling LEDs on/off
+
+#define RS_RG_ALT	0x00000003	//eor mask to toggle rs rg bits
+#define RS_GRN_TGL	0x00000002
+#define RS_RED_TGL	0x00000001
+#define DISK1_TGL	0x00000008
+#define DISK2_TGL	0x00000004
+
+// The LED names for switches
+
+#define LED_RS_RED	0
+#define LED_RS_GRN	1
+#define	LED_DISK1	2
+#define LED_DISK2	3
+#define LED_ALL		4
+
+static int nslu2_shutdown_in_progress = 0;
+
+static unsigned long init_jiffy = 0;			//jiffies at init time
+static unsigned long rb_presses = 0;			//number of reset button presses
+static unsigned long ontime = 50;
+static unsigned long offtime = 450;
+static unsigned long bz_repeatcnt = 10;
+static unsigned long tone = 1000;
+
+DECLARE_WAIT_QUEUE_HEAD(n2rb_waitq);
+DECLARE_WAIT_QUEUE_HEAD(n2pb_waitq);
+
+static struct timer_list n2lm_rsg_timer;	//rs green 
+static struct timer_list n2lm_rsr_timer;	//rs red
+static struct timer_list n2lm_d1_timer;		//drive 1
+static struct timer_list n2lm_d2_timer;		//drive 2
+static struct timer_list n2rb_timer;
+static struct timer_list n2pb_timer;
+static struct timer_list n2bz_timer;		//beeper
+
+// sysfs class
+static struct class_simple *n2lm_class;
+
+//==================================================================================================
+//
+// Blinking is handled entirely by the 4 timer handlers.  On timeout, the bit in the
+// GPIO output register is xor'd with a mask corresponding to the selected led which simply
+// flips that bit.  No record of what any of the other leds is doing is needed.
+//
+//==================================================================================================
+// this blinks rs green or green/yellow if rs red is on
+static void n2lm_rsg_handler(unsigned long data)
+{
+	*IXP4XX_GPIO_GPOUTR ^= RS_GRN_TGL;			//flip the led
+	n2lm_rsg_timer.expires = jiffies + BLINK_DELAY;		//next timeout
+	add_timer(&n2lm_rsg_timer);				//reinit timer
+	return;
+}
+
+// this blinks or alternates rs red green... inited wit green on/red off
+static void n2lm_rsr_handler(unsigned long data)
+{
+	*IXP4XX_GPIO_GPOUTR ^= n2lm_rsr_timer.data;
+	n2lm_rsr_timer.expires = jiffies + BLINK_DELAY;
+	add_timer(&n2lm_rsr_timer);
+	return;	
+}
+// blinks disk 1
+static void n2lm_d1_handler(unsigned long data)
+{
+	*IXP4XX_GPIO_GPOUTR ^= DISK1_TGL;
+	n2lm_d1_timer.expires = jiffies + BLINK_DELAY;
+	add_timer(&n2lm_d1_timer);
+	return;
+}
+// blinks disk 2
+static void n2lm_d2_handler(unsigned long data)
+{
+	*IXP4XX_GPIO_GPOUTR ^= DISK2_TGL;
+	n2lm_d2_timer.expires = jiffies + BLINK_DELAY;
+	add_timer(&n2lm_d2_timer);
+	return;
+}
+
+//==================================================================================================
+
+static void n2lm_timer_start(unsigned long led)
+{
+
+	nslu2_io_debug((KERN_DEBUG "timer: %ld\n",led));
+
+	switch(led) {
+		case LED_RS_RED:
+			n2lm_rsr_timer.expires = jiffies + BLINK_DELAY;
+			add_timer(&n2lm_rsr_timer);
+			break;
+
+		case LED_RS_GRN:
+			n2lm_rsg_timer.expires = jiffies + BLINK_DELAY;
+			add_timer(&n2lm_rsg_timer);
+			break;
+
+		case LED_DISK1:
+			n2lm_d1_timer.expires = jiffies + BLINK_DELAY;
+			add_timer(&n2lm_d1_timer);
+ 			break;
+
+		case LED_DISK2:
+			n2lm_d2_timer.expires = jiffies + BLINK_DELAY; 
+			add_timer(&n2lm_d2_timer);
+			break;
+
+		default:
+			break;
+	}
+	return;
+}
+
+//==================================================================================================
+
+static void n2lm_timer_stop(unsigned long led)
+{
+	switch (led) {
+		case LED_RS_RED:
+			del_timer(&n2lm_rsr_timer);
+			break;
+		case LED_RS_GRN:
+			del_timer(&n2lm_rsg_timer);
+			break;
+		case LED_DISK1:
+			del_timer(&n2lm_d1_timer);
+ 			break;
+		case LED_DISK2: 
+			del_timer(&n2lm_d2_timer);
+			break;
+		default:
+			break;
+	}
+	return;
+}
+
+//--------------------------------------------------------------------------------------------------
+
+static void n2lm_timer_stop_all(void)
+{
+	del_timer(&n2lm_rsg_timer);
+	del_timer(&n2lm_rsr_timer);
+	del_timer(&n2lm_d1_timer); 
+	del_timer(&n2lm_d2_timer);
+	return;
+}
+//--------------------------------------------------------------------------------------------------
+
+static void n2lm_ledon(unsigned long led)
+{
+
+	nslu2_io_debug((KERN_DEBUG "ledon: %ld\n", led));
+
+	switch (led) {
+		case LED_RS_RED:	
+			*IXP4XX_GPIO_GPOUTR |= RS_RED_ON;	//1
+			return;
+		case LED_RS_GRN:
+			*IXP4XX_GPIO_GPOUTR |= RS_GRN_ON;	//2
+			return;
+		case LED_DISK1:
+			*IXP4XX_GPIO_GPOUTR &= DISK1_ON;	//0xfffffff7
+			return;
+		case LED_DISK2:	
+			*IXP4XX_GPIO_GPOUTR &= DISK2_ON;	//0xfffffffb
+			return;
+		case LED_ALL:					//all green
+			*IXP4XX_GPIO_GPOUTR |= RS_GRN_ON;
+			*IXP4XX_GPIO_GPOUTR &= (DISK1_ON & DISK2_ON);
+			return;	
+	}
+}
+
+//--------------------------------------------------------------------------------------------------
+
+static void n2lm_ledoff(unsigned long led)
+{
+
+	switch (led) {
+		case LED_RS_RED:	
+			*IXP4XX_GPIO_GPOUTR &= RS_RED_OFF;	//0xffffffffe
+			return;
+		case LED_RS_GRN:
+			*IXP4XX_GPIO_GPOUTR &= RS_GRN_OFF;	//0xfffffffd
+			return;
+		case LED_DISK1:
+			*IXP4XX_GPIO_GPOUTR |= DISK1_OFF;	//0x00000008
+			return;
+		case LED_DISK2:	
+			*IXP4XX_GPIO_GPOUTR |= DISK2_OFF;	//0x00000004
+			return;
+		case LED_ALL:
+			*IXP4XX_GPIO_GPOUTR &= (RS_GRN_OFF & RS_RED_OFF);
+			*IXP4XX_GPIO_GPOUTR |= (DISK1_OFF | DISK2_OFF);
+	}
+}
+
+//==================================================================================================
+
+static int n2lm_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long led)
+{
+
+	nslu2_io_debug((KERN_DEBUG "cmd=%d, led=%ld\n", cmd, led));
+	
+	if (led < 0 || led >= PHYS_LEDS)
+		return -EINVAL;
+
+	switch (cmd ) {
+		case N2LM_ON:
+			n2lm_timer_stop(led);
+			n2lm_ledon(led);
+			break;
+			
+		case N2LM_OFF:
+			n2lm_timer_stop(led);
+			n2lm_ledoff(led);
+			break;
+			
+		case N2LM_BLINK:
+			n2lm_ledon(led);
+			if (led == LED_RS_RED)
+				n2lm_rsr_timer.data = RS_RED_TGL;
+			n2lm_timer_start(led);
+			break;
+
+		case N2LM_ALT:
+			if (led == LED_RS_RED)
+			{
+				n2lm_ledon(LED_RS_GRN);
+				n2lm_ledoff(LED_RS_RED);
+				n2lm_rsr_timer.data = RS_RG_ALT;
+				n2lm_timer_start(LED_RS_RED);
+				break;
+			} else
+				return -EINVAL;
+		
+		case N2LM_ALL_ON:
+			n2lm_timer_stop_all();
+			n2lm_ledon(LED_ALL);
+			break;
+		
+		case N2LM_ALL_OFF:
+			n2lm_timer_stop_all();
+			n2lm_ledoff(LED_ALL);
+			break;
+		
+		default:
+			return -EINVAL;
+	}
+
+	return NOERR;
+}
+
+static struct file_operations n2lm_fops = {
+	.owner		= THIS_MODULE,
+	.ioctl		= n2lm_ioctl,
+};
+//==================================================================================================
+// We can't do anything fancy here since the system tick rate is far below that required to
+// generate a desirable tone.  Therefore we haven't much choice but to use a busy loop until
+// I get up to speed on the timers.  The saving grace is that for the normal uses, nothing 
+// important should be haprepening. 
+//==================================================================================================
+
+static void n2_buzz(int tone_delay, int duration)
+{
+	int i;
+
+	*IXP4XX_GPIO_GPOER &= ~GPIO_BZ_BM;
+		
+	for (i = 1; i < duration; i++) {
+		*IXP4XX_GPIO_GPOUTR &= ~GPIO_BZ_BM;
+		udelay(tone_delay);
+		*IXP4XX_GPIO_GPOUTR |= GPIO_BZ_BM;
+		udelay(tone_delay);
+	}
+	*IXP4XX_GPIO_GPOER |= GPIO_BZ_BM;
+
+	return;
+}
+//=================================================================================================
+
+// this handles the buzzer duty cycle
+static void n2bz_handler(unsigned long data)
+{
+	if (--bz_repeatcnt > 0) {			//if just one beep left to do
+		n2bz_timer.expires = jiffies + ontime + offtime;	//next timeout
+		add_timer(&n2bz_timer);					//reinit timer
+	}
+	n2_buzz(tone/2, ontime);
+	nslu2_io_debug((KERN_DEBUG "Count = %d\tOntime = %d\n", bz_repeatcnt, ontime));
+	return;
+}
+
+//==================================================================================================
+
+static int n2bz_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long param)
+{
+	switch (cmd) {
+		case N2BZ_BEEP:
+			n2_buzz(tone/2, ontime);
+			break;
+	
+		case N2BZ_BEEP_STOP:
+			del_timer(&n2bz_timer);
+			break;
+
+		case N2BZ_BEEPS:
+			if (param == 0)
+				bz_repeatcnt = 0xffffffff;
+			else
+				bz_repeatcnt = param;
+			n2bz_handler(0);
+			break;
+	
+		case N2BZ_TONESET:
+			if (param >= 250 && param <= 2000)
+				tone = param;
+			break;
+
+		case N2BZ_ONTIME:
+			if (param > 4 && param < 201)
+				ontime = param;
+			break;
+
+		case N2BZ_SILENTTIME:
+			if (param > ontime)			//enforce a reasonable duty cycle
+				offtime = param;
+			else
+				offtime = ontime;
+			break;
+
+		case N2BZ_REPEATCNT:
+			if (param == 0)
+				bz_repeatcnt = 0xffffffff;
+			else
+				bz_repeatcnt = param;
+			break;
+
+		case N2BZ_COMBINED:
+			bz_repeatcnt =  (param & 0xF0000000) >> 28;	//repeat 1 - 16
+			ontime =        (param & 0x0FF00000) >> 20; 	//ontime 1 - 256 jiffies
+			offtime =       (param & 0x000FFF00) >> 8;	//offtime 1 - 4095 jiffies
+			tone =          (param & 0x000000FF) << 4;	//tone (1 - 255) * 16
+			break;
+
+		default:
+			break;
+	}
+	return NOERR;
+}
+
+static struct file_operations n2bz_fops = {
+	.owner		= THIS_MODULE,
+	.ioctl		= n2bz_ioctl,
+};
+
+//==================================================================================================
+		
+static irqreturn_t n2pb_handler (int irq, void *dev_id, struct pt_regs *regs)
+{
+	void *ret;
+	if (!nslu2_shutdown_in_progress++) {			
+		wake_up(&n2pb_waitq);	
+		remove_proc_entry(PWR_OFF_STR, NULL);		//no parent	
+		n2_buzz(N2_BEEP_PITCH_HIGH, N2_BEEP_DUR_SHORT); // Short, high-pitched "OK"
+		ret = create_proc_entry(PWR_OFF_STR, 0, NULL);
+		nslu2_io_debug((KERN_DEBUG "Powerbutton pressed. Shutting down. cpe ret = %p\n", ret));
+		kill_proc(1,SIGINT,1);				// Signal init to shut down
+	} else {
+	        n2_buzz(N2_BEEP_PITCH_LOW, N2_BEEP_DUR_MED);    // Make a scary noise!
+		nslu2_io_debug((KERN_DEBUG "Powerbutton pressed while already in shutdown")); // Whine!
+	}				 
+	return IRQ_HANDLED;
+}
+
+struct testr {
+	int	ctl;
+	long	param;
+};
+
+static irqreturn_t n2rb_handler (int irq, void *dev_id, struct pt_regs *regs)
+{
+//	This doesn't reset the NSLU2. It powers it off. Close enough, since reset is unreliable
+
+	wake_up(&n2rb_waitq);	
+	machine_power_off();
+	return IRQ_HANDLED;		// So we don't get a nobody cared error :-P
+}
+
+//==================================================================================================
+//  What to do here is majorly undetermined...
+
+static int n2rb_read (struct file *filp, char __user *buffer, size_t count, loff_t *ppos)
+{
+	printk(KERN_DEBUG "Reset Button Wait\n");
+	interruptible_sleep_on(&n2rb_waitq);
+	return copy_to_user(buffer, "reset", 5) ? -EFAULT : 5;
+
+}
+
+//==================================================================================================
+//  What to do here is majorly undetermined...
+
+static int n2pb_read (struct file *filp, char __user *buffer, size_t count, loff_t *ppos)
+{
+	printk(KERN_DEBUG "Power Button Wait\n");
+	interruptible_sleep_on(&n2pb_waitq);
+	return copy_to_user(buffer, "poweroff", 8) ? -EFAULT : 8;
+
+}
+
+//--------------------------------------------------------------------------------------------------
+
+static struct file_operations n2rb_fops = {
+	.owner		= THIS_MODULE,
+	.read		= n2rb_read,
+};
+
+//--------------------------------------------------------------------------------------------------
+
+static struct file_operations n2pb_fops = {
+	.owner		= THIS_MODULE,
+	.read		= n2pb_read,
+};
+
+//==================================================================================================
+
+static void n2iom_initarch(void)
+{
+	printk(KERN_DEBUG "setup_interrupts - jiffies=%ld init_jiffy=%ld\n", jiffies, init_jiffy);
+
+	*IXP4XX_GPIO_GPISR = 0x20400000;	// read the 2 irqs to clr
+	gpio_line_config(N2_RB_GPIO, IXP4XX_GPIO_IN | IXP4XX_GPIO_ACTIVE_LOW);
+	gpio_line_isr_clear(N2_RB_GPIO);
+	gpio_line_config(N2_PB_GPIO, IXP4XX_GPIO_IN | IXP4XX_GPIO_ACTIVE_HIGH);
+	gpio_line_isr_clear(N2_PB_GPIO);
+
+	init_timer(&n2lm_rsg_timer);
+	init_timer(&n2lm_rsr_timer);
+	init_timer(&n2lm_d1_timer);
+	init_timer(&n2lm_d2_timer);
+//	init_timer(&n2rb_timer);
+//	init_timer(&n2pb_timer);
+	init_timer(&n2bz_timer);
+	n2lm_rsr_timer.function = n2lm_rsr_handler;
+	n2lm_rsg_timer.function = n2lm_rsg_handler;
+	n2lm_d2_timer.function = n2lm_d2_handler;
+	n2lm_d1_timer.function = n2lm_d1_handler;
+	n2bz_timer.function = n2bz_handler;
+	n2lm_rsr_timer.data = n2lm_rsg_timer.data = n2lm_d1_timer.data = n2lm_d2_timer.data = n2bz_timer.data = 0;
+
+	*IXP4XX_GPIO_GPOER &= 0xfffffff0;	//enable gpio 0-3
+	*IXP4XX_GPIO_GPOUTR |= 0x00000003;	//turn off the leds
+	*IXP4XX_GPIO_GPOUTR &= 0xfffffffc;
+	n2lm_ledon(LED_ALL);
+	n2_buzz(N2_BEEP_PITCH_MED, N2_BEEP_DUR_SHORT);
+	n2lm_ledoff(LED_ALL);
+// Default the Ready/Status to Red during kernel boot, Turn Green at the end of sysvinit
+	n2lm_ledon(LED_RS_RED);
+
+	return;
+}
+
+//==================================================================================================
+
+static int __init n2iom_init(void)
+{
+	printk(KERN_INFO "OpenN2 Misc I/O Driver Version %s\n", VERSION);
+  	
+	init_jiffy = jiffies;
+	printk(KERN_DEBUG "init_jiffy=%ld\n",init_jiffy);
+	n2iom_initarch();
+
+	n2lm_class = class_simple_create(THIS_MODULE, "nslu2");
+
+	if (register_chrdev(N2RB_MAJOR, "n2_rbm", &n2pb_fops) < NOERR) {
+		printk(KERN_DEBUG "Reset Button Major %d not available\n", N2RB_MAJOR);
+		return -EBUSY;
+	}
+	else {
+		class_simple_device_add(n2lm_class, MKDEV(N2RB_MAJOR, 0), NULL, "rbuttons");
+	}
+	if (register_chrdev(N2PB_MAJOR, "n2_pbm", &n2rb_fops) < NOERR) {
+		printk(KERN_DEBUG "Power Button Major %d not available\n", N2PB_MAJOR);
+		return -EBUSY;
+	}
+	else {
+		class_simple_device_add(n2lm_class, MKDEV(N2PB_MAJOR, 0), NULL, "pbuttons");
+	}
+	if (register_chrdev(N2LM_MAJOR, "n2_ledm", &n2lm_fops) < NOERR) {
+		printk(KERN_DEBUG "Led Manager Major %d not available\n", N2LM_MAJOR);
+		return -EBUSY;
+	}
+	else {
+		class_simple_device_add(n2lm_class, MKDEV(N2LM_MAJOR, 0), NULL, "leds");
+	}
+	if (register_chrdev(N2BZ_MAJOR, "n2_bzm", &n2bz_fops) < NOERR) {
+		printk(KERN_DEBUG "Buzzer Major %d not available\n", N2BZ_MAJOR);
+		return -EBUSY;
+	}
+	else {
+		class_simple_device_add(n2lm_class, MKDEV(N2BZ_MAJOR, 0), NULL, "buzzer");
+	}
+
+	if (request_irq(N2RB_IRQ, &n2rb_handler, SA_INTERRUPT, "n2_rb", NULL) < NOERR) {
+		printk(KERN_DEBUG "Reset Button IRQ %d not available\n", N2RB_IRQ);
+		return -EIO;
+	}
+	if (request_irq(N2PB_IRQ, &n2pb_handler, SA_INTERRUPT, "n2_pb", NULL) < NOERR) {
+		printk(KERN_DEBUG "Power Button IRQ %d not available\n", N2PB_IRQ);
+		return -EIO;	
+	}
+	
+	enable_irq(N2PB_IRQ);
+	enable_irq(N2RB_IRQ);
+	return (NOERR);
+}
+
+//==================================================================================================
+
+static void __exit n2iom_exit(void)
+{
+	remove_proc_entry(PWR_OFF_STR, NULL);
+	del_timer(&n2rb_timer);
+	free_irq(N2RB_IRQ,NULL);
+	unregister_chrdev(N2PB_MAJOR, "n2pb");
+	class_simple_device_remove(MKDEV(N2PB_MAJOR, 0));
+	del_timer(&n2pb_timer);	
+	free_irq(N2PB_IRQ, NULL);
+	unregister_chrdev(N2RB_MAJOR, "n2rb" );
+	class_simple_device_remove(MKDEV(N2RB_MAJOR, 0));
+	del_timer(&n2lm_rsg_timer);
+	del_timer(&n2lm_rsr_timer);
+	del_timer(&n2lm_d1_timer);
+	del_timer(&n2lm_d2_timer);	
+	unregister_chrdev(N2LM_MAJOR, "n2lm" );
+	class_simple_device_remove(MKDEV(N2LM_MAJOR, 0));
+	unregister_chrdev(N2BZ_MAJOR, "n2bz");
+	class_simple_device_remove(MKDEV(N2BZ_MAJOR, 0));
+	class_simple_destroy(n2lm_class);
+}
+
+module_init (n2iom_init);
+module_exit (n2iom_exit);
+
+MODULE_AUTHOR("Karen Spearel <kas11@tampabay.rr.com>");
+MODULE_DESCRIPTION("OpenN2 Buttons/LEDs IO Driver");
+MODULE_LICENSE("GPL");
+static int debug = 7;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Debugging enabled = 8");
+
--- /dev/null	2005-10-05 21:35:01.000000000 +0930
+++ linux-2.6.12.2/arch/arm/mach-ixp4xx/nslu2-setup.c	2005-10-11 10:55:56.961189520 +0930
@@ -0,0 +1,147 @@
+/*
+ * arch/arm/mach-ixp4xx/nslu2-setup.c
+ *
+ * NSLU2 board-setup
+ *
+ * based ixdp425-setup.c:
+ *      Copyright (C) 2003-2004 MontaVista Software, Inc.
+ *
+ * Author: Mark Rakes <mrakes at mac.com>
+ * Maintainers: http://www.nslu2-linux.org/
+ *
+ * Fixed missing init_time in MACHINE_START kas11 10/22/04
+ * Changed to conform to new style __init ixdp425 kas11 10/22/04 
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/serial.h>
+#include <linux/tty.h>
+#include <linux/serial_8250.h>
+
+#include <asm/types.h>
+#include <asm/setup.h>
+#include <asm/memory.h>
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/flash.h>
+
+void __init nslu2_map_io(void) 
+{
+	ixp4xx_map_io();
+}
+
+static struct flash_platform_data nslu2_flash_data = {
+	.map_name	= "cfi_probe",
+	.width		= 2,
+};
+
+static struct resource nslu2_flash_resource = {
+	.start		= NSLU2_FLASH_BASE,
+	.end		= NSLU2_FLASH_BASE + NSLU2_FLASH_SIZE,
+	.flags		= IORESOURCE_MEM,
+};
+
+static struct platform_device nslu2_flash = {
+	.name		= "IXP4XX-Flash",
+	.id		= 0,
+	.dev		= {
+		.platform_data = &nslu2_flash_data,
+	},
+	.num_resources	= 1,
+	.resource	= &nslu2_flash_resource,
+};
+
+static struct ixp4xx_i2c_pins nslu2_i2c_gpio_pins = {
+	.sda_pin	= NSLU2_SDA_PIN,
+	.scl_pin	= NSLU2_SCL_PIN,
+};
+
+static struct platform_device nslu2_i2c_controller = {
+	.name		= "IXP4XX-I2C",
+	.id		= 0,
+	.dev		= {
+		.platform_data = &nslu2_i2c_gpio_pins,
+	},
+	.num_resources	= 0
+};
+
+static struct resource nslu2_uart_resources[] = {
+	{
+		.start		= IXP4XX_UART1_BASE_PHYS,
+		.end		= IXP4XX_UART1_BASE_PHYS + 0x0fff,
+		.flags		= IORESOURCE_MEM
+	},
+	{
+		.start		= IXP4XX_UART2_BASE_PHYS,
+		.end		= IXP4XX_UART2_BASE_PHYS + 0x0fff,
+		.flags		= IORESOURCE_MEM
+	}
+};
+
+static struct plat_serial8250_port nslu2_uart_data[] = {
+	{
+		.mapbase	= IXP4XX_UART1_BASE_PHYS,
+		.membase	= (char *)IXP4XX_UART1_BASE_VIRT + REG_OFFSET,
+		.irq		= IRQ_IXP4XX_UART1,
+		.flags		= UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= IXP4XX_UART_XTAL,
+	},
+	{
+		.mapbase	= IXP4XX_UART2_BASE_PHYS,
+		.membase	= (char *)IXP4XX_UART2_BASE_VIRT + REG_OFFSET,
+		.irq		= IRQ_IXP4XX_UART2,
+		.flags		= UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= IXP4XX_UART_XTAL,
+	}
+};
+
+static struct platform_device nslu2_uart = {
+	.name			= "serial8250",
+	.id			= 0,
+	.dev.platform_data	= nslu2_uart_data,
+	.num_resources		= 2,
+	.resource		= nslu2_uart_resources
+};
+
+static struct platform_device *nslu2_devices[] __initdata = {
+	&nslu2_i2c_controller,
+	&nslu2_flash,
+	&nslu2_uart
+};
+
+static void n2_power_off(void)
+{
+        /* This causes the box to drop the power and go dead. */
+#define GPIO_PO_BM              0x0100  //b0000 0001 0000 0000
+        *IXP4XX_GPIO_GPOER &= ~GPIO_PO_BM;      // enable the pwr cntl gpio
+        *IXP4XX_GPIO_GPOUTR |= GPIO_PO_BM;      // do the deed
+}
+
+static void __init nslu2_init(void)
+{
+	ixp4xx_sys_init();
+
+	pm_power_off = n2_power_off;
+	platform_add_devices(nslu2_devices, ARRAY_SIZE(nslu2_devices));
+}
+
+MACHINE_START(NSLU2, "Linksys NSLU2")
+        MAINTAINER("www.nslu2-linux.org")
+	        BOOT_MEM(PHYS_OFFSET, IXP4XX_PERIPHERAL_BASE_PHYS, 
+			IXP4XX_PERIPHERAL_BASE_VIRT)
+	        MAPIO(nslu2_map_io)
+	        INITIRQ(ixp4xx_init_irq)        //FIXME: all irq are off here
+	        .timer          = &ixp4xx_timer,
+	        // INITTIME(ixp4xx_init_time)   //this was missing in 2.6.7 code ...soft reboot needed?
+		BOOT_PARAMS(0x0100)
+		INIT_MACHINE(nslu2_init)
+MACHINE_END
+
--- /dev/null	2005-10-05 21:35:01.000000000 +0930
+++ linux-2.6.12.2/arch/arm/mach-ixp4xx/nslu2-pci.c	2005-10-11 10:55:56.976187240 +0930
@@ -0,0 +1,87 @@
+/*
+ * arch/arm/mach-ixp4xx/nslu2-pci.c
+ *
+ * NSLU2 board-level PCI initialization
+ *
+ * based on ixdp425-pci.c:
+ *	Copyright (C) 2002 Intel Corporation.
+ *	Copyright (C) 2003-2004 MontaVista Software, Inc.
+ *
+ * Maintainer: http://www.nslu2-linux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+// GPIO 8 is used as the power input so is not free for use as a PCI IRQ
+// However, all the common PCI setup code presumes the standard 4 PCI
+// interrupts are available.  So we compromise...we don't enable the
+// IRQ on Pin 8 but we let
+
+#include <linux/config.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include <asm/mach/pci.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+
+void __init nslu2_pci_preinit(void)
+{
+	gpio_line_config(NSLU2_PCI_INTA_PIN,
+				IXP4XX_GPIO_IN | IXP4XX_GPIO_ACTIVE_LOW);
+	gpio_line_config(NSLU2_PCI_INTB_PIN,
+				IXP4XX_GPIO_IN | IXP4XX_GPIO_ACTIVE_LOW);
+	gpio_line_config(NSLU2_PCI_INTC_PIN,
+				IXP4XX_GPIO_IN | IXP4XX_GPIO_ACTIVE_LOW);
+//	gpio_line_config(NSLU2_PCI_INTD_PIN,
+//				IXP4XX_GPIO_IN | IXP4XX_GPIO_ACTIVE_LOW);
+
+	gpio_line_isr_clear(NSLU2_PCI_INTA_PIN);
+	gpio_line_isr_clear(NSLU2_PCI_INTB_PIN);
+	gpio_line_isr_clear(NSLU2_PCI_INTC_PIN);
+//	gpio_line_isr_clear(NSLU2_PCI_INTD_PIN);
+
+	ixp4xx_pci_preinit();
+}
+
+static int __init nslu2_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	static int pci_irq_table[NSLU2_PCI_IRQ_LINES] = {
+		IRQ_NSLU2_PCI_INTA,
+		IRQ_NSLU2_PCI_INTB,
+		IRQ_NSLU2_PCI_INTC,
+//		IRQ_NSLU2_PCI_INTD
+	};
+
+	int irq = -1;
+
+	if (slot >= 1 && slot <= NSLU2_PCI_MAX_DEV &&
+		pin >= 1 && pin <= NSLU2_PCI_IRQ_LINES) {
+		irq = pci_irq_table[(slot + pin - 2) % 3]; // ! % 4 kas11
+	}
+
+	return irq;
+}
+
+struct hw_pci __initdata nslu2_pci = {
+	.nr_controllers = 1,
+	.preinit	= nslu2_pci_preinit,
+	.swizzle	= pci_std_swizzle,
+	.setup		= ixp4xx_setup,
+	.scan		= ixp4xx_scan_bus,
+	.map_irq	= nslu2_map_irq,
+};
+
+int __init nslu2_pci_init(void)		//monkey see, monkey do
+{
+	if (machine_is_nslu2())
+		pci_common_init(&nslu2_pci);
+	return 0;
+}
+
+subsys_initcall(nslu2_pci_init);
+
--- /dev/null	2005-10-05 21:35:01.000000000 +0930
+++ linux-2.6.12.2/arch/arm/mach-ixp4xx/nslu2-part.c	2005-10-11 10:55:56.990185112 +0930
@@ -0,0 +1,120 @@
+/*
+ * nslu2-part.c
+ *
+ * Maintainers: http://www.nslu2-linux.org/
+ * Initial port: Mark Rakes <mrakes AT mac.com>
+ *
+ * "Parse" the fixed partition table of the Linksys NSLU2 and
+ * produce a Linux partition array to match.
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/vmalloc.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+/* info we know about the NSLU2's flash setup:
+ *
+ * Num	Partition		offset		size
+ * ---	---------		----------	-----------
+ * 0	RedBoot			0x00000000	0x00040000
+ * 1	System Configuration	0x00040000	0x00020000
+ * 2	Kernel			0x00060000	0x00100000
+ * 3	Ramdisk			0x00160000	0x006a0000
+ */
+ #define NSLU2_NUM_FLASH_PARTITIONS	4
+ #define NSLU2_FLASH_PART0_NAME		"RedBoot"
+ #define NSLU2_FLASH_PART0_OFFSET	0x00000000
+ #define NSLU2_FLASH_PART0_SIZE		0x00040000
+ #define NSLU2_FLASH_PART1_NAME		"System Configuration"
+ #define NSLU2_FLASH_PART1_OFFSET	(NSLU2_FLASH_PART0_OFFSET + NSLU2_FLASH_PART0_SIZE)
+ #define NSLU2_FLASH_PART1_SIZE		0x00020000
+ #define NSLU2_FLASH_PART2_NAME		"Kernel"
+ #define NSLU2_FLASH_PART2_OFFSET	(NSLU2_FLASH_PART1_OFFSET + NSLU2_FLASH_PART1_SIZE)
+ #define NSLU2_FLASH_PART2_SIZE		0x00100000
+ #define NSLU2_FLASH_PART3_NAME		"Ramdisk"
+ #define NSLU2_FLASH_PART3_OFFSET	(NSLU2_FLASH_PART2_OFFSET + NSLU2_FLASH_PART2_SIZE)
+ #define NSLU2_FLASH_PART3_SIZE		0x006a0000
+
+static int parse_nslu2_partitions(struct mtd_info *master,
+                             struct mtd_partition **pparts,
+                             unsigned long flash_start)
+{
+	struct mtd_partition *parts;
+	int ret = 0, namelen = 0;
+	char *names;
+
+	namelen = strlen(NSLU2_FLASH_PART0_NAME) +
+		  strlen(NSLU2_FLASH_PART1_NAME) +
+		  strlen(NSLU2_FLASH_PART2_NAME) +
+		  strlen(NSLU2_FLASH_PART3_NAME) +
+		  NSLU2_NUM_FLASH_PARTITIONS; /*4 strings + each terminator */
+
+	parts = kmalloc(sizeof(*parts)*NSLU2_NUM_FLASH_PARTITIONS + namelen, GFP_KERNEL);
+	if (!parts) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	memset(parts, 0, sizeof(*parts)*NSLU2_NUM_FLASH_PARTITIONS + namelen);
+	names = (char *)&parts[NSLU2_NUM_FLASH_PARTITIONS];
+
+	/* RedBoot partition */
+	parts[0].size	= NSLU2_FLASH_PART0_SIZE;
+	parts[0].offset	= NSLU2_FLASH_PART0_OFFSET;
+	parts[0].name	= NSLU2_FLASH_PART0_NAME;
+	parts[0].mask_flags = MTD_WRITEABLE; /* readonly */
+	strcpy(names, NSLU2_FLASH_PART0_NAME);
+	names += strlen(names)+1;
+	/* System Configuration */
+	parts[1].size	= NSLU2_FLASH_PART1_SIZE;
+	parts[1].offset	= NSLU2_FLASH_PART1_OFFSET;
+	parts[1].name	= NSLU2_FLASH_PART1_NAME;
+	parts[1].mask_flags = MTD_WRITEABLE; /* readonly */
+	strcpy(names, NSLU2_FLASH_PART1_NAME);
+	names += strlen(names)+1;
+	/* Kernel */
+	parts[2].size	= NSLU2_FLASH_PART2_SIZE;
+	parts[2].offset	= NSLU2_FLASH_PART2_OFFSET;
+	parts[2].name	= NSLU2_FLASH_PART2_NAME;
+	parts[2].mask_flags = MTD_WRITEABLE; /* readonly */
+	strcpy(names, NSLU2_FLASH_PART2_NAME);
+	names += strlen(names)+1;
+	/* Ramdisk */
+	parts[3].size	= NSLU2_FLASH_PART3_SIZE;
+	parts[3].offset	= NSLU2_FLASH_PART3_OFFSET;
+	parts[3].name	= NSLU2_FLASH_PART3_NAME;
+	parts[3].mask_flags = MTD_WRITEABLE; /* readonly */
+	strcpy(names, NSLU2_FLASH_PART3_NAME);
+	names += strlen(names)+1;
+
+	ret = NSLU2_NUM_FLASH_PARTITIONS;
+	*pparts = parts;
+ out:
+	return ret;
+}
+
+static struct mtd_part_parser nslu2_parser = {
+	.owner = THIS_MODULE,
+	.parse_fn = parse_nslu2_partitions,
+	.name = "NSLU2",
+};
+
+static int __init nslu2_parser_init(void)
+{
+	return register_mtd_parser(&nslu2_parser);
+}
+
+static void __exit nslu2_parser_exit(void)
+{
+	deregister_mtd_parser(&nslu2_parser);
+}
+
+module_init(nslu2_parser_init);
+module_exit(nslu2_parser_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Mark Rakes");
+MODULE_DESCRIPTION("Parsing code for NSLU2 flash tables");
--- /dev/null	2005-10-05 21:35:01.000000000 +0930
+++ linux-2.6.12.2/include/asm-arm/arch-ixp4xx/nslu2.h	2005-10-11 10:55:57.003183136 +0930
@@ -0,0 +1,43 @@
+/*
+ * include/asm-arm/arch-ixp4xx/nslu2.h
+ *
+ * NSLU2 platform specific definitions
+ *
+ * Author: Mark Rakes <mrakes AT mac.com>
+ * Maintainers: http://www.nslu2-linux.org
+ *
+ * based on ixdp425.h:
+ *	Copyright 2004 (c) MontaVista, Software, Inc.
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+// GPIO 8 is used as the power input so is not free for use as a PCI IRQ
+// kas11 11-2-04
+
+#ifndef __ASM_ARCH_HARDWARE_H__
+#error "Do not include this directly, instead #include <asm/hardware.h>"
+#endif
+
+#define	NSLU2_FLASH_BASE	IXP4XX_EXP_BUS_CS0_BASE_PHYS
+#define	NSLU2_FLASH_SIZE	IXP4XX_EXP_BUS_CSX_REGION_SIZE
+
+#define	NSLU2_SDA_PIN		7
+#define	NSLU2_SCL_PIN		6
+
+/*
+ * NSLU2 PCI IRQs
+ */
+#define NSLU2_PCI_MAX_DEV	3
+#define NSLU2_PCI_IRQ_LINES	3
+
+
+/* PCI controller GPIO to IRQ pin mappings */
+#define NSLU2_PCI_INTA_PIN	11
+#define NSLU2_PCI_INTB_PIN	10
+#define	NSLU2_PCI_INTC_PIN	9
+//#define	NSLU2_PCI_INTD_PIN	8
+
+
--- linux-2.6.11/arch/arm/boot/compressed/head.S	2005-06-17 17:51:27.245788998 -0700
+++ linux-2.6.11/arch/arm/boot/compressed/head.S	2005-06-17 17:54:45.041806429 -0700
@@ -37,6 +37,7 @@
     defined(CONFIG_ARCH_INTEGRATOR) || \
     defined(CONFIG_ARCH_PXA) || \
     defined(CONFIG_ARCH_IXP4XX) || \
+    defined(CONFIG_ARCH_NSLU2) || \
     defined(CONFIG_ARCH_IXP2000) || \
     defined(CONFIG_ARCH_LH7A40X) || \
     defined(CONFIG_ARCH_OMAP)
--- linux-2.6.11/.pc/2.6.patch/arch/arm/boot/compressed/head-xscale.S	2005-03-01 23:37:52.000000000 -0800
+++ linux-2.6.11/arch/arm/boot/compressed/head-xscale.S	2005-06-17 17:51:32.546985425 -0700
@@ -47,3 +47,8 @@
                orr     r7, r7, #(MACH_TYPE_GTWX5715 & 0xff00)
 #endif
 
+#ifdef CONFIG_ARCH_NSLU2
+               mov     r7, #(MACH_TYPE_NSLU2 & 0xff)
+               orr     r7, r7, #(MACH_TYPE_NSLU2 & 0xff00)
+#endif
+
--- linux-2.6.11/.pc/2.6.patch/arch/arm/mach-ixp4xx/Kconfig	2005-06-17 17:51:27.365770810 -0700
+++ linux-2.6.11/arch/arm/mach-ixp4xx/Kconfig	2005-06-17 17:51:32.560983303 -0700
@@ -43,6 +43,12 @@
 	  IXDP465 Development Platform (Also known as BMP).
 	  For more information on this platform, see <file:Documentation/arm/IXP4xx>.
 
+config ARCH_NSLU2
+       bool "NSLU2"
+       help
+         Say 'Y' here if you want your kernel to support Linksys's 
+         NSLU2 NAS device. For more information on this platform, 
+         see http://www.nslu2-linux.org
 
 #
 # IXCDP1100 is the exact same HW as IXDP425, but with a different machine 
--- linux-2.6.11/.pc/2.6.patch/arch/arm/mach-ixp4xx/Makefile	2005-06-17 17:51:27.365770810 -0700
+++ linux-2.6.11/arch/arm/mach-ixp4xx/Makefile	2005-06-17 17:51:32.560983303 -0700
@@ -8,4 +8,4 @@
 obj-$(CONFIG_MACH_IXDPG425)	+= ixdpg425-pci.o coyote-setup.o
 obj-$(CONFIG_ARCH_ADI_COYOTE)	+= coyote-pci.o coyote-setup.o
 obj-$(CONFIG_MACH_GTWX5715)	+= gtwx5715-pci.o gtwx5715-setup.o
-
+obj-$(CONFIG_ARCH_NSLU2)	+= nslu2-pci.o nslu2-setup.o nslu2-part.o nslu2-io.o
--- linux-2.6.11/.pc/2.6.patch/arch/arm/tools/mach-types	2005-06-17 17:51:27.423762020 -0700
+++ linux-2.6.11/arch/arm/tools/mach-types	2005-06-17 17:51:32.564982697 -0700
@@ -604,7 +604,7 @@
 roverp7			MACH_ROVERP7		ROVERP7			594
 pr818s			MACH_PR818S		PR818S			595
 trxpro			MACH_TRXPRO		TRXPRO			596
-nslu2			MACH_NSLU2		NSLU2			597
+nslu2			ARCH_NSLU2		NSLU2			597
 e400			MACH_E400		E400			598
 trab			MACH_TRAB		TRAB			599
 cmc_pu2			MACH_CMC_PU2		CMC_PU2			600
--- linux-2.6.11/.pc/2.6.patch/drivers/mtd/maps/ixp4xx.c	2005-03-01 23:37:30.000000000 -0800
+++ linux-2.6.11/drivers/mtd/maps/ixp4xx.c	2005-06-17 17:51:32.566982394 -0700
@@ -94,7 +94,11 @@
 	struct resource *res;
 };
 
+#ifdef CONFIG_ARCH_NSLU2
+static const char *probes[] = { "cmdlinepart", "RedBoot", "NSLU2", NULL };
+#else
 static const char *probes[] = { "RedBoot", "cmdlinepart", NULL };
+#endif
 
 static int ixp4xx_flash_remove(struct device *_dev)
 {
--- linux-2.6.11/.pc/2.6.patch/include/asm-arm/arch-ixp4xx/hardware.h	2005-03-01 23:37:51.000000000 -0800
+++ linux-2.6.11/include/asm-arm/arch-ixp4xx/hardware.h	2005-06-17 17:51:32.567982242 -0700
@@ -44,5 +44,6 @@
 #include "ixdp425.h"
 #include "coyote.h"
 #include "prpmc1100.h"
+#include "nslu2.h"
 
 #endif  /* _ASM_ARCH_HARDWARE_H */
--- linux-2.6.11/.pc/2.6.patch/include/asm-arm/arch-ixp4xx/irqs.h	2005-03-01 23:38:12.000000000 -0800
+++ linux-2.6.11/include/asm-arm/arch-ixp4xx/irqs.h	2005-06-17 17:51:32.568982091 -0700
@@ -93,4 +93,11 @@
 #define	IRQ_COYOTE_PCI_SLOT1	IRQ_IXP4XX_GPIO11
 #define	IRQ_COYOTE_IDE		IRQ_IXP4XX_GPIO5
 
+/*
+ * NSLU2 board IRQs
+ */
+#define        IRQ_NSLU2_PCI_INTA      IRQ_IXP4XX_GPIO11
+#define        IRQ_NSLU2_PCI_INTB      IRQ_IXP4XX_GPIO10
+#define        IRQ_NSLU2_PCI_INTC      IRQ_IXP4XX_GPIO9
+
 #endif
--- linux-2.6.11/.pc/2.6.patch/drivers/i2c/chips/Kconfig	2005-06-17 17:51:28.635578329 -0700
+++ linux-2.6.11/drivers/i2c/chips/Kconfig	2005-06-17 17:51:32.565982545 -0700
@@ -430,6 +430,15 @@
 	  
 	  This driver can also be built as a module.  If so, the module
 	  will be called isp1301_omap.
+config SENSORS_X1205
+       tristate "Xicor X1205 RTC chip"
+       depends on I2C && EXPERIMENTAL
+       select I2C_SENSOR
+       help
+         If you say yes here you get support for the Xicor x1205 RTC chip.
+ 
+         This driver can also be built as a module.  If so, the module
+         will be called x1205-rtc
 
 config SENSORS_M41T00
 	tristate "ST M41T00 RTC chip"
--- linux-2.6.11/.pc/2.6.patch/drivers/i2c/chips/Makefile	2005-06-17 17:51:28.636578177 -0700
+++ linux-2.6.11/drivers/i2c/chips/Makefile	2005-06-17 17:51:32.566982394 -0700
@@ -41,6 +41,7 @@
 obj-$(CONFIG_SENSORS_VIA686A)	+= via686a.o
 obj-$(CONFIG_SENSORS_W83L785TS)	+= w83l785ts.o
 obj-$(CONFIG_ISP1301_OMAP)	+= isp1301_omap.o
+obj-$(CONFIG_SENSORS_X1205)     += x1205-rtc.o
 
 ifeq ($(CONFIG_I2C_DEBUG_CHIP),y)
 EXTRA_CFLAGS += -DDEBUG
--- linux-2.6.11/.pc/2.6.patch/include/linux/i2c-id.h	2005-06-17 17:51:31.358165630 -0700
+++ linux-2.6.11/include/linux/i2c-id.h	2005-06-17 17:51:32.569981939 -0700
@@ -108,6 +108,7 @@
 #define I2C_DRIVERID_TDA7313	62	/* TDA7313 audio processor	*/
 #define I2C_DRIVERID_MAX6900	63	/* MAX6900 real-time clock	*/
 #define I2C_DRIVERID_SAA7114H	64	/* video decoder		*/
+#define I2C_DRIVERID_X1205	0xF0
 
 
 #define I2C_DRIVERID_EXP0	0xF0	/* experimental use id's	*/
--- linux-2.6.11/.pc/2.6.patch/include/asm-arm/arch-ixp4xx/ixp4xx-regs.h	2005-03-01 23:37:49.000000000 -0800
+++ linux-2.6.11/include/asm-arm/arch-ixp4xx/ixp4xx-regs.h	2005-06-17 17:51:32.569981939 -0700
@@ -52,7 +52,7 @@
  * Expansion BUS Configuration registers
  */
 #define IXP4XX_EXP_CFG_BASE_PHYS	(0xC4000000)
-#define IXP4XX_EXP_CFG_BASE_VIRT	(0xFFBFD000)
+#define IXP4XX_EXP_CFG_BASE_VIRT	(0xFFBFE000)
 #define IXP4XX_EXP_CFG_REGION_SIZE	(0x00001000)
 
 /*
--- linux-2.6.11/arch/arm/Makefile.orig	2005-03-20 15:02:07.587138712 -0800
+++ linux-2.6.11/arch/arm/Makefile	2005-03-20 15:10:36.546765088 -0800
@@ -33,6 +33,12 @@
 AFLAGS		+= -mlittle-endian
 endif
 
+ifeq ($(CONFIG_ARM_THUMB_INTERWORK),y)
+CFLAGS		+= -mthumb-interwork
+else
+CFLAGS		+= -mno-thumb-interwork
+endif
+
 comma = ,
 
 # This selects which instruction set is used.
@@ -43,6 +49,8 @@
 arch-$(CONFIG_CPU_32v5)		:=-D__LINUX_ARM_ARCH__=5 $(call cc-option,-march=armv5te,-march=armv4)
 arch-$(CONFIG_CPU_32v4)		:=-D__LINUX_ARM_ARCH__=4 -march=armv4
 arch-$(CONFIG_CPU_32v3)		:=-D__LINUX_ARM_ARCH__=3 -march=armv3
+# The following overrides the CPU_32v5 setting if specified
+arch-$(CONFIG_ARCH_XSCALE)	:=-D__LINUX_ARM_ARCH__=5 $(call cc-option,-march=xscale,-march=armv5te)
 
 # This selects how we optimise for the processor.
 tune-$(CONFIG_CPU_ARM610)	:=-mtune=arm610
--- linux-2.6.11/arch/arm/mm/Kconfig.orig	2005-03-20 14:54:07.927058128 -0800
+++ linux-2.6.11/arch/arm/mm/Kconfig	2005-03-20 15:01:26.727350344 -0800
@@ -366,6 +366,31 @@
 
 	  If you don't know what this all is, saying Y is a safe choice.
 
+config ARM_THUMB_INTERWORK
+	bool "Support Thumb code within the kernel"
+	depends on CPU_ARM720T || CPU_ARM920T || CPU_ARM922T || CPU_ARM925T || CPU_ARM926T || CPU_ARM1020 || CPU_ARM1020E || CPU_ARM1022 || CPU_ARM1026 || CPU_XSCALE || CPU_V6
+	default n
+	help
+	  Say Y to compile the whole kernel with support for the interworking
+	  of the 16 bit thumb instruction set and 32 bit ARM instruction set.
+
+	  You only need this if some parts of the kernel will be compiled
+	  as thumb code, this is not usual.  It increases the total kernel
+	  size by about 3%.
+
+config ARCH_XSCALE
+	bool "Use -march=xscale in preference to -march=armv5te"
+	depends on CPU_XSCALE
+	default y
+	help
+	  Say yes to ask gcc to use the xscale architecture (instruction set)
+	  in preference to armv5te.  This allows gcc to use the extra xscale
+	  instructions but means the code will not run on a standard (non-xscale)
+	  armv5te.  At present this makes no difference - gcc 3.4.3 does not
+	  generate any xscale specific instructions - however gcc 3.4.3 does
+	  generate slightly more optimal instructions if this is specified (this
+	  is an error inside gcc 3.4.3 which should be fixed in 4.1.)
+
 config CPU_BIG_ENDIAN
 	bool "Build big-endian kernel"
 	depends on ARCH_SUPPORTS_BIG_ENDIAN
--- linux-2.6.11/drivers/mtd/maps/ixp4xx.c.orig	2005-03-05 20:00:28.000000000 +0100
+++ linux-2.6.11/drivers/mtd/maps/ixp4xx.c	2005-03-05 22:10:48.000000000 +0100
@@ -29,6 +29,8 @@
 #include <asm/mach-types.h>
 #include <asm/mach/flash.h>
 
+#include <asm/unaligned.h>
+
 #include <linux/reboot.h>
 
 #ifndef __ARMEB__
@@ -60,13 +62,13 @@ static void ixp4xx_copy_from(struct map_
 	u16 data;
 
 	for (i = 0; i < (len / 2); i++) {
-		data = src[i];
+		data = get_unaligned((u16*)(src + i));
 		dest[i * 2] = BYTE0(data);
 		dest[i * 2 + 1] = BYTE1(data);
 	}
 
 	if (len & 1)
-		dest[len - 1] = BYTE0(src[i]);
+		dest[len - 1] = BYTE0(get_unaligned((u16*)(src + i)));
 }
 
 /* 
--- linux-2.6.12.2/drivers/mtd/maps/ixp4xx.c.orig	2005-07-17 15:07:47.790388300 -0700
+++ linux-2.6.12.2/drivers/mtd/maps/ixp4xx.c	2005-07-17 17:00:08.082672710 -0700
@@ -144,6 +144,52 @@
 	return 0;
 }
 
+static void ixp4xx_flash_shutdown(struct device *_dev)
+{
+	struct platform_device *dev = to_platform_device(_dev);
+	struct flash_platform_data *plat = dev->dev.platform_data;
+	struct ixp4xx_flash_info *info = dev_get_drvdata(&dev->dev);
+	map_word d;
+
+	dev_set_drvdata(&dev->dev, NULL);
+
+	if(!info)
+		return;
+
+	/*
+	 * This is required for a soft reboot to work.
+	 */
+	d.x[0] = 0xff;
+	ixp4xx_write16(&info->map, d, 0x55 * 0x2);
+
+#if 0
+	/* This is commented out because it seems to cause a kernel
+	 * panic (at least if it isn't commented out the kernel fails
+	 * to shut down).  Should be investigated.
+	 */
+	if (info->mtd) {
+		del_mtd_partitions(info->mtd);
+		map_destroy(info->mtd);
+	}
+#endif
+	if (info->map.map_priv_1)
+		iounmap((void *) info->map.map_priv_1);
+
+	if (info->partitions)
+		kfree(info->partitions);
+
+	if (info->res) {
+		release_resource(info->res);
+		kfree(info->res);
+	}
+
+	if (plat->exit)
+		plat->exit();
+
+	/* Disable flash write */
+	*IXP4XX_EXP_CS0 &= ~IXP4XX_FLASH_WRITABLE;
+}
+
 static int ixp4xx_flash_probe(struct device *_dev)
 {
 	struct platform_device *dev = to_platform_device(_dev);
@@ -243,6 +289,7 @@
 	.bus		= &platform_bus_type,
 	.probe		= ixp4xx_flash_probe,
 	.remove		= ixp4xx_flash_remove,
+	.shutdown	= ixp4xx_flash_shutdown,
 };
 
 static int __init ixp4xx_flash_init(void)
--- linux-2.6.12/drivers/char/random.c~	2005-05-14 16:42:24.000000000 -0400
+++ linux-2.6.12/drivers/char/random.c	2005-05-14 16:42:46.000000000 -0400
@@ -646,6 +646,7 @@ extern void add_input_randomness(unsigne
 	add_timer_randomness(&input_timer_state,
 			     (type << 4) ^ code ^ (code >> 4) ^ value);
 }
+EXPORT_SYMBOL_GPL(add_input_randomness);
 
 void add_interrupt_randomness(int irq)
 {
--- linux-2.6.12/lib/kobject_uevent.c~	2005-05-14 16:45:13.000000000 -0400
+++ linux-2.6.12/lib/kobject_uevent.c	2005-05-14 16:45:27.000000000 -0400
@@ -178,6 +178,7 @@ static inline int send_uevent(const char
 
 #ifdef CONFIG_HOTPLUG
 char hotplug_path[HOTPLUG_PATH_LEN] = "/sbin/hotplug";
+EXPORT_SYMBOL_GPL(hotplug_path);
 u64 hotplug_seqnum;
 static DEFINE_SPINLOCK(sequence_lock);
# Fix for the NSLU2 timer problem (tickadj 10101.01 when it should be 10000)
# Also contains a fix for the more generate problem on the ixp4xx in that the
# Intel spec says to use a 33.33MHz crystal, not 33.333333Mhz

--- linux-2.6.12.2/include/asm-arm/arch-ixp4xx/timex.h.orig	2005-08-05 11:02:09.872690723 -0700
+++ linux-2.6.12.2/include/asm-arm/arch-ixp4xx/timex.h	2005-08-05 11:45:08.786971567 -0700
@@ -7,7 +7,14 @@
 
 /*
  * We use IXP425 General purpose timer for our timer needs, it runs at 
- * 66.66... MHz
+ * 66.66 MHz (exactly) by the Intel specification.
  */
-#define CLOCK_TICK_RATE (66666666)
-
+#if 0
+#define CLOCK_TICK_RATE (66660000)
+#else
+/*
+ * Unfortunately the NSLU2 has a 33MHz crystal, so the rate is not the
+ * specified one.
+ */
+#define CLOCK_TICK_RATE (66000000)
+#endif
--- linux-2.6.12.2/drivers/usb/core/hub.c.bak	2005-09-19 20:29:14.000000000 +0000
+++ linux-2.6.12.2/drivers/usb/core/hub.c	2005-09-19 20:30:44.000000000 +0000
@@ -1026,6 +1026,19 @@
 
 	dev_info (&udev->dev, "USB disconnect, address %d\n", udev->devnum);
 
+	// --- Forward-Ported Linksys Disk 1 & Disk 2 LED Control (Port done 16.Sept.05 by Philipp Kirchhofer) ---
+	// Copy & paste from nslu2-io.c
+	#define DISK1_OFF	0x00000008	//0b0000 0000 0000 1000
+	#define	DISK2_OFF	0x00000004	//0b0000 0000 0000 0100
+	// Copy & Paste end
+
+	if (*udev->devpath == 0x31) {
+		*IXP4XX_GPIO_GPOUTR |= DISK1_OFF;
+	} else if (*udev->devpath == 0x32) {
+		*IXP4XX_GPIO_GPOUTR |= DISK2_OFF;
+	}
+	// --- End LED Control ---
+
 	/* Free up all the children before we remove this device */
 	for (i = 0; i < USB_MAXCHILDREN; i++) {
 		if (udev->children[i])
@@ -2175,6 +2188,19 @@
 			udev->bus->controller->driver->name,
 			udev->devnum);
 
+	// --- Start LED Control ---
+	// Copy & paste from nslu2-io.c
+	#define DISK1_ON	0xfffffff7	//0b1111 1111 1111 0111
+	#define	DISK2_ON	0xfffffffb	//0b1111 1111 1111 1011
+	// Copy & Paste end
+
+	if (*udev->devpath == 0x31) {
+		*IXP4XX_GPIO_GPOUTR &= DISK1_ON;
+	} else if (*udev->devpath == 0x32) {
+		*IXP4XX_GPIO_GPOUTR &= DISK2_ON;
+	}
+	// --- End LED Control ---
+
 	/* Set up TT records, if needed  */
 	if (hdev->tt) {
 		udev->tt = hdev->tt;
--- linux-2.6.12.2/drivers/usb/storage/transport.c.bak	2005-09-19 20:29:25.000000000 +0000
+++ linux-2.6.12.2/drivers/usb/storage/transport.c	2005-09-19 20:29:55.000000000 +0000
@@ -60,6 +60,60 @@
 #include "scsiglue.h"
 #include "debug.h"
 
+// --- Forward-Ported Linksys Disk 1 & Disk 2 LED Activity Blinking Part 1 (Port done 16.Sept.05 by Philipp Kirchhofer) ---
+// Copy & Paste from nslu2-io.c
+#define DISK1_ON	0xfffffff7	//0b1111 1111 1111 0111
+#define DISK2_ON	0xfffffffb	//0b1111 1111 1111 1011
+
+#define DISK1_OFF	0x00000008	//0b0000 0000 0000 1000
+#define DISK2_OFF	0x00000004	//0b0000 0000 0000 0100
+// Copy & Paste End
+
+#define JIFFIES_BLINKING_TIME 6
+#define ON_LED_INTERVAL 3
+unsigned long turn_on_time;
+
+static struct timer_list usb1_led_timer;    /* ide led switch */
+static struct timer_list usb2_led_timer;    /* ide led switch */
+
+// Turns on Disk 1 LED
+static void turn_on_led_usb1(unsigned long ptr) {
+	*IXP4XX_GPIO_GPOUTR &= DISK1_ON; // 0xfff7
+	return;
+}
+
+// Turns on Disk 2 LED
+static void turn_on_led_usb2(unsigned long ptr) {
+	*IXP4XX_GPIO_GPOUTR &= DISK2_ON; // 0xfffb
+        return;
+}
+
+// Turns on Disk 1 LED after ON_LED_INTERVAL jiffies
+static void usb_1_led_timer(void) {
+	usb1_led_timer.expires = jiffies + ON_LED_INTERVAL;
+	add_timer(&usb1_led_timer);
+	return;
+}
+
+// Turns on Disk 2 LED after ON_LED_INTERVAL jiffies
+static void usb_2_led_timer(void) {
+        usb2_led_timer.expires = jiffies + ON_LED_INTERVAL;
+        add_timer(&usb2_led_timer);
+        return;
+}
+
+// Initializes Timers
+unsigned long initialized_timers = 0;
+static void initializeTimers() {
+	if (initialized_timers != 1) {
+		init_timer(&usb1_led_timer);
+		usb1_led_timer.function = turn_on_led_usb1;
+		init_timer(&usb2_led_timer);
+		usb2_led_timer.function = turn_on_led_usb2;
+		initialized_timers = 1;
+	}
+}
+// --- End Disk LED Activity Blinking Part 1 ---
 
 /***********************************************************************
  * Data transfer routines
@@ -499,6 +553,21 @@
 
 	/* are we scatter-gathering? */
 	if (use_sg) {
+		// --- Disk LED Activity Blinking Part 2 ---
+		initializeTimers();
+		if ((jiffies - turn_on_time) >= JIFFIES_BLINKING_TIME) {
+	        	if (*us->pusb_dev->devpath == 0x31) {
+				del_timer_sync(&usb1_led_timer);
+				*IXP4XX_GPIO_GPOUTR |= DISK1_OFF;
+				usb_1_led_timer();
+			} else if (*us->pusb_dev->devpath == 0x32) {
+				del_timer_sync(&usb2_led_timer);
+				*IXP4XX_GPIO_GPOUTR |= DISK2_OFF;
+				usb_2_led_timer();
+			}
+			turn_on_time = jiffies;
+		}
+		// --- End Disk LED Activity Blinking Part 2 ---
 		/* use the usb core scatter-gather primitives */
 		result = usb_stor_bulk_transfer_sglist(us, pipe,
 				(struct scatterlist *) buf, use_sg,
--- linux-2.6-2.6.12/arch/arm/mm/proc-xscale.S	2005-06-18 05:18:29.000000000 +0930
+++ linux-2.6-2.6.12/arch/arm/mm/proc-xscale.S.new	2005-10-11 19:35:49.653875752 +0930
@@ -137,23 +137,129 @@
  * same state as it would be if it had been reset, and branch
  * to what would be the reset vector.
  *
+ * This code is ixp425 specific with respect to the reset of
+ * the 'configuration register' - to be found at address
+ * 0xC40000020 'IXP425_EXP_CNFGO'
+ *
  * loc: location to jump to for soft reset
  */
 	.align	5
 ENTRY(cpu_xscale_reset)
+	@ always branch to 0
+	mov	r0, #0
+
+	@ disable both FIQ and IRQ, put us into 32 bit
+	@ SVC mode (no thumb).
 	mov	r1, #PSR_F_BIT|PSR_I_BIT|SVC_MODE
 	msr	cpsr_c, r1			@ reset CPSR
-	mrc	p15, 0, r1, c1, c0, 0		@ ctrl register
-	bic	r1, r1, #0x0086			@ ........B....CA.
-	bic	r1, r1, #0x3900			@ ..VIZ..S........
-	mcr	p15, 0, r1, c1, c0, 0		@ ctrl register
-	mcr	p15, 0, ip, c7, c7, 0		@ invalidate I,D caches & BTB
-	bic	r1, r1, #0x0001			@ ...............M
-	mcr	p15, 0, r1, c1, c0, 0		@ ctrl register
-	@ CAUTION: MMU turned off from this point. We count on the pipeline
-	@ already containing those two last instructions to survive.
+
+	@ disable debug, clock and power registers are
+	@ unimplemented.
+	mcr	p14, 0, r0, c10, c0, 0		@ disable debug
+
+	@ disable the performance monitor
+	mcr	p14, 0, r0, c0, c1, 0		@ PMNC (ctrl reg)
+	mcr	p14, 0, r0, c4, c1, 0		@ INTEN (intrpt enable)
+
+	@ wait for p14 to complete
+	mrc	p14, 0, ip, c4, c1, 0		@ arbitrary read
+	mov	ip, ip				@ sync
+
+	@ clear the PID register
+	mcr	p15, 0, r0, c13, c0, 0		@ OR nothing with address!
+
+	@ unlock the TLBs and the I/D cache locks
+	mcr	p15, 0, r0, c10, c8, 1		@ data TLB unlocked
+	mcr	p15, 0, r0, c10, c4, 1		@ instruction TLB unlocked
+	mcr	p15, 0, r0,  c9, c2, 1		@ unlock data cache
+	mcr	p15, 0, r0,  c9, c1, 1		@ unlock instruction cache
+
+	@ zap the minidata cache to write through with write coalescing
+	@ disabled.
+	mov	r1, #0x21			@ MD=b10, K=1
+	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
+	mrc	p15, 0, ip, c1, c0, 0		@ read of ctrl register
+	mov	ip, ip				@ sync
+	mcr 	p15, 0, r1, c1, c0, 1		@ write through, no coalesc
+
+	@ set the control register, the MMU is enabled but everything else
+	@ is disabled at this point, r1 contains the control register flags
+	@ the process is now in little-endian mode (no matter, we aren't
+	@ going to do any <word access)
+	mov	r1, #0x79			@ 00vIz0rs.b1111caM
+	orr	r1, r1, #0x1000			@ I-cache enable
+	mcr	p15, 0, r1, c1, c0, 0
+	mrc	p15, 0, ip, c1, c0, 0
+	mov	ip, ip				@ sync to coproc
+	mov	r1, #0x78			@ 00viz0rs.b1111cam
+
+	@ and flush the I/D cache and BTB
+	mcr	p15, 0, r0, c7, c7, 0
+
+	@ that's most of the work.  The only thing which remains is to
+	@ remap the flash memory and disable the MMU.  Do some setup
+	@ for this, also get ready to set the LED to red and put in
+	@ a watchdog timer.
+
+	@ get ready to reset the configuration registers in the expansion
+	@ bus.  CFGN1 disables byte swap and interrupt.
+	ldr	r3, =IXP4XX_PERIPHERAL_BASE_VIRT
+	ldr	r4, [r3, #IXP4XX_EXP_CFG1_OFFSET]
+	bic	r4, r4, #0x13			@ -BYTE_SWAP_EN, -SW_INT?
+	str	r4, [r3, #IXP4XX_EXP_CFG1_OFFSET]
+
+	@ load the current configuration register from its
+	@ virtual address and set the MEM_MAP bit ready to map the
+	@ flash back to address 0, but don't write it yet.
+	ldr	r4, [r3, #IXP4XX_EXP_CFG0_OFFSET]
+	orr	r4, r4, #0x80000000
+
+	@ load the GPIO OUTR register address and current value,
+	@ set the low nibble to just red LED on.
+	ldr	r5, =IXP4XX_GPIO_BASE_VIRT
+	ldr	r6, [r5, #IXP4XX_GPIO_GPOUTR_OFFSET]
+	bic	r6, r6, #0xf
+	orr	r6, r6, #0xd
+
+	@ load the watchdog timer virtual address, set the key and
+	@ the timer and start the down counter
+	ldr	r7, =IXP4XX_TIMER_BASE_VIRT
+	ldr	r8, =IXP4XX_WDT_KEY		@ set key
+	str	r8, [r7, #IXP4XX_OSWK_OFFSET]
+	mov	r8, #0x1000000			@ about 0.25 seconds
+	str	r8, [r7, #IXP4XX_OSWT_OFFSET]	@ set timer
+	mov	r8, #(IXP4XX_WDT_RESET_ENABLE | IXP4XX_WDT_COUNT_ENABLE)
+	str	r8, [r7, #IXP4XX_OSWE_OFFSET]	@ enable reset
+
+	@ invalidate the TLBs to ensure that there isn't a match for
+	@ '0' there.
 	mcr	p15, 0, ip, c8, c7, 0		@ invalidate I & D TLBs
-	mov	pc, r0
+	mrc	p15, 0, ip, c1, c0, 0		@ read of ctrl register
+	mov	ip, ip				@ sync
+
+	@ remap the flash (after preloading instructions into the
+	@ I-cache) then turn off the MMU and branch to 0 when it is
+	@ off.  It seems that RedBoot relies on the page tables being
+	@ set up on boot, so set the page table head register too.
+	mov	r7, #0x4000			@ flash page table
+	ldr	r8, =IXP4XX_GPIO_BASE_PHYS	@ for led setting
+	bic	r9, r6, #0xc			@ disk1+disk2 led on
+	str	r6, [r5, #IXP4XX_GPIO_GPOUTR_OFFSET]	@ red led
+	b	cache
+
+	@ cached instructions  These 8 instructions are valid in the cache
+	@ along with the associated TLB as soon as the first is executed.
+	@ They are used to effect the transition back into the flash
+	@ ROM code.
+	.align	5
+cache:	str	r4, [r3, #IXP4XX_EXP_CFG0_OFFSET]	@0 no memory!
+	mcr	p15, 0, r7, c2, c0, 0			@1 set translation table base
+	mcr	p15, 0, r1, c1, c0, 0			@2 no MMU!
+	mrc	p15, 0, ip, c2, c0, 0			@3 arbitrary read of cp15
+	str	r9, [r8, #IXP4XX_GPIO_GPOUTR_OFFSET]	@4 red+disk1+disk2 led
+	sub	pc, r0, ip, LSR #32			@5 sync and branch to zero
+	nop						@6
+	nop						@7
 
 /*
  * cpu_xscale_do_idle()
@@ -168,8 +274,10 @@
 	.align	5
 
 ENTRY(cpu_xscale_do_idle)
-	mov	r0, #1
-	mcr	p14, 0, r0, c7, c0, 0		@ Go to IDLE
+	@ NSLU2/ixp420: not implemented in the hardware, docs
+	@ say do not write!
+	@mov	r0, #1
+	@mcr	p14, 0, r0, c7, c0, 0		@ Go to IDLE
 	mov	pc, lr
 
 /* ================================= CACHE ================================ */
