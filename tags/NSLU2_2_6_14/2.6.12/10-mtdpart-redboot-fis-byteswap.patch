On IXP4XX systems the FIS directory is big endian even with a little
endian kernel.  This patch recognises the FIS directory on such a
system and byte swaps it to obtain a valid table based on the 'size'
field of the FIS directory (the size field is know to always match the
erase block size on such systems, and probably all systems.)

--- linux-2.6.13/drivers/mtd/redboot.c.orig	2005-10-19 17:14:19.304956677 -0700
+++ linux-2.6.13/drivers/mtd/redboot.c	2005-10-19 17:48:16.457146582 -0700
@@ -89,8 +89,32 @@
 			i = numslots;
 			break;
 		}
-		if (!memcmp(buf[i].name, "FIS directory", 14))
+		if (!memcmp(buf[i].name, "FIS directory", 14)) {
+			/* This is apparently the FIS directory entry for the
+			 * FIS directory itself.  The FIS directory size is
+			 * one erase block, if the buf[i].size field is
+			 * swab32(erasesize) then we know we are looking at
+			 * a byte swapped FIS directory - swap all the entries!
+			 * (NOTE: this is 'size' not 'data_length', size is
+			 * the full size of the entry.)
+			 */
+			if (swab32(buf[i].size) == master->erasesize) {
+				int j;
+				for (j = 0; j < numslots && buf[j].name[0] != 0xff; ++j) {
+					/* The unsigned long fields were written with the
+					 * wrong byte sex, name and pad have no byte sex.
+					 */
+					swab32s(&buf[j].flash_base);
+					swab32s(&buf[j].mem_base);
+					swab32s(&buf[j].size);
+					swab32s(&buf[j].entry_point);
+					swab32s(&buf[j].data_length);
+					swab32s(&buf[j].desc_cksum);
+					swab32s(&buf[j].file_cksum);
+				}
+			}
 			break;
+		}
 	}
 	if (i == numslots) {
 		/* Didn't find it */
