--- linux-2.6.14-rc3/arch/arm/mach-ixp4xx/Makefile	2005-09-17 12:42:02.000000000 +0200
+++ test14/arch/arm/mach-ixp4xx/Makefile	2005-10-06 21:29:53.000000000 +0200
@@ -8,4 +8,9 @@
 obj-$(CONFIG_MACH_IXDPG425)	+= ixdpg425-pci.o coyote-setup.o
 obj-$(CONFIG_ARCH_ADI_COYOTE)	+= coyote-pci.o coyote-setup.o
 obj-$(CONFIG_MACH_GTWX5715)	+= gtwx5715-pci.o gtwx5715-setup.o
+obj-$(CONFIG_MACH_NSLU2)	+= nslu2-pci.o nslu2-setup.o nslu2-power.o nslu2-rtc.o nslu2-io.o
+
+leds-$(CONFIG_MACH_NSLU2)	+= nslu2-leds.o
+obj-$(CONFIG_LEDS)		+= $(leds-y)
+
 
--- linux-2.6.14-rc3/arch/arm/mach-ixp4xx/nslu2-rtc.c	1970-01-01 01:00:00.000000000 +0100
+++ test14/arch/arm/mach-ixp4xx/nslu2-rtc.c	2005-10-06 21:29:53.000000000 +0200
@@ -0,0 +1,113 @@
+/*
+ * arch/arm/mach-ixp4xx/nslu2-rtc.c
+ *
+ * NSLU2 RTC driver
+ *
+ * Copyright (C) 2005 Tower Technologies
+ *
+ * based on x1205-rtc.c  
+ *  Copyright (C) 2004 Karen Spearel
+ *
+ * Author: Alessandro Zummo <a.zummo@towertech.it>
+ * Maintainers: http://www.nslu2-linux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/time.h>
+#include <linux/rtc.h>
+#include <linux/init.h>
+
+#include <linux/x1205.h>
+
+#include <asm/rtc.h>
+#include <asm/mach-types.h>
+
+extern int (*set_rtc)(void);
+
+static int nslu2_set_rtc(void)
+{
+	struct rtc_time new_tm, old_tm;
+	unsigned long cur_secs = xtime.tv_sec;
+
+	if (x1205_do_command(X1205_CMD_GETDATETIME, &old_tm))
+		return 0;
+
+	/* FIXME      xtime.tv_nsec = old_tm.tm_sec * 10000000; */
+	new_tm.tm_sec  = cur_secs % 60;
+	cur_secs /= 60;
+	new_tm.tm_min  = cur_secs % 60;
+	cur_secs /= 60;
+	new_tm.tm_hour = cur_secs % 24;
+
+       /*
+	* avoid writing when we're going to change the day
+	* of the month.  We will retry in the next minute.
+	* This basically means that if the RTC must not drift
+	* by more than 1 minute in 11 minutes.
+	*/
+	if ((old_tm.tm_hour == 23 && old_tm.tm_min == 59) ||
+	    (new_tm.tm_hour == 23 && new_tm.tm_min == 59))
+		return 1;
+
+	return x1205_do_command(X1205_CMD_SETTIME, &new_tm);
+}
+
+static int rtc_read_alarm(struct rtc_wkalrm *alrm)
+{
+	return x1205_do_command(X1205_CMD_GETALARM, &alrm->time);
+}
+
+static int rtc_set_alarm(struct rtc_wkalrm *alrm)
+{
+	return x1205_do_command(X1205_CMD_SETALARM, &alrm->time);
+}
+
+static int rtc_read_time(struct rtc_time *tm)
+{
+	return x1205_do_command(X1205_CMD_GETDATETIME, tm);
+}
+
+static int rtc_set_time(struct rtc_time *tm)
+{
+	return x1205_do_command(X1205_CMD_SETDATETIME, tm);
+}
+
+static struct rtc_ops rtc_ops = {
+	.owner		= THIS_MODULE,
+	.read_time	= rtc_read_time,
+	.set_time	= rtc_set_time,
+	.read_alarm	= rtc_read_alarm,
+	.set_alarm	= rtc_set_alarm,
+};
+
+static int __init nslu2_rtc_init(void)
+{
+	int ret;
+
+	if (!(machine_is_nslu2()))
+		return 0;
+
+	printk(KERN_INFO "NSLU2: rtc\n");
+
+	if ((ret = register_rtc(&rtc_ops)) != 0)
+		return ret;
+
+	set_rtc = nslu2_set_rtc;
+
+	return 0;
+}
+
+static void __exit nslu2_rtc_exit(void)
+{
+	set_rtc = NULL;
+
+	unregister_rtc(&rtc_ops);
+}
+
+module_init(nslu2_rtc_init);
+module_exit(nslu2_rtc_exit);
--- linux-2.6.14-rc3/arch/arm/mach-ixp4xx/nslu2-io.c	1970-01-01 01:00:00.000000000 +0100
+++ test14/arch/arm/mach-ixp4xx/nslu2-io.c	2005-10-06 21:29:53.000000000 +0200
@@ -0,0 +1,548 @@
+//=============================================================================
+//
+// n2-io.c version 0.1.7
+// Author: Karen Spearel <kas11 at tampabay.rr.com>
+// please report problems/bugs directly to the address above
+//
+// Boilerplate to be added "real soon now"...it is and has always been GPL'ed per
+// MODULE_LICENSE but is offered without warrantee of any sort..use at your own risk
+//
+// NOTE: THIS IS INCOMPLETE.  INCLUDED ONLY TO KEEP FROM BREAKING THE BUILD,
+// IT BEEPS AND SENDS A MESSAGE TO /proc/poweroff.  EVENTUALLY IT
+// WILL TALK TO THE n2_pbd DAEMON.  EVENTUALLY THE LED DRIVER
+// WILL TALK TO SOME USERLAND APP BUT ***NOT*** SET_LEDS.
+// 
+//=============================================================================
+//	GPIO		Function	State
+//	0		Red LED		Status		
+//	1		Green LED	Ready = 1
+//	2		Disk 2 LED	On = 0
+//	3		Disk 1 LED	On = 0
+//	4		Buzzer
+//	5		Power Button	Pressed = 1
+//	8		Power Down	Output = 1 powers down NSLU2
+//	12		Reset		Pressed = 0
+
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <linux/device.h>
+#include <linux/reboot.h>
+
+#include <asm/uaccess.h>
+#include <asm-arm/irq.h>
+#include <asm-arm/delay.h>
+
+/* Set this to 1 to output lots of debug messages. */
+#define NSLU2_IO_DEBUG 0
+
+#if NSLU2_IO_DEBUG
+#define nslu2_io_debug(args) printk args
+#else
+#define nslu2_io_debug(args) ((void)0)
+#endif
+
+#define VERSION			"0.1.7"
+
+#define	NSLU2BZ_MAJOR		62		//buzzer
+#define NSLU2LM_MAJOR		126
+
+
+#define NSLU2_BEEP_DUR_LONG	2000
+#define NSLU2_BEEP_DUR_MED	400
+#define NSLU2_BEEP_DUR_SHORT	100
+#define NSLU2_BEEP_PITCH_HIGH	250
+#define NSLU2_BEEP_PITCH_MED	500
+#define NSLU2_BEEP_PITCH_LOW	1000
+#define NSLU2_LONG_DELAY	30000
+
+#define NSLU2_BZ_BM		(1L << NSLU2_GPIO_BUZZ)
+
+// ioctls -- 'M" is used for sound cards...we don't got one so it seems safe
+
+#define NSLU2BZ_BEEP_STOP		_IO('M',0)       //stop multi-beep at end of audible
+#define NSLU2BZ_BEEP		_IO('M',1)       //one beep at current defaults
+#define NSLU2BZ_BEEPS		_IOW('M',3,long) //param beeps at current defaults
+#define NSLU2BZ_TONESET		_IOW('M',4,long) //set tone: range is high=250 to low=2000
+#define NSLU2BZ_ONTIME		_IOW('M',5,long) //ontime for multi-beeps in jiffies
+#define	NSLU2BZ_SILENTTIME		_IOW('M',6,long) //offtime for multi-beeps in jiffies
+#define NSLU2BZ_REPEATCNT		_IOW('M',7,long) //number of repeats for multi-beeps 0 = forever
+#define NSLU2BZ_COMBINED		_IOW('M',8,long) //combine all params in a long
+
+#define NSLU2LM_OFF		_IOW('M',32,long)
+#define NSLU2LM_ON			_IOW('M',33,long)
+#define NSLU2LM_BLINK		_IOW('M',34,long)
+#define NSLU2LM_ALT		_IOW('M',35,long)
+#define NSLU2LM_ALL_ON		_IO('M',36)
+#define NSLU2LM_ALL_OFF		_IO('M',37)
+
+#define PHYS_LEDS		4
+#define BLINK_DELAY		25
+
+//  OR Masks to turn these LEDs ON
+
+#define	RS_RED_ON	0x00000001	//0b0000 0000 0000 0010
+#define	RS_GRN_ON	0x00000002	//0b0000 0000 0000 0001
+#define RS_YEL_ON	0x00000003	//0b0000 0000 0000 0011
+
+// AND Masks to turn these LEDs OFF
+
+#define	RS_RED_OFF	0xfffffffe	//0b1111 1111 1111 1101
+#define	RS_GRN_OFF	0xfffffffd	//0b1111 1111 1111 1110
+#define RS_YEL_OFF	0xfffffffc	//0b1111 1111 1111 1100
+
+// AND Masks to turn these LEDs ON
+
+#define DISK1_ON	0xfffffff7	//0b1111 1111 1111 0111
+#define	DISK2_ON	0xfffffffb	//0b1111 1111 1111 1011
+
+// Or Masks to turn these LEDs OFF
+
+#define DISK1_OFF	0x00000008	//0b0000 0000 0000 1000
+#define	DISK2_OFF	0x00000004	//0b0000 0000 0000 0100	
+
+// EOR masks for toggling LEDs on/off
+
+#define RS_RG_ALT	0x00000003	//eor mask to toggle rs rg bits
+#define RS_GRN_TGL	0x00000002
+#define RS_RED_TGL	0x00000001
+#define DISK1_TGL	0x00000008
+#define DISK2_TGL	0x00000004
+
+// The LED names for switches
+
+#define LED_RS_RED	0
+#define LED_RS_GRN	1
+#define	LED_DISK1	2
+#define LED_DISK2	3
+#define LED_ALL		4
+
+static unsigned long ontime = 50;
+static unsigned long offtime = 450;
+static unsigned long bz_repeatcnt = 10;
+static unsigned long tone = 1000;
+
+static struct timer_list n2lm_rsg_timer;	//rs green 
+static struct timer_list n2lm_rsr_timer;	//rs red
+static struct timer_list n2lm_d1_timer;		//drive 1
+static struct timer_list n2lm_d2_timer;		//drive 2
+static struct timer_list n2bz_timer;		//beeper
+
+// sysfs class
+static struct class *n2lm_class;
+
+//==================================================================================================
+//
+// Blinking is handled entirely by the 4 timer handlers.  On timeout, the bit in the
+// GPIO output register is xor'd with a mask corresponding to the selected led which simply
+// flips that bit.  No record of what any of the other leds is doing is needed.
+//
+//==================================================================================================
+// this blinks rs green or green/yellow if rs red is on
+#ifndef CONFIG_LEDS
+static void n2lm_rsg_handler(unsigned long data)
+{
+	*IXP4XX_GPIO_GPOUTR ^= RS_GRN_TGL;			//flip the led
+	n2lm_rsg_timer.expires = jiffies + BLINK_DELAY;		//next timeout
+	add_timer(&n2lm_rsg_timer);				//reinit timer
+	return;
+}
+
+// this blinks or alternates rs red green... inited wit green on/red off
+static void n2lm_rsr_handler(unsigned long data)
+{
+	*IXP4XX_GPIO_GPOUTR ^= n2lm_rsr_timer.data;
+	n2lm_rsr_timer.expires = jiffies + BLINK_DELAY;
+	add_timer(&n2lm_rsr_timer);
+	return;	
+}
+// blinks disk 1
+static void n2lm_d1_handler(unsigned long data)
+{
+	*IXP4XX_GPIO_GPOUTR ^= DISK1_TGL;
+	n2lm_d1_timer.expires = jiffies + BLINK_DELAY;
+	add_timer(&n2lm_d1_timer);
+	return;
+}
+// blinks disk 2
+static void n2lm_d2_handler(unsigned long data)
+{
+	*IXP4XX_GPIO_GPOUTR ^= DISK2_TGL;
+	n2lm_d2_timer.expires = jiffies + BLINK_DELAY;
+	add_timer(&n2lm_d2_timer);
+	return;
+}
+
+//==================================================================================================
+
+static void n2lm_timer_start(unsigned long led)
+{
+
+	nslu2_io_debug((KERN_DEBUG "timer: %ld\n",led));
+
+	switch(led) {
+		case LED_RS_RED:
+			n2lm_rsr_timer.expires = jiffies + BLINK_DELAY;
+			add_timer(&n2lm_rsr_timer);
+			break;
+
+		case LED_RS_GRN:
+			n2lm_rsg_timer.expires = jiffies + BLINK_DELAY;
+			add_timer(&n2lm_rsg_timer);
+			break;
+
+		case LED_DISK1:
+			n2lm_d1_timer.expires = jiffies + BLINK_DELAY;
+			add_timer(&n2lm_d1_timer);
+ 			break;
+
+		case LED_DISK2:
+			n2lm_d2_timer.expires = jiffies + BLINK_DELAY; 
+			add_timer(&n2lm_d2_timer);
+			break;
+
+		default:
+			break;
+	}
+	return;
+}
+
+//==================================================================================================
+
+static void n2lm_timer_stop(unsigned long led)
+{
+	switch (led) {
+		case LED_RS_RED:
+			del_timer(&n2lm_rsr_timer);
+			break;
+		case LED_RS_GRN:
+			del_timer(&n2lm_rsg_timer);
+			break;
+		case LED_DISK1:
+			del_timer(&n2lm_d1_timer);
+ 			break;
+		case LED_DISK2: 
+			del_timer(&n2lm_d2_timer);
+			break;
+		default:
+			break;
+	}
+	return;
+}
+
+//--------------------------------------------------------------------------------------------------
+
+static void n2lm_timer_stop_all(void)
+{
+	del_timer(&n2lm_rsg_timer);
+	del_timer(&n2lm_rsr_timer);
+	del_timer(&n2lm_d1_timer); 
+	del_timer(&n2lm_d2_timer);
+	return;
+}
+//--------------------------------------------------------------------------------------------------
+
+static void n2lm_ledon(unsigned long led)
+{
+
+	nslu2_io_debug((KERN_DEBUG "ledon: %ld\n", led));
+
+	switch (led) {
+		case LED_RS_RED:	
+			*IXP4XX_GPIO_GPOUTR |= RS_RED_ON;	//1
+			return;
+		case LED_RS_GRN:
+			*IXP4XX_GPIO_GPOUTR |= RS_GRN_ON;	//2
+			return;
+		case LED_DISK1:
+			*IXP4XX_GPIO_GPOUTR &= DISK1_ON;	//0xfffffff7
+			return;
+		case LED_DISK2:	
+			*IXP4XX_GPIO_GPOUTR &= DISK2_ON;	//0xfffffffb
+			return;
+		case LED_ALL:					//all green
+			*IXP4XX_GPIO_GPOUTR |= RS_GRN_ON;
+			*IXP4XX_GPIO_GPOUTR &= (DISK1_ON & DISK2_ON);
+			return;	
+	}
+}
+
+//--------------------------------------------------------------------------------------------------
+
+static void n2lm_ledoff(unsigned long led)
+{
+
+	switch (led) {
+		case LED_RS_RED:	
+			*IXP4XX_GPIO_GPOUTR &= RS_RED_OFF;	//0xffffffffe
+			return;
+		case LED_RS_GRN:
+			*IXP4XX_GPIO_GPOUTR &= RS_GRN_OFF;	//0xfffffffd
+			return;
+		case LED_DISK1:
+			*IXP4XX_GPIO_GPOUTR |= DISK1_OFF;	//0x00000008
+			return;
+		case LED_DISK2:	
+			*IXP4XX_GPIO_GPOUTR |= DISK2_OFF;	//0x00000004
+			return;
+		case LED_ALL:
+			*IXP4XX_GPIO_GPOUTR &= (RS_GRN_OFF & RS_RED_OFF);
+			*IXP4XX_GPIO_GPOUTR |= (DISK1_OFF | DISK2_OFF);
+	}
+}
+
+//==================================================================================================
+
+static int n2lm_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long led)
+{
+
+	nslu2_io_debug((KERN_DEBUG "cmd=%d, led=%ld\n", cmd, led));
+	
+	if (led < 0 || led >= PHYS_LEDS)
+		return -EINVAL;
+
+	switch (cmd ) {
+		case NSLU2LM_ON:
+			n2lm_timer_stop(led);
+			n2lm_ledon(led);
+			break;
+			
+		case NSLU2LM_OFF:
+			n2lm_timer_stop(led);
+			n2lm_ledoff(led);
+			break;
+			
+		case NSLU2LM_BLINK:
+			n2lm_ledon(led);
+			if (led == LED_RS_RED)
+				n2lm_rsr_timer.data = RS_RED_TGL;
+			n2lm_timer_start(led);
+			break;
+
+		case NSLU2LM_ALT:
+			if (led == LED_RS_RED)
+			{
+				n2lm_ledon(LED_RS_GRN);
+				n2lm_ledoff(LED_RS_RED);
+				n2lm_rsr_timer.data = RS_RG_ALT;
+				n2lm_timer_start(LED_RS_RED);
+				break;
+			} else
+				return -EINVAL;
+		
+		case NSLU2LM_ALL_ON:
+			n2lm_timer_stop_all();
+			n2lm_ledon(LED_ALL);
+			break;
+		
+		case NSLU2LM_ALL_OFF:
+			n2lm_timer_stop_all();
+			n2lm_ledoff(LED_ALL);
+			break;
+		
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static struct file_operations n2lm_fops = {
+	.owner		= THIS_MODULE,
+	.ioctl		= n2lm_ioctl,
+};
+#endif
+//==================================================================================================
+// We can't do anything fancy here since the system tick rate is far below that required to
+// generate a desirable tone.  Therefore we haven't much choice but to use a busy loop until
+// I get up to speed on the timers.  The saving grace is that for the normal uses, nothing 
+// important should be haprepening. 
+//==================================================================================================
+
+static void n2_buzz(int tone_delay, int duration)
+{
+	int i;
+
+	*IXP4XX_GPIO_GPOER &= ~NSLU2_BZ_BM;
+		
+	for (i = 1; i < duration; i++) {
+		*IXP4XX_GPIO_GPOUTR &= ~NSLU2_BZ_BM;
+		udelay(tone_delay);
+		*IXP4XX_GPIO_GPOUTR |= NSLU2_BZ_BM;
+		udelay(tone_delay);
+	}
+	*IXP4XX_GPIO_GPOER |= NSLU2_BZ_BM;
+
+	return;
+}
+//=================================================================================================
+
+// this handles the buzzer duty cycle
+static void n2bz_handler(unsigned long data)
+{
+	if (--bz_repeatcnt > 0) {			//if just one beep left to do
+		n2bz_timer.expires = jiffies + ontime + offtime;	//next timeout
+		add_timer(&n2bz_timer);					//reinit timer
+	}
+	n2_buzz(tone/2, ontime);
+	nslu2_io_debug((KERN_DEBUG "Count = %d\tOntime = %d\n", bz_repeatcnt, ontime));
+	return;
+}
+
+//==================================================================================================
+
+static int n2bz_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long param)
+{
+	switch (cmd) {
+		case NSLU2BZ_BEEP:
+			n2_buzz(tone/2, ontime);
+			break;
+	
+		case NSLU2BZ_BEEP_STOP:
+			del_timer(&n2bz_timer);
+			break;
+
+		case NSLU2BZ_BEEPS:
+			if (param == 0)
+				bz_repeatcnt = 0xffffffff;
+			else
+				bz_repeatcnt = param;
+			n2bz_handler(0);
+			break;
+	
+		case NSLU2BZ_TONESET:
+			if (param >= 250 && param <= 2000)
+				tone = param;
+			break;
+
+		case NSLU2BZ_ONTIME:
+			if (param > 4 && param < 201)
+				ontime = param;
+			break;
+
+		case NSLU2BZ_SILENTTIME:
+			if (param > ontime)			//enforce a reasonable duty cycle
+				offtime = param;
+			else
+				offtime = ontime;
+			break;
+
+		case NSLU2BZ_REPEATCNT:
+			if (param == 0)
+				bz_repeatcnt = 0xffffffff;
+			else
+				bz_repeatcnt = param;
+			break;
+
+		case NSLU2BZ_COMBINED:
+			bz_repeatcnt =  (param & 0xF0000000) >> 28;	//repeat 1 - 16
+			ontime =        (param & 0x0FF00000) >> 20; 	//ontime 1 - 256 jiffies
+			offtime =       (param & 0x000FFF00) >> 8;	//offtime 1 - 4095 jiffies
+			tone =          (param & 0x000000FF) << 4;	//tone (1 - 255) * 16
+			break;
+
+		default:
+			break;
+	}
+	return 0;
+}
+
+static struct file_operations n2bz_fops = {
+	.owner		= THIS_MODULE,
+	.ioctl		= n2bz_ioctl,
+};
+
+static void n2iom_initarch(void)
+{
+#ifndef CONFIG_LEDS
+	init_timer(&n2lm_rsg_timer);
+	init_timer(&n2lm_rsr_timer);
+	init_timer(&n2lm_d1_timer);
+	init_timer(&n2lm_d2_timer);
+
+	n2lm_rsr_timer.function = n2lm_rsr_handler;
+	n2lm_rsg_timer.function = n2lm_rsg_handler;
+	n2lm_d2_timer.function = n2lm_d2_handler;
+	n2lm_d1_timer.function = n2lm_d1_handler;
+#endif
+
+	init_timer(&n2bz_timer);
+	n2bz_timer.function = n2bz_handler;
+
+	n2lm_rsr_timer.data = n2lm_rsg_timer.data = n2lm_d1_timer.data = n2lm_d2_timer.data = n2bz_timer.data = 0;
+
+#ifndef CONFIG_LEDS
+	*IXP4XX_GPIO_GPOER &= 0xfffffff0;	//enable gpio 0-3
+	*IXP4XX_GPIO_GPOUTR |= 0x00000003;	//turn off the leds
+	*IXP4XX_GPIO_GPOUTR &= 0xfffffffc;
+	n2lm_ledon(LED_ALL);
+	n2_buzz(NSLU2_BEEP_PITCH_MED, NSLU2_BEEP_DUR_SHORT);
+	n2lm_ledoff(LED_ALL);
+
+	// Default the Ready/Status to Red during kernel boot, Turn Green at the end of sysvinit
+	n2lm_ledon(LED_RS_RED);
+#endif
+
+	return;
+}
+
+//==================================================================================================
+
+static int __init n2iom_init(void)
+{
+	printk(KERN_INFO "NSLU2: i/o, %s\n", VERSION);
+  	
+	n2iom_initarch();
+
+	n2lm_class = class_create(THIS_MODULE, "nslu2");
+
+#ifndef CONFIG_LEDS
+	if (register_chrdev(NSLU2LM_MAJOR, "n2_ledm", &n2lm_fops) < 0) {
+		printk(KERN_DEBUG "Led Manager Major %d not available\n", NSLU2LM_MAJOR);
+		return -EBUSY;
+	}
+	else {
+		class_device_create(n2lm_class, MKDEV(NSLU2LM_MAJOR, 0), NULL, "leds");
+	}
+#endif
+
+	if (register_chrdev(NSLU2BZ_MAJOR, "n2_bzm", &n2bz_fops) < 0) {
+		printk(KERN_DEBUG "Buzzer Major %d not available\n", NSLU2BZ_MAJOR);
+		return -EBUSY;
+	}
+	else {
+		class_device_create(n2lm_class, MKDEV(NSLU2BZ_MAJOR, 0), NULL, "buzzer");
+	}
+
+	return 0;
+}
+
+//==================================================================================================
+
+static void __exit n2iom_exit(void)
+{
+
+#ifndef CONFIG_LEDS
+	del_timer(&n2lm_rsg_timer);
+	del_timer(&n2lm_rsr_timer);
+	del_timer(&n2lm_d1_timer);
+	del_timer(&n2lm_d2_timer);	
+
+	unregister_chrdev(NSLU2LM_MAJOR, "n2lm" );
+	class_device_destroy(n2lm_class, MKDEV(NSLU2LM_MAJOR, 0));
+#endif
+
+	unregister_chrdev(NSLU2BZ_MAJOR, "n2bz");
+	class_device_destroy(n2lm_class, MKDEV(NSLU2BZ_MAJOR, 0));
+
+	class_destroy(n2lm_class);
+}
+
+module_init(n2iom_init);
+module_exit(n2iom_exit);
+
+MODULE_AUTHOR("Karen Spearel <kas11@tampabay.rr.com>");
+MODULE_DESCRIPTION("NSLU2 I/O driver");
+MODULE_LICENSE("GPL");
--- linux-2.6.14-rc3/arch/arm/mach-ixp4xx/nslu2-setup.c	1970-01-01 01:00:00.000000000 +0100
+++ test14/arch/arm/mach-ixp4xx/nslu2-setup.c	2005-10-06 21:29:53.000000000 +0200
@@ -0,0 +1,134 @@
+/*
+ * arch/arm/mach-ixp4xx/nslu2-setup.c
+ *
+ * NSLU2 board-setup
+ *
+ * based ixdp425-setup.c:
+ *      Copyright (C) 2003-2004 MontaVista Software, Inc.
+ *
+ * Author: Mark Rakes <mrakes at mac.com>
+ * Maintainers: http://www.nslu2-linux.org/
+ *
+ * Fixed missing init_time in MACHINE_START kas11 10/22/04
+ * Changed to conform to new style __init ixdp425 kas11 10/22/04 
+ */
+
+#include <linux/kernel.h>
+#include <linux/serial.h>
+#include <linux/serial_8250.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/flash.h>
+
+static struct flash_platform_data nslu2_flash_data = {
+	.map_name		= "cfi_probe",
+	.width			= 2,
+};
+
+static struct resource nslu2_flash_resource = {
+	.start			= NSLU2_FLASH_BASE,
+	.end			= NSLU2_FLASH_BASE + NSLU2_FLASH_SIZE,
+	.flags			= IORESOURCE_MEM,
+};
+
+static struct platform_device nslu2_flash = {
+	.name			= "IXP4XX-Flash",
+	.id			= 0,
+	.dev.platform_data	= &nslu2_flash_data,
+	.num_resources		= 1,
+	.resource		= &nslu2_flash_resource,
+};
+
+static struct ixp4xx_i2c_pins nslu2_i2c_gpio_pins = {
+	.sda_pin		= NSLU2_SDA_PIN,
+	.scl_pin		= NSLU2_SCL_PIN,
+};
+
+static struct platform_device nslu2_i2c_controller = {
+	.name			= "IXP4XX-I2C",
+	.id			= 0,
+	.dev.platform_data	= &nslu2_i2c_gpio_pins,
+	.num_resources		= 0
+};
+
+static struct resource nslu2_uart_resources[] = {
+	{
+		.start		= IXP4XX_UART1_BASE_PHYS,
+		.end		= IXP4XX_UART1_BASE_PHYS + 0x0fff,
+		.flags		= IORESOURCE_MEM
+	},
+	{
+		.start		= IXP4XX_UART2_BASE_PHYS,
+		.end		= IXP4XX_UART2_BASE_PHYS + 0x0fff,
+		.flags		= IORESOURCE_MEM
+	}
+};
+
+static struct plat_serial8250_port nslu2_uart_data[] = {
+	{
+		.mapbase	= IXP4XX_UART1_BASE_PHYS,
+		.membase	= (char *)IXP4XX_UART1_BASE_VIRT + REG_OFFSET,
+		.irq		= IRQ_IXP4XX_UART1,
+		.flags		= UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= IXP4XX_UART_XTAL,
+	},
+	{
+		.mapbase	= IXP4XX_UART2_BASE_PHYS,
+		.membase	= (char *)IXP4XX_UART2_BASE_VIRT + REG_OFFSET,
+		.irq		= IRQ_IXP4XX_UART2,
+		.flags		= UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= IXP4XX_UART_XTAL,
+	},
+	{ }
+};
+
+static struct platform_device nslu2_uart = {
+	.name			= "serial8250",
+	.id			= PLAT8250_DEV_PLATFORM,
+	.dev.platform_data	= nslu2_uart_data,
+	.num_resources		= 2,
+	.resource		= nslu2_uart_resources
+};
+
+static struct platform_device *nslu2_devices[] __initdata = {
+	&nslu2_i2c_controller,
+	&nslu2_flash,
+	&nslu2_uart
+};
+
+static void nslu2_power_off(void)
+{
+        /* This causes the box to drop the power and go dead. */
+
+	/* enable the pwr cntl gpio */
+	gpio_line_config(NSLU2_PO_GPIO, IXP4XX_GPIO_OUT);
+
+	/* do the deed */
+	gpio_line_set(NSLU2_PO_GPIO, IXP4XX_GPIO_HIGH);
+}
+
+static void __init nslu2_init(void)
+{
+	ixp4xx_sys_init();
+
+	pm_power_off = nslu2_power_off;
+
+	platform_add_devices(nslu2_devices, ARRAY_SIZE(nslu2_devices));
+}
+
+MACHINE_START(NSLU2, "Linksys NSLU2")
+	/* Maintainer: www.nslu2-linux.org */
+	.phys_ram	= PHYS_OFFSET,
+	.phys_io	= IXP4XX_PERIPHERAL_BASE_PHYS,
+	.io_pg_offst	= ((IXP4XX_PERIPHERAL_BASE_VIRT) >> 18) & 0xFFFC,
+	.boot_params	= 0x00000100,
+	.map_io		= ixp4xx_map_io,
+	.init_irq	= ixp4xx_init_irq, /* FIXME: all irq are off here */
+        .timer          = &ixp4xx_timer,
+	.init_machine	= nslu2_init,
+MACHINE_END
--- linux-2.6.14-rc3/arch/arm/mach-ixp4xx/nslu2-pci.c	1970-01-01 01:00:00.000000000 +0100
+++ test14/arch/arm/mach-ixp4xx/nslu2-pci.c	2005-10-06 21:29:53.000000000 +0200
@@ -0,0 +1,78 @@
+/*
+ * arch/arm/mach-ixp4xx/nslu2-pci.c
+ *
+ * NSLU2 board-level PCI initialization
+ *
+ * based on ixdp425-pci.c:
+ *	Copyright (C) 2002 Intel Corporation.
+ *	Copyright (C) 2003-2004 MontaVista Software, Inc.
+ *
+ * Maintainer: http://www.nslu2-linux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+
+#include <asm/mach/pci.h>
+#include <asm/mach-types.h>
+
+void __init nslu2_pci_preinit(void)
+{
+	set_irq_type(IRQ_NSLU2_PCI_INTA, IRQT_LOW);
+	set_irq_type(IRQ_NSLU2_PCI_INTB, IRQT_LOW);
+	set_irq_type(IRQ_NSLU2_PCI_INTC, IRQT_LOW);
+
+	gpio_line_isr_clear(NSLU2_PCI_INTA_PIN);
+	gpio_line_isr_clear(NSLU2_PCI_INTB_PIN);
+	gpio_line_isr_clear(NSLU2_PCI_INTC_PIN);
+
+	/* INTD is not configured as GPIO is used
+	 * for the power input button.
+	 */
+
+	ixp4xx_pci_preinit();
+}
+
+static int __init nslu2_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	static int pci_irq_table[NSLU2_PCI_IRQ_LINES] = {
+		IRQ_NSLU2_PCI_INTA,
+		IRQ_NSLU2_PCI_INTB,
+		IRQ_NSLU2_PCI_INTC,
+	};
+
+	int irq = -1;
+
+	if (slot >= 1 && slot <= NSLU2_PCI_MAX_DEV &&
+		pin >= 1 && pin <= NSLU2_PCI_IRQ_LINES) {
+			irq = pci_irq_table[
+				(slot + pin - 2) % NSLU2_PCI_IRQ_LINES];
+	}
+
+	return irq;
+}
+
+struct hw_pci __initdata nslu2_pci = {
+	.nr_controllers = 1,
+	.preinit	= nslu2_pci_preinit,
+	.swizzle	= pci_std_swizzle,
+	.setup		= ixp4xx_setup,
+	.scan		= ixp4xx_scan_bus,
+	.map_irq	= nslu2_map_irq,
+};
+
+int __init nslu2_pci_init(void) /* monkey see, monkey do */
+{
+	if (machine_is_nslu2())
+		pci_common_init(&nslu2_pci);
+
+	return 0;
+}
+
+subsys_initcall(nslu2_pci_init);
--- linux-2.6.14-rc3/arch/arm/mach-ixp4xx/nslu2-power.c	1970-01-01 01:00:00.000000000 +0100
+++ test14/arch/arm/mach-ixp4xx/nslu2-power.c	2005-10-06 21:39:43.000000000 +0200
@@ -0,0 +1,92 @@
+/*
+ * arch/arm/mach-ixp4xx/nslu2-power.c
+ *
+ * NSLU2 Power/Reset driver
+ *
+ * Copyright (C) 2005 Tower Technologies
+ *
+ * based on nslu2-io.c  
+ *  Copyright (C) 2004 Karen Spearel
+ *
+ * Author: Alessandro Zummo <a.zummo@towertech.it>
+ * Maintainers: http://www.nslu2-linux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/reboot.h>
+#include <linux/interrupt.h>
+
+#include <asm/mach-types.h>
+
+static irqreturn_t nslu2_power_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+	/* Signal init to do the ctrlaltdel action */
+	kill_proc(1, SIGINT, 1);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t nslu2_reset_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+	/* FIXME This doesn't reset the NSLU2. It powers it off.
+	 * Close enough, since reset is unreliable
+	 */
+
+	machine_power_off();
+
+	return IRQ_HANDLED;
+}
+
+static int __init nslu2_power_init(void)
+{
+	if (!(machine_is_nslu2()))
+		return 0;
+
+	printk(KERN_INFO "NSLU2: power/reset\n");
+
+	*IXP4XX_GPIO_GPISR = 0x20400000;	/* read the 2 irqs to clr */
+
+	set_irq_type(NSLU2_RB_IRQ, IRQT_LOW);
+	set_irq_type(NSLU2_PB_IRQ, IRQT_HIGH);
+
+	gpio_line_isr_clear(NSLU2_RB_GPIO);
+	gpio_line_isr_clear(NSLU2_PB_GPIO);
+
+	if (request_irq(NSLU2_RB_IRQ, &nslu2_reset_handler,
+		SA_INTERRUPT, "NSLU2 reset button", NULL) < 0) {
+
+		printk(KERN_DEBUG "Reset Button IRQ %d not available\n",
+			NSLU2_RB_IRQ);
+
+		return -EIO;
+	}
+
+	if (request_irq(NSLU2_PB_IRQ, &nslu2_power_handler,
+		SA_INTERRUPT, "NSLU2 power button", NULL) < 0) {
+
+		printk(KERN_DEBUG "Power Button IRQ %d not available\n",
+			NSLU2_PB_IRQ);
+
+		return -EIO;	
+	}
+
+	return 0;
+}
+
+static void __exit nslu2_power_exit(void)
+{
+	free_irq(NSLU2_RB_IRQ, NULL);
+	free_irq(NSLU2_PB_IRQ, NULL);
+}
+
+module_init(nslu2_power_init);
+module_exit(nslu2_power_exit);
+
+MODULE_AUTHOR("Alessandro Zummo <a.zummo@towertech.it>");
+MODULE_DESCRIPTION("NSLU2 Power/Reset driver");
+MODULE_LICENSE("GPL");
--- linux-2.6.14-rc3/include/asm-arm/arch-ixp4xx/nslu2.h	1970-01-01 01:00:00.000000000 +0100
+++ test14/include/asm-arm/arch-ixp4xx/nslu2.h	2005-10-06 21:29:53.000000000 +0200
@@ -0,0 +1,96 @@
+/*
+ * include/asm-arm/arch-ixp4xx/nslu2.h
+ *
+ * NSLU2 platform specific definitions
+ *
+ * Author: Mark Rakes <mrakes AT mac.com>
+ * Maintainers: http://www.nslu2-linux.org
+ *
+ * based on ixdp425.h:
+ *	Copyright 2004 (c) MontaVista, Software, Inc.
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H__
+#error "Do not include this directly, instead #include <asm/hardware.h>"
+#endif
+
+#define NSLU2_FLASH_BASE	IXP4XX_EXP_BUS_CS0_BASE_PHYS
+#define NSLU2_FLASH_SIZE	IXP4XX_EXP_BUS_CSX_REGION_SIZE
+
+#define NSLU2_SDA_PIN		7
+#define NSLU2_SCL_PIN		6
+
+/*
+ * NSLU2 PCI IRQs
+ */
+#define NSLU2_PCI_MAX_DEV	3
+#define NSLU2_PCI_IRQ_LINES	3
+
+
+/* PCI controller GPIO to IRQ pin mappings */
+#define NSLU2_PCI_INTA_PIN	11
+#define NSLU2_PCI_INTB_PIN	10
+#define NSLU2_PCI_INTC_PIN	9
+#define NSLU2_PCI_INTD_PIN	8
+
+
+/* NSLU2 Timer */
+#define NSLU2_FREQ 66000000
+#define NSLU2_CLOCK_TICK_RATE (((NSLU2_FREQ / HZ & ~IXP4XX_OST_RELOAD_MASK) + 1) * HZ)
+#define NSLU2_CLOCK_TICKS_PER_USEC ((NSLU2_CLOCK_TICK_RATE + USEC_PER_SEC/2) / USEC_PER_SEC)
+
+/* GPIO */
+
+#define NSLU2_GPIO0		0
+#define NSLU2_GPIO1		1
+#define NSLU2_GPIO2		2
+#define NSLU2_GPIO3		3
+#define NSLU2_GPIO4		4
+#define NSLU2_GPIO5		5
+#define NSLU2_GPIO6		6
+#define NSLU2_GPIO7		7
+#define NSLU2_GPIO8		8
+#define NSLU2_GPIO9		9
+#define NSLU2_GPIO10		10
+#define NSLU2_GPIO11		11
+#define NSLU2_GPIO12		12
+#define NSLU2_GPIO13		13
+#define NSLU2_GPIO14		14
+#define NSLU2_GPIO15		15
+
+/* Buttons */
+
+#define NSLU2_PB_GPIO		NSLU2_GPIO5
+#define NSLU2_PO_GPIO		NSLU2_GPIO8	/* power off */
+#define NSLU2_RB_GPIO		NSLU2_GPIO12
+
+#define NSLU2_PB_IRQ		IRQ_IXP4XX_GPIO5
+#define NSLU2_RB_IRQ		IRQ_IXP4XX_GPIO12
+
+#define NSLU2_PB_BM		(1L << NSLU2_PB_GPIO)
+#define NSLU2_PO_BM		(1L << NSLU2_PO_GPIO)
+#define NSLU2_RB_BM		(1L << NSLU2_RB_GPIO)
+
+/* Buzzer */
+
+#define NSLU2_GPIO_BUZZ		4
+#define NSLU2_BZ_BM		(1L << NSLU2_GPIO_BUZZ)
+/* LEDs */
+
+#define NSLU2_LED_RED		NSLU2_GPIO0
+#define NSLU2_LED_GRN		NSLU2_GPIO1
+
+#define NSLU2_LED_RED_BM	(1L << NSLU2_LED_RED)
+#define NSLU2_LED_GRN_BM	(1L << NSLU2_LED_GRN)
+
+#define NSLU2_LED_DISK1		NSLU2_GPIO2
+#define NSLU2_LED_DISK2		NSLU2_GPIO3
+
+#define NSLU2_LED_DISK1_BM	(1L << NSLU2_GPIO2)
+#define NSLU2_LED_DISK2_BM	(1L << NSLU2_GPIO3)
+
+
--- linux-2.6.14-rc3/arch/arm/Kconfig	2005-10-01 13:46:47.000000000 +0200
+++ test14/arch/arm/Kconfig	2005-10-06 21:29:53.000000000 +0200
@@ -389,7 +389,8 @@
 		   ARCH_EBSA285 || ARCH_IMX || ARCH_INTEGRATOR || \
 		   ARCH_LUBBOCK || MACH_MAINSTONE || ARCH_NETWINDER || \
 		   ARCH_OMAP || ARCH_P720T || ARCH_PXA_IDP || \
-		   ARCH_SA1100 || ARCH_SHARK || ARCH_VERSATILE
+		   ARCH_SA1100 || ARCH_SHARK || ARCH_VERSATILE || \
+		   MACH_NSLU2
 	help
 	  If you say Y here, the LEDs on your machine will be used
 	  to provide useful information about your current system status.
@@ -403,7 +404,7 @@
 
 config LEDS_TIMER
 	bool "Timer LED" if (!ARCH_CDB89712 && !ARCH_OMAP) || \
-			    MACH_OMAP_H2 || MACH_OMAP_PERSEUS2
+			    MACH_OMAP_H2 || MACH_OMAP_PERSEUS2 || MACH_NSLU2
 	depends on LEDS
 	default y if ARCH_EBSA110
 	help
@@ -419,7 +420,8 @@
 
 config LEDS_CPU
 	bool "CPU usage LED" if (!ARCH_CDB89712 && !ARCH_EBSA110 && \
-			!ARCH_OMAP) || MACH_OMAP_H2 || MACH_OMAP_PERSEUS2
+			!ARCH_OMAP) || MACH_OMAP_H2 || MACH_OMAP_PERSEUS2 \
+			|| MACH_NSLU2
 	depends on LEDS
 	help
 	  If you say Y here, the red LED will be used to give a good real
--- linux-2.6.14-rc3/arch/arm/mach-ixp4xx/nslu2-leds.c	1970-01-01 01:00:00.000000000 +0100
+++ test14/arch/arm/mach-ixp4xx/nslu2-leds.c	2005-10-06 21:29:53.000000000 +0200
@@ -0,0 +1,223 @@
+/*
+ * arch/arm/mach-ixp4xx/nslu2-leds.c
+ *
+ * NSLU2 LEDs driver
+ *
+ * Copyright (C) 2005 Tower Technologies
+ *
+ * based on nslu2-io.c  
+ *  Copyright (C) 2004 Karen Spearel
+ * and arch/arm/mach-footbridge/netwinder-leds.c
+ *  Copyright (C) 1998-1999 Russell King 
+ *
+ * Author: Alessandro Zummo <a.zummo@towertech.it>
+ * Maintainers: http://www.nslu2-linux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/notifier.h>
+
+#include <asm/hardware.h>
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+#include <asm/system.h>
+
+#define LED_STATE_ENABLED	0x01
+#define LED_STATE_CLAIMED	0x02
+#define LED_STATE_IDLE		0x04
+
+static unsigned char led_state;
+static unsigned int hw_led_state;
+
+static const unsigned long idle_seq[4] = {
+	
+	NSLU2_LED_GRN_BM, 0,
+	NSLU2_LED_GRN_BM, 0,
+};
+
+static const unsigned long busy_seq[4] = {
+
+	NSLU2_LED_GRN_BM, 0,
+	NSLU2_LED_GRN_BM | NSLU2_LED_RED_BM, 0,
+};
+
+static unsigned char led_count = 0;
+
+static DEFINE_SPINLOCK(leds_lock);
+extern spinlock_t gpio_lock;
+
+static void nslu2_leds_event(led_event_t evt)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&leds_lock, flags);
+
+	switch (evt) {
+	case led_start:
+		/* Let's rock! Red led on, all others off. Remember
+		 * that disk1/disk2 works inverted. On the NSLU2, the
+		 * interface starts in a claimed state. XXX
+		 */
+		led_state = LED_STATE_ENABLED | LED_STATE_CLAIMED;
+		hw_led_state = NSLU2_LED_DISK1_BM | NSLU2_LED_DISK2_BM
+				| NSLU2_LED_RED_BM;
+		break;
+
+	case led_stop:
+		led_state &= ~LED_STATE_ENABLED;
+		break;
+
+	case led_claim:
+		/* The user claimed the interface, red and green off */
+		led_state |= LED_STATE_CLAIMED;
+		hw_led_state &= ~(NSLU2_LED_RED_BM | NSLU2_LED_GRN_BM);
+		break;
+
+	case led_release:
+		/* The user released the interface, preserve the last
+		 * status of the leds, except red/green.
+		 */
+		led_state &= ~LED_STATE_CLAIMED;
+		hw_led_state = *IXP4XX_GPIO_GPOUTR & 0x0000000C;
+		break;
+
+#ifdef CONFIG_LEDS_TIMER
+	case led_timer:
+		/* Pulse green led */
+		if (!(led_state & LED_STATE_CLAIMED))
+		{
+			/* clear red and green bits */
+			hw_led_state &= ~(NSLU2_LED_RED_BM | NSLU2_LED_GRN_BM);
+
+			/* copy the right sequence in */
+			if (led_state & LED_STATE_IDLE)
+				hw_led_state |= idle_seq[led_count % 4];
+			else
+				hw_led_state |= busy_seq[led_count % 4];
+
+			led_count++;
+		}
+		break;
+#endif
+
+#ifdef CONFIG_LEDS_CPU
+
+	case led_idle_start:
+		led_state |= LED_STATE_IDLE;
+#ifndef CONFIG_LEDS_TIMER
+		/* green on, red off */
+		hw_led_state |= NSLU2_LED_GRN_BM;
+		hw_led_state &= ~NSLU2_LED_RED_BM;
+#endif
+		break;
+
+	case led_idle_end:
+		led_state &= ~LED_STATE_IDLE;
+#ifndef CONFIG_LEDS_TIMER
+		/* green on, red on -> amber on */
+		hw_led_state |= NSLU2_LED_GRN_BM | NSLU2_LED_RED_BM;
+#endif
+		break;
+#endif
+
+	case led_halted:
+		if (!(led_state & LED_STATE_CLAIMED))
+			hw_led_state |= NSLU2_LED_RED_BM;
+		break;
+
+	/* leds */
+
+	case led_green_on:
+		if (led_state & LED_STATE_CLAIMED)
+			hw_led_state |= NSLU2_LED_GRN_BM;
+		break;
+
+	case led_green_off:
+		if (led_state & LED_STATE_CLAIMED)
+			hw_led_state &= ~NSLU2_LED_GRN_BM;
+		break;
+
+	case led_amber_on:
+		if (led_state & LED_STATE_CLAIMED)
+			hw_led_state |= (NSLU2_LED_RED_BM | NSLU2_LED_GRN_BM);
+		break;
+
+	case led_amber_off:
+		if (led_state & LED_STATE_CLAIMED)
+			hw_led_state &= ~(NSLU2_LED_RED_BM | NSLU2_LED_GRN_BM);
+		break;
+
+	case led_red_on:
+		if (led_state & LED_STATE_CLAIMED)
+			hw_led_state |= NSLU2_LED_RED_BM;
+		break;
+
+	case led_red_off:
+		if (led_state & LED_STATE_CLAIMED)
+			hw_led_state &= ~NSLU2_LED_RED_BM;
+		break;
+
+	default:
+		break;
+	}
+
+	spin_unlock_irqrestore(&leds_lock, flags);
+
+	if  (led_state & LED_STATE_ENABLED) {
+		spin_lock_irqsave(&gpio_lock, flags);
+		*IXP4XX_GPIO_GPOUTR = (*IXP4XX_GPIO_GPOUTR & 0xFFFFFFF0) | hw_led_state;
+		spin_unlock_irqrestore(&gpio_lock, flags);
+	}
+}
+
+static int nslu2_leds_panic_event(struct notifier_block *this, unsigned long event,
+	void *ptr)
+{
+	leds_event(led_green_off);
+	leds_event(led_red_on);
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block nslu2_leds_panic_block = {
+	.notifier_call	= nslu2_leds_panic_event,
+};
+
+static int __init nslu2_leds_init(void)
+{
+	if (!(machine_is_nslu2()))
+		return 0;
+
+	printk(KERN_INFO "NSLU2: leds\n");
+
+	/* register panic notifier */
+	notifier_chain_register(&panic_notifier_list, &nslu2_leds_panic_block);
+
+	/* enable gpio 0-3 */
+	gpio_line_config(NSLU2_LED_GRN, IXP4XX_GPIO_OUT);
+	gpio_line_config(NSLU2_LED_RED, IXP4XX_GPIO_OUT);
+	gpio_line_config(NSLU2_LED_DISK1, IXP4XX_GPIO_OUT);
+	gpio_line_config(NSLU2_LED_DISK2, IXP4XX_GPIO_OUT);
+
+	leds_event = nslu2_leds_event;
+
+	/* this will also initialize the leds to the
+	 * default state.
+	 */
+
+	leds_event(led_start);
+
+	return 0;
+}
+
+module_init(nslu2_leds_init);
+
