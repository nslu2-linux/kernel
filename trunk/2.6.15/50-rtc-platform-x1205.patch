 drivers/i2c/chips/x1205.c |   73 ++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 71 insertions(+), 2 deletions(-)

--- linux-nslu2.orig/drivers/i2c/chips/x1205.c	2005-12-12 02:29:27.000000000 +0100
+++ linux-nslu2/drivers/i2c/chips/x1205.c	2005-12-12 02:33:34.000000000 +0100
@@ -18,13 +18,14 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/slab.h>
+#include <linux/err.h>
 #include <linux/i2c.h>
 #include <linux/string.h>
 #include <linux/bcd.h>
 #include <linux/rtc.h>
 #include <linux/delay.h>
 
-#define DRV_VERSION "1.0.1"
+#define DRV_VERSION "1.0.2"
 
 /* Addresses to scan: none. This chip is located at
  * 0x6f and uses a two bytes register addressing.
@@ -517,6 +518,53 @@ static int x1205_validate_client(struct 
 	return 0;
 }
 
+static int x1205_rtc_read_alarm(struct device *dev,
+	struct rtc_wkalrm *alrm)
+{
+	return x1205_get_datetime(to_i2c_client(dev),
+		&alrm->time, X1205_ALM0_BASE);
+}
+
+static int x1205_rtc_set_alarm(struct device *dev,
+	struct rtc_wkalrm *alrm)
+{
+	return x1205_set_datetime(to_i2c_client(dev),
+		&alrm->time, 1, X1205_ALM0_BASE);
+}
+
+static int x1205_rtc_read_time(struct device *dev,
+	struct rtc_time *tm)
+{
+	return x1205_get_datetime(to_i2c_client(dev),
+		tm, X1205_CCR_BASE);
+}
+
+static int x1205_rtc_set_time(struct device *dev,
+	struct rtc_time *tm)
+{
+	return x1205_set_datetime(to_i2c_client(dev),
+		tm, 1, X1205_CCR_BASE);
+}
+
+static int x1205_rtc_proc(struct device *dev, char *buf)
+{
+	int err, dtrim, atrim;
+	char *p = buf;
+
+	p += sprintf(p, "24hr\t\t: yes\n");
+
+	err = x1205_get_dtrim(to_i2c_client(dev), &dtrim);
+	if (err == 0)
+		p += sprintf(p, "digital_trim\t: %d ppm\n", dtrim);
+
+	err = x1205_get_atrim(to_i2c_client(dev), &atrim);
+	if (err == 0)
+		p += sprintf(p, "analog_trim\t: %d.%02d pF\n",
+			atrim / 1000, atrim % 1000);
+
+	return p - buf;
+}
+
 static int x1205_attach(struct i2c_adapter *adapter)
 {
 	dev_dbg(&adapter->dev, "%s\n", __FUNCTION__);
@@ -524,11 +572,21 @@ static int x1205_attach(struct i2c_adapt
 	return i2c_probe(adapter, &addr_data, x1205_probe);
 }
 
+struct rtc_class_ops x1205_rtc_ops = {
+	.owner = THIS_MODULE,
+	.proc = x1205_rtc_proc,
+	.read_time = x1205_rtc_read_time,
+	.set_time = x1205_rtc_set_time,
+	.read_alarm = x1205_rtc_read_alarm,
+	.set_alarm = x1205_rtc_set_alarm,
+};
+
 static int x1205_probe(struct i2c_adapter *adapter, int address, int kind)
 {
 	int err = 0;
 	unsigned char sr;
 	struct i2c_client *client;
+	struct class_device *rtc_dev;
 
 	dev_dbg(&adapter->dev, "%s\n", __FUNCTION__);
 
@@ -542,7 +600,7 @@ static int x1205_probe(struct i2c_adapte
 		goto exit;
 	}
 
-	/* Initialize our structures */
+	/* I2C client */
 	client->addr = address;
 	client->driver = &x1205_driver;
 	client->adapter	= adapter;
@@ -563,6 +621,9 @@ static int x1205_probe(struct i2c_adapte
 
 	dev_info(&client->dev, "chip found, driver version " DRV_VERSION "\n");
 
+	rtc_dev = rtc_device_register(&client->dev, &x1205_rtc_ops);
+	i2c_set_clientdata(client, rtc_dev);
+
 	/* Check for power failures and eventualy enable the osc */
 	if ((err = x1205_get_status(client, &sr)) == 0) {
 		if (sr & X1205_SR_RTCF) {
@@ -595,12 +656,20 @@ exit:
 static int x1205_detach(struct i2c_client *client)
 {
 	int err;
+	struct class_device *rtc_dev = i2c_get_clientdata(client);
 
 	dev_dbg(&client->dev, "%s\n", __FUNCTION__);
 
+	if (rtc_dev)
+		rtc_device_unregister(rtc_dev);
+
+	dev_dbg(&client->dev, "%s, rtc dev unregistered\n", __FUNCTION__);
+
 	if ((err = i2c_detach_client(client)))
 		return err;
 
+	dev_dbg(&client->dev, "%s, client detached\n", __FUNCTION__);
+
 	kfree(client);
 
 	return 0;
