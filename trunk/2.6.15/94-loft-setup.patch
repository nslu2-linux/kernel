Include a fixup machine start function in the loft part of
ixdp425-setup.c to handle the command line and memory setup
parameters which are not specifiable in the boot loader.

Signed-off-by: John Bowler <jbowler@acm.org>


--- linux-2.6.15/arch/arm/mach-ixp4xx/ixdp425-setup.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/arch/arm/mach-ixp4xx/ixdp425-setup.c	1970-01-01 00:00:00.000000000 +0000
@@ -191,8 +191,8 @@ MACHINE_END
 /*
  * Loft is functionally equivalent to Avila except that it has a
  * different number for the maximum PCI devices.  The MACHINE
- * structure below is identical to Avila except for the and
- * the use of a loft specific init.
+ * structure below is derived from the Avila one (and may, in
+ * fact, be useful on Avila in general).
  *
  * The loft init registers a notifier on the on-board EEPROM to
  * detect the MAC addresses.
@@ -201,6 +201,58 @@ MACHINE_END
  */
 #ifdef CONFIG_MACH_LOFT
 /*
+ * Loft bootstrap may pass in parameters, if these contain an
+ * ATAG_MEM and it appears valid (not the 16MByte one in the
+ * setup/kernel.c default) we use it, otherwise a 64MByte
+ * setting is forced here, this may be overridden on the
+ * command line.
+ */
+static void __init loft_fixup(struct machine_desc *desc,
+		struct tag *tags, char **cmdline, struct meminfo *mi)
+{
+	char saved_command_line[COMMAND_LINE_SIZE];
+	/* Put Loft specific known-required-for-certain stuff here, leave
+	 * a trailing space!
+	 */
+	static char loft_command_line[] =
+		"root=/dev/mtdblock2 rw rootfstype=jffs2 init=/linuxrc "
+		"rtc-ds1672.probe=0,0x68 rtc-ds1672.hctosys=1 ";
+	const int len = (sizeof loft_command_line)-1;
+	int memtag = 0;
+
+	/* The Loft typically has one bank of 64MByte memory.
+	 * NOTE: setting nr_banks != 0 causes kernel/setup.c to remove
+	 * the mem tags from the tag list, so if there is an entry
+	 * there don't remove it!
+	 */
+	if (tags->hdr.tag == ATAG_CORE) do {
+		tags = tag_next(tags);
+		printk(KERN_NOTICE "ATAG[0x%x] size %d\n", tags->hdr.tag, tags->hdr.size);
+		if (tags->hdr.tag == ATAG_MEM && tags->hdr.size == tag_size(tag_mem32) &&
+			(tags->u.mem.start != 0 || tags->u.mem.size != (16*1024*1024))) {
+			memtag = 1;
+			printk(KERN_NOTICE " ATAG_MEM base %lx size %lx\n",
+					tags->u.mem.start, tags->u.mem.size);
+		}
+	} while (tags->hdr.size);
+
+	if (!memtag) {
+		mi->nr_banks=1;
+		mi->bank[0].start = 0;
+		mi->bank[0].size = (64*1024*1024);
+		mi->bank[0].node = PHYS_TO_NID(0);
+	}
+
+	/* A command line in the ATAG list will override this one,
+	 * as is intended.
+	 */
+	memcpy(saved_command_line, *cmdline, COMMAND_LINE_SIZE);
+	memcpy(*cmdline, loft_command_line, len);
+	memcpy(*cmdline + len, saved_command_line, COMMAND_LINE_SIZE - len);
+	*cmdline[COMMAND_LINE_SIZE-1] = 0;
+}
+
+/*
  * When the EEPROM is added the MAC address are read from it.
  */
 static void loft_eeprom_add(int address, int kind, struct kobject *kobj,
@@ -252,6 +304,7 @@ MACHINE_START(LOFT, "Giant Shoulder Inc 
 	.phys_ram	= PHYS_OFFSET,
 	.phys_io	= IXP4XX_PERIPHERAL_BASE_PHYS,
 	.io_pg_offst	= ((IXP4XX_PERIPHERAL_BASE_VIRT) >> 18) & 0xfffc,
+	.fixup          = loft_fixup,
 	.map_io		= ixp4xx_map_io,
 	.init_irq	= ixp4xx_init_irq,
 	.timer		= &ixp4xx_timer,
