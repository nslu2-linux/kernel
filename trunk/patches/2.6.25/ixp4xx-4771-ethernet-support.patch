From 31f59b98f850870515f73d05517b2fa00d9e46fd Mon Sep 17 00:00:00 2001
From: Rod Whitby <rod@whitby.id.au>
Date: Sun, 27 Jan 2008 09:06:51 +1030
Subject: [PATCH] ixp4xx: Ethernet support for the nslu2 and nas100d boards

Enables the new ixp4xx qmgr and npe drivers in ixp4xx_defconfig.

Sets up the corresponding platform data for the nslu2 and nas100d
boards, and reads the ethernet MAC address from the internal flash.

Tested on both little-endian and big-endian kernels.

Signed-off-by: Rod Whitby <rod@whitby.id.au>
Signed-off-by: Michael Westerhof <mwester@dls.net>
Tested-by: Tom King <tom@websb.net>
---
 arch/arm/configs/ixp4xx_defconfig    |    8 ++++-
 arch/arm/mach-ixp4xx/nas100d-setup.c |   49 +++++++++++++++++++++++++++++++++
 arch/arm/mach-ixp4xx/nslu2-setup.c   |   50 ++++++++++++++++++++++++++++++++++
 3 files changed, 105 insertions(+), 2 deletions(-)

Index: linux-2.6.24-armeb/arch/arm/configs/ixp4xx_defconfig
===================================================================
--- linux-2.6.24-armeb.orig/arch/arm/configs/ixp4xx_defconfig	2008-01-27 22:09:53.000000000 +1030
+++ linux-2.6.24-armeb/arch/arm/configs/ixp4xx_defconfig	2008-01-27 22:09:53.000000000 +1030
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.24-rc8
-# Wed Jan 23 17:26:16 2008
+# Linux kernel version: 2.6.24
+# Sun Jan 27 07:33:38 2008
 #
 CONFIG_ARM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
@@ -174,6 +174,8 @@
 #
 CONFIG_DMABOUNCE=y
 # CONFIG_IXP4XX_INDIRECT_PCI is not set
+CONFIG_IXP4XX_QMGR=y
+CONFIG_IXP4XX_NPE=y
 
 #
 # Boot options
@@ -832,6 +834,7 @@
 # CONFIG_PHYLIB is not set
 CONFIG_NET_ETHERNET=y
 CONFIG_MII=y
+CONFIG_IXP4XX_ETH=y
 # CONFIG_AX88796 is not set
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
@@ -925,6 +928,7 @@
 # CONFIG_PC300TOO is not set
 # CONFIG_FARSYNC is not set
 # CONFIG_DSCC4 is not set
+# CONFIG_IXP4XX_HSS is not set
 CONFIG_DLCI=m
 CONFIG_DLCI_MAX=8
 CONFIG_WAN_ROUTER_DRIVERS=m
Index: linux-2.6.24-armeb/arch/arm/mach-ixp4xx/nas100d-setup.c
===================================================================
--- linux-2.6.24-armeb.orig/arch/arm/mach-ixp4xx/nas100d-setup.c	2008-01-27 22:09:53.000000000 +1030
+++ linux-2.6.24-armeb/arch/arm/mach-ixp4xx/nas100d-setup.c	2008-01-28 03:57:37.000000000 +1030
@@ -12,6 +12,7 @@
  *
  */
 
+#include <linux/if_ether.h>
 #include <linux/kernel.h>
 #include <linux/serial.h>
 #include <linux/serial_8250.h>
@@ -20,6 +21,7 @@
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
 #include <asm/mach/flash.h>
+#include <asm/io.h>
 
 static struct flash_platform_data nas100d_flash_data = {
 	.map_name		= "cfi_probe",
@@ -123,12 +125,30 @@
 	.resource		= nas100d_uart_resources,
 };
 
+/* Built-in 10/100 Ethernet MAC interfaces */
+static struct eth_plat_info nas100d_plat_eth[] = {
+	{
+		.phy		= 0,
+		.rxq		= 3,
+		.txreadyq	= 20,
+	}
+};
+
+static struct platform_device nas100d_eth[] = {
+	{
+		.name			= "ixp4xx_eth",
+		.id			= IXP4XX_ETH_NPEB,
+		.dev.platform_data	= nas100d_plat_eth,
+	}
+};
+
 static struct platform_device *nas100d_devices[] __initdata = {
 	&nas100d_i2c_controller,
 	&nas100d_flash,
 #ifdef CONFIG_LEDS_IXP4XX
 	&nas100d_leds,
 #endif
+	&nas100d_eth[0],
 };
 
 static void nas100d_power_off(void)
@@ -144,6 +164,10 @@
 
 static void __init nas100d_init(void)
 {
+	DECLARE_MAC_BUF(mac_buf);
+	uint8_t __iomem *f;
+	int i;
+
 	ixp4xx_sys_init();
 
 	/* gpio 14 and 15 are _not_ clocks */
@@ -163,6 +187,30 @@
 	(void)platform_device_register(&nas100d_uart);
 
 	platform_add_devices(nas100d_devices, ARRAY_SIZE(nas100d_devices));
+
+	/*
+	 * Map in a portion of the flash and read the MAC address.
+	 * Since it is stored in BE in the flash itself, we need to
+	 * byteswap it if we're in LE mode.
+	 */
+	f = ioremap(IXP4XX_EXP_BUS_BASE(0), 0x1000000);
+	if (f) {
+#ifdef __ARMEB__
+		for (i = 0; i < 6; i++)
+			nas100d_plat_eth[0].hwaddr[i] = readb(f + 0xFC0FD8 + i);
+#else
+		nas100d_plat_eth[0].hwaddr[0] = readb(f + 0xFC0FD8 + 3);
+		nas100d_plat_eth[0].hwaddr[1] = readb(f + 0xFC0FD8 + 2);
+		nas100d_plat_eth[0].hwaddr[2] = readb(f + 0xFC0FD8 + 1);
+		nas100d_plat_eth[0].hwaddr[3] = readb(f + 0xFC0FD8 + 0);
+		nas100d_plat_eth[0].hwaddr[4] = readb(f + 0xFC0FD8 + 7);
+		nas100d_plat_eth[0].hwaddr[5] = readb(f + 0xFC0FD8 + 6);
+#endif
+		iounmap(f);
+	}
+	printk(KERN_INFO "NAS100D: Using MAC address %s for port 0\n",
+	       print_mac(mac_buf, nas100d_plat_eth[0].hwaddr));
+
 }
 
 MACHINE_START(NAS100D, "Iomega NAS 100d")
Index: linux-2.6.24-armeb/arch/arm/mach-ixp4xx/nslu2-setup.c
===================================================================
--- linux-2.6.24-armeb.orig/arch/arm/mach-ixp4xx/nslu2-setup.c	2008-01-27 22:09:49.000000000 +1030
+++ linux-2.6.24-armeb/arch/arm/mach-ixp4xx/nslu2-setup.c	2008-01-28 03:57:25.000000000 +1030
@@ -14,6 +14,7 @@
  * Changed to conform to new style __init ixdp425 kas11 10/22/04
  */
 
+#include <linux/if_ether.h>
 #include <linux/kernel.h>
 #include <linux/serial.h>
 #include <linux/serial_8250.h>
@@ -23,6 +24,7 @@
 #include <asm/mach/arch.h>
 #include <asm/mach/flash.h>
 #include <asm/mach/time.h>
+#include <asm/io.h>
 
 static struct flash_platform_data nslu2_flash_data = {
 	.map_name		= "cfi_probe",
@@ -138,6 +140,23 @@
 	.resource		= nslu2_uart_resources,
 };
 
+/* Built-in 10/100 Ethernet MAC interfaces */
+static struct eth_plat_info nslu2_plat_eth[] = {
+	{
+		.phy		= 1,
+		.rxq		= 3,
+		.txreadyq	= 20,
+	}
+};
+
+static struct platform_device nslu2_eth[] = {
+	{
+		.name			= "ixp4xx_eth",
+		.id			= IXP4XX_ETH_NPEB,
+		.dev.platform_data	= nslu2_plat_eth,
+	}
+};
+
 static struct platform_device *nslu2_devices[] __initdata = {
 	&nslu2_i2c_controller,
 	&nslu2_flash,
@@ -145,6 +164,7 @@
 #ifdef CONFIG_LEDS_IXP4XX
 	&nslu2_leds,
 #endif
+	&nslu2_eth[0],
 };
 
 static void nslu2_power_off(void)
@@ -173,6 +193,10 @@
 
 static void __init nslu2_init(void)
 {
+	DECLARE_MAC_BUF(mac_buf);
+	uint8_t __iomem *f;
+	int i;
+
 	ixp4xx_sys_init();
 
 	nslu2_flash_resource.start = IXP4XX_EXP_BUS_BASE(0);
@@ -189,6 +213,31 @@
 	(void)platform_device_register(&nslu2_uart);
 
 	platform_add_devices(nslu2_devices, ARRAY_SIZE(nslu2_devices));
+
+
+	/*
+	 * Map in a portion of the flash and read the MAC address.
+	 * Since it is stored in BE in the flash itself, we need to
+	 * byteswap it if we're in LE mode.
+	 */
+	f = ioremap(IXP4XX_EXP_BUS_BASE(0), 0x40000);
+	if (f) {
+#ifdef __ARMEB__
+		for (i = 0; i < 6; i++)
+			nslu2_plat_eth[0].hwaddr[i] = readb(f + 0x3FFB0 + i);
+#else
+		nslu2_plat_eth[0].hwaddr[0] = readb(f + 0x3FFB0 + 3);
+		nslu2_plat_eth[0].hwaddr[1] = readb(f + 0x3FFB0 + 2);
+		nslu2_plat_eth[0].hwaddr[2] = readb(f + 0x3FFB0 + 1);
+		nslu2_plat_eth[0].hwaddr[3] = readb(f + 0x3FFB0 + 0);
+		nslu2_plat_eth[0].hwaddr[4] = readb(f + 0x3FFB0 + 7);
+		nslu2_plat_eth[0].hwaddr[5] = readb(f + 0x3FFB0 + 6);
+#endif
+		iounmap(f);
+	}
+	printk(KERN_INFO "NSLU2: Using MAC address %s for port 0\n",
+	       print_mac(mac_buf, nslu2_plat_eth[0].hwaddr));
+
 }
 
 MACHINE_START(NSLU2, "Linksys NSLU2")
