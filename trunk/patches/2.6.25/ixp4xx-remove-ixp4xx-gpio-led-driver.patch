From bd70bd41a75c8fd171113c889c50a1c7af39ea3c Mon Sep 17 00:00:00 2001
From: Rod Whitby <rod@whitby.id.au>
Date: Fri, 25 Jan 2008 23:11:54 +1030
Subject: [PATCH] ixp4xx: Remove IXP4XX-GPIO-LED driver

All boards using the IXP4XX-GPIO-LED driver have been updated to use
the generic leds-gpio driver instead.

Signed-off-by: Rod Whitby <rod@whitby.id.au>
---
 arch/arm/configs/ixp4xx_defconfig |    1 -
 drivers/leds/Kconfig              |    9 --
 drivers/leds/Makefile             |    1 -
 drivers/leds/leds-ixp4xx-gpio.c   |  214 -------------------------------------
 4 files changed, 0 insertions(+), 225 deletions(-)
 delete mode 100644 drivers/leds/leds-ixp4xx-gpio.c

diff --git a/arch/arm/configs/ixp4xx_defconfig b/arch/arm/configs/ixp4xx_defconfig
index 77fe3b0..d535040 100644
--- a/arch/arm/configs/ixp4xx_defconfig
+++ b/arch/arm/configs/ixp4xx_defconfig
@@ -1330,7 +1330,6 @@ CONFIG_LEDS_CLASS=y
 #
 # LED drivers
 #
-# CONFIG_LEDS_IXP4XX is not set
 CONFIG_LEDS_GPIO=y
 
 #
diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
index ec568fa..2773ee8 100644
--- a/drivers/leds/Kconfig
+++ b/drivers/leds/Kconfig
@@ -39,15 +39,6 @@ config LEDS_SPITZ
 	  This option enables support for the LEDs on Sharp Zaurus
 	  SL-Cxx00 series (C1000, C3000, C3100).
 
-config LEDS_IXP4XX
-	tristate "LED Support for GPIO connected LEDs on IXP4XX processors"
-	depends on LEDS_CLASS && ARCH_IXP4XX
-	help
-	  This option enables support for the LEDs connected to GPIO
-	  outputs of the Intel IXP4XX processors.  To be useful the
-	  particular board must have LEDs and they must be connected
-	  to the GPIO lines.  If unsure, say Y.
-
 config LEDS_TOSA
 	tristate "LED Support for the Sharp SL-6000 series"
 	depends on LEDS_CLASS && PXA_SHARPSL
diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
index a60de1b..531c139 100644
--- a/drivers/leds/Makefile
+++ b/drivers/leds/Makefile
@@ -8,7 +8,6 @@ obj-$(CONFIG_LEDS_TRIGGERS)		+= led-triggers.o
 obj-$(CONFIG_LEDS_CORGI)		+= leds-corgi.o
 obj-$(CONFIG_LEDS_LOCOMO)		+= leds-locomo.o
 obj-$(CONFIG_LEDS_SPITZ)		+= leds-spitz.o
-obj-$(CONFIG_LEDS_IXP4XX)		+= leds-ixp4xx-gpio.o
 obj-$(CONFIG_LEDS_TOSA)			+= leds-tosa.o
 obj-$(CONFIG_LEDS_S3C24XX)		+= leds-s3c24xx.o
 obj-$(CONFIG_LEDS_AMS_DELTA)		+= leds-ams-delta.o
diff --git a/drivers/leds/leds-ixp4xx-gpio.c b/drivers/leds/leds-ixp4xx-gpio.c
deleted file mode 100644
index 7dcf0b9..0000000
--- a/drivers/leds/leds-ixp4xx-gpio.c
+++ /dev/null
@@ -1,214 +0,0 @@
-/*
- * IXP4XX GPIO driver LED driver
- *
- * Author: John Bowler <jbowler@acm.org>
- *
- * Copyright (c) 2006 John Bowler
- *
- * Permission is hereby granted, free of charge, to any
- * person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the
- * Software without restriction, including without
- * limitation the rights to use, copy, modify, merge,
- * publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the
- * following conditions:
- *
- * The above copyright notice and this permission notice
- * shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
- * ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
- * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
- * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
- * SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
- * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/spinlock.h>
-#include <linux/leds.h>
-#include <asm/arch/hardware.h>
-
-extern spinlock_t gpio_lock;
-
-/* Up to 16 gpio lines are possible. */
-#define GPIO_MAX 16
-static struct ixp4xxgpioled_device {
-	struct led_classdev ancestor;
-	int               flags;
-} ixp4xxgpioled_devices[GPIO_MAX];
-
-void ixp4xxgpioled_brightness_set(struct led_classdev *pled,
-				enum led_brightness value)
-{
-	const struct ixp4xxgpioled_device *const ixp4xx_dev =
-		container_of(pled, struct ixp4xxgpioled_device, ancestor);
-	const u32 gpio_pin = ixp4xx_dev - ixp4xxgpioled_devices;
-
-	if (gpio_pin < GPIO_MAX && ixp4xx_dev->ancestor.name != 0) {
-		/* Set or clear the 'gpio_pin' bit according to the style
-		 * and the required setting (value > 0 == on)
-		 */
-		const int gpio_value =
-			(value > 0) == (ixp4xx_dev->flags != IXP4XX_GPIO_LOW) ?
-				IXP4XX_GPIO_HIGH : IXP4XX_GPIO_LOW;
-
-		{
-			unsigned long flags;
-			spin_lock_irqsave(&gpio_lock, flags);
-			gpio_line_set(gpio_pin, gpio_value);
-			spin_unlock_irqrestore(&gpio_lock, flags);
-		}
-	}
-}
-
-/* LEDs are described in resources, the following iterates over the valid
- * LED resources.
- */
-#define for_all_leds(i, pdev) \
-	for (i=0; i<pdev->num_resources; ++i) \
-		if (pdev->resource[i].start < GPIO_MAX && \
-			pdev->resource[i].name != 0)
-
-/* The following applies 'operation' to each LED from the given platform,
- * the function always returns 0 to allow tail call elimination.
- */
-static int apply_to_all_leds(struct platform_device *pdev,
-	void (*operation)(struct led_classdev *pled))
-{
-	int i;
-
-	for_all_leds(i, pdev)
-		operation(&ixp4xxgpioled_devices[pdev->resource[i].start].ancestor);
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int ixp4xxgpioled_suspend(struct platform_device *pdev,
-				pm_message_t state)
-{
-	return apply_to_all_leds(pdev, led_classdev_suspend);
-}
-
-static int ixp4xxgpioled_resume(struct platform_device *pdev)
-{
-	return apply_to_all_leds(pdev, led_classdev_resume);
-}
-#endif
-
-static void ixp4xxgpioled_remove_one_led(struct led_classdev *pled)
-{
-	led_classdev_unregister(pled);
-	pled->name = 0;
-}
-
-static int ixp4xxgpioled_remove(struct platform_device *pdev)
-{
-	return apply_to_all_leds(pdev, ixp4xxgpioled_remove_one_led);
-}
-
-static int ixp4xxgpioled_probe(struct platform_device *pdev)
-{
-	/* The board level has to tell the driver where the
-	 * LEDs are connected - there is no way to find out
-	 * electrically.  It must also say whether the GPIO
-	 * lines are active high or active low.
-	 *
-	 * To do this read the num_resources (the number of
-	 * LEDs) and the struct resource (the data for each
-	 * LED).  The name comes from the resource, and it
-	 * isn't copied.
-	 */
-	int i;
-
-	for_all_leds(i, pdev) {
-		const u8 gpio_pin = pdev->resource[i].start;
-		int      rc;
-
-		if (ixp4xxgpioled_devices[gpio_pin].ancestor.name == 0) {
-			unsigned long flags;
-
-			spin_lock_irqsave(&gpio_lock, flags);
-			gpio_line_config(gpio_pin, IXP4XX_GPIO_OUT);
-			/* The config can, apparently, reset the state,
-			 * I suspect the gpio line may be an input and
-			 * the config may cause the line to be latched,
-			 * so the setting depends on how the LED is
-			 * connected to the line (which affects how it
-			 * floats if not driven).
-			 */
-			gpio_line_set(gpio_pin, IXP4XX_GPIO_HIGH);
-			spin_unlock_irqrestore(&gpio_lock, flags);
-
-			ixp4xxgpioled_devices[gpio_pin].flags =
-				pdev->resource[i].flags & IORESOURCE_BITS;
-
-			ixp4xxgpioled_devices[gpio_pin].ancestor.name =
-				pdev->resource[i].name;
-
-			/* This is how a board manufacturer makes the LED
-			 * come on on reset - the GPIO line will be high, so
-			 * make the LED light when the line is low...
-			 */
-			if (ixp4xxgpioled_devices[gpio_pin].flags != IXP4XX_GPIO_LOW)
-				ixp4xxgpioled_devices[gpio_pin].ancestor.brightness = 100;
-			else
-				ixp4xxgpioled_devices[gpio_pin].ancestor.brightness = 0;
-
-			ixp4xxgpioled_devices[gpio_pin].ancestor.flags = 0;
-
-			ixp4xxgpioled_devices[gpio_pin].ancestor.brightness_set =
-				ixp4xxgpioled_brightness_set;
-
-			ixp4xxgpioled_devices[gpio_pin].ancestor.default_trigger = 0;
-		}
-
-		rc = led_classdev_register(&pdev->dev,
-				&ixp4xxgpioled_devices[gpio_pin].ancestor);
-		if (rc < 0) {
-			ixp4xxgpioled_devices[gpio_pin].ancestor.name = 0;
-			ixp4xxgpioled_remove(pdev);
-			return rc;
-		}
-	}
-
-	return 0;
-}
-
-static struct platform_driver ixp4xxgpioled_driver = {
-	.probe   = ixp4xxgpioled_probe,
-	.remove  = ixp4xxgpioled_remove,
-#ifdef CONFIG_PM
-	.suspend = ixp4xxgpioled_suspend,
-	.resume  = ixp4xxgpioled_resume,
-#endif
-	.driver  = {
-		.name = "IXP4XX-GPIO-LED",
-	},
-};
-
-static int __init ixp4xxgpioled_init(void)
-{
-	return platform_driver_register(&ixp4xxgpioled_driver);
-}
-
-static void __exit ixp4xxgpioled_exit(void)
-{
-	platform_driver_unregister(&ixp4xxgpioled_driver);
-}
-
-module_init(ixp4xxgpioled_init);
-module_exit(ixp4xxgpioled_exit);
-
-MODULE_AUTHOR("John Bowler <jbowler@acm.org>");
-MODULE_DESCRIPTION("IXP4XX GPIO LED driver");
-MODULE_LICENSE("Dual MIT/GPL");
-- 
1.5.2.5

