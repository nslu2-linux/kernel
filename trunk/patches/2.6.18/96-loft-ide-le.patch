diff -urN linux-2.6.16.orig/drivers/ide/arm/avila-ide.c linux-2.6.16/drivers/ide/arm/avila-ide.c
--- linux-2.6.16.orig/drivers/ide/arm/avila-ide.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.16/drivers/ide/arm/avila-ide.c	2006-04-05 16:24:55.000000000 -0400
@@ -0,0 +1,170 @@
+/* drivers/ide/arm/avila-ide.c
+ *
+ * IDE/CF driver for the Gateworks Avila platform
+ *
+ * Copyright (c) 2005 Gateworks Corporation
+ * Dave G <daveg@unixstudios.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/slab.h>
+#include <linux/blkdev.h>
+#include <linux/errno.h>
+#include <linux/ide.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/delay.h>
+
+
+#define AVILA_IDE_BASE IXP4XX_EXP_BUS_BASE(1)
+#define AVILA_IDE_IRQ IRQ_IXP4XX_GPIO12
+#define AVILA_IDE_CONTROL 0x1e
+#define AVILA_IDE_INT 12
+#define AVILA_IDE_CS1_BITS 0xbfff0003;
+
+static unsigned char _mode;
+
+static void avila_ide_enable_16(void)
+{
+	if ( _mode == 0 ) {
+		*IXP4XX_EXP_CS1 &= ~(0x00000001);
+		udelay(100);
+		_mode = 1;
+	}
+
+}
+
+static void avila_ide_disable_16(void)
+{
+	if ( _mode == 1 ) {
+		udelay(100);
+		*IXP4XX_EXP_CS1 |= (0x00000001);
+		_mode = 0;
+	}
+
+}
+
+static u8 avila_ide_inb(unsigned long addr)
+{
+	u8 val;
+
+	val = readb(addr ^ 0x03);
+
+//	val = readb(addr);
+	//printk("%s: %x = %02x\n", __FUNCTION__, addr ^ 0x03, val);
+	return val;
+}
+
+static u16 avila_ide_inw(unsigned long addr)
+{
+	u16 val;
+
+	avila_ide_enable_16();
+	val = readw(addr ^ 0x02);
+	avila_ide_disable_16();
+
+	//printk("%s: %08x = %04x\n", __FUNCTION__, addr, val);
+
+	return val;
+}
+
+static void avila_ide_insw(unsigned long addr, void *buf, u32 len)
+{
+	u16 *buf16p;
+
+	//printk("%s: %02x, %x\n", __FUNCTION__, len, addr);
+
+	avila_ide_enable_16();
+	for (buf16p = (u16 *) buf; (len > 0); len--)
+		*buf16p++ = readw(addr ^ 0x02);
+	avila_ide_disable_16();
+
+}
+
+static void avila_ide_outb(u8 val, unsigned long addr)
+{
+	//printk("%s: %02x, %x\n", __FUNCTION__, val, addr ^ 0x03);
+	writeb(val, addr ^ 0x03);
+}
+
+static void avila_ide_outbsync(ide_drive_t *drive, u8 val, unsigned long addr)
+{
+	writeb(val, addr ^ 0x03);
+}
+
+static void avila_ide_outw(u16 val, unsigned long addr)
+{
+	//printk("%s: %04x, %x\n", __FUNCTION__, val, addr);
+
+	avila_ide_enable_16();
+	writew(val, addr ^ 0x02);
+	avila_ide_disable_16();
+}
+
+
+static void avila_ide_outsw(unsigned long addr, void *buf, u32 len)
+{
+	u16 *buf16p;
+	//printk("%s: len=%d, addr=%x\n", __FUNCTION__, len, addr);
+	avila_ide_enable_16();
+	for (buf16p = (u16 *) buf; (len > 0); len--)
+		writew(*buf16p++, addr ^ 0x02);
+	avila_ide_disable_16();
+
+}
+
+static int avila_ide_iack(ide_hwif_t *hwif)
+{
+  //gpio_line_isr_clear(AVILA_IDE_INT);
+  	return 1;
+}
+
+void __init avila_ide_init(void)
+{
+	hw_regs_t hw;
+	ide_hwif_t *hwif;
+	unsigned char *avila_ide_iobase;
+	int i;
+
+	gpio_line_config(AVILA_IDE_INT, IXP4XX_GPIO_IN | IXP4XX_GPIO_STYLE_ACTIVE_HIGH);
+	// gpio_line_isr_clear(AVILA_IDE_INT);
+
+	*IXP4XX_EXP_CS1 |= AVILA_IDE_CS1_BITS;
+	
+	avila_ide_iobase = ioremap(AVILA_IDE_BASE, 0x1000);
+
+	memset(&hw, 0, sizeof(hw));
+
+	hw.irq = AVILA_IDE_IRQ;
+	hw.dma = NO_DMA;
+	hw.ack_intr = avila_ide_iack;
+
+	for (i = 0; (i <= IDE_STATUS_OFFSET); i++)
+		hw.io_ports[i] = (unsigned long)(avila_ide_iobase + i);
+	
+	hw.io_ports[IDE_CONTROL_OFFSET] = (unsigned long)(avila_ide_iobase + AVILA_IDE_CONTROL);
+
+	printk("ide: Gateworks Avila IDE/CF driver v1.3\n");
+
+	ide_register_hw(&hw, &hwif);
+
+	hwif->mmio = 2;
+	hwif->OUTB = avila_ide_outb;
+	hwif->OUTBSYNC = avila_ide_outbsync;
+	hwif->OUTW = avila_ide_outw;
+	hwif->OUTSW = avila_ide_outsw;
+	hwif->INB = avila_ide_inb;
+	hwif->INW = avila_ide_inw;
+	hwif->INSW = avila_ide_insw;
+}
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Dave G <daveg@unixstudios.net>");
+MODULE_DESCRIPTION("Gateworks Avila CF/IDE Driver");
diff -urN linux-2.6.16.orig/drivers/ide/arm/Makefile linux-2.6.16/drivers/ide/arm/Makefile
--- linux-2.6.16.orig/drivers/ide/arm/Makefile	2006-03-20 00:53:29.000000000 -0500
+++ linux-2.6.16/drivers/ide/arm/Makefile	2006-04-05 16:24:26.000000000 -0400
@@ -1,5 +1,6 @@
 
 obj-$(CONFIG_BLK_DEV_IDE_ICSIDE)	+= icside.o
+obj-$(CONFIG_BLK_DEV_IDE_AVILA)	+= avila-ide.o
 obj-$(CONFIG_BLK_DEV_IDE_RAPIDE)	+= rapide.o
 obj-$(CONFIG_BLK_DEV_IDE_BAST)		+= bast-ide.o
 
diff -urN linux-2.6.16.orig/drivers/ide/ide.c linux-2.6.16/drivers/ide/ide.c
--- linux-2.6.16.orig/drivers/ide/ide.c	2006-03-20 00:53:29.000000000 -0500
+++ linux-2.6.16/drivers/ide/ide.c	2006-04-05 16:24:26.000000000 -0400
@@ -1822,6 +1822,12 @@
 		macide_init();
 	}
 #endif /* CONFIG_BLK_DEV_MAC_IDE */
+#ifdef CONFIG_BLK_DEV_IDE_AVILA
+  {
+    extern void avila_ide_init(void);
+    avila_ide_init();
+  }
+#endif /* CONFIG_BLK_DEV_IDE_AVILA */
 #ifdef CONFIG_BLK_DEV_Q40IDE
 	{
 		extern void q40ide_init(void);
diff -urN linux-2.6.16.orig/drivers/ide/ide.c.orig linux-2.6.16/drivers/ide/ide.c.orig
--- linux-2.6.16.orig/drivers/ide/ide.c.orig	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.16/drivers/ide/ide.c.orig	2006-03-20 00:53:29.000000000 -0500
@@ -0,0 +1,2088 @@
+/*
+ *  linux/drivers/ide/ide.c		Version 7.00beta2	Mar 05 2003
+ *
+ *  Copyright (C) 1994-1998  Linus Torvalds & authors (see below)
+ */
+
+/*
+ *  Mostly written by Mark Lord  <mlord@pobox.com>
+ *                and Gadi Oxman <gadio@netvision.net.il>
+ *                and Andre Hedrick <andre@linux-ide.org>
+ *
+ *  See linux/MAINTAINERS for address of current maintainer.
+ *
+ * This is the multiple IDE interface driver, as evolved from hd.c.
+ * It supports up to MAX_HWIFS IDE interfaces, on one or more IRQs
+ *   (usually 14 & 15).
+ * There can be up to two drives per interface, as per the ATA-2 spec.
+ *
+ * Primary:    ide0, port 0x1f0; major=3;  hda is minor=0; hdb is minor=64
+ * Secondary:  ide1, port 0x170; major=22; hdc is minor=0; hdd is minor=64
+ * Tertiary:   ide2, port 0x???; major=33; hde is minor=0; hdf is minor=64
+ * Quaternary: ide3, port 0x???; major=34; hdg is minor=0; hdh is minor=64
+ * ...
+ *
+ *  From hd.c:
+ *  |
+ *  | It traverses the request-list, using interrupts to jump between functions.
+ *  | As nearly all functions can be called within interrupts, we may not sleep.
+ *  | Special care is recommended.  Have Fun!
+ *  |
+ *  | modified by Drew Eckhardt to check nr of hd's from the CMOS.
+ *  |
+ *  | Thanks to Branko Lankester, lankeste@fwi.uva.nl, who found a bug
+ *  | in the early extended-partition checks and added DM partitions.
+ *  |
+ *  | Early work on error handling by Mika Liljeberg (liljeber@cs.Helsinki.FI).
+ *  |
+ *  | IRQ-unmask, drive-id, multiple-mode, support for ">16 heads",
+ *  | and general streamlining by Mark Lord (mlord@pobox.com).
+ *
+ *  October, 1994 -- Complete line-by-line overhaul for linux 1.1.x, by:
+ *
+ *	Mark Lord	(mlord@pobox.com)		(IDE Perf.Pkg)
+ *	Delman Lee	(delman@ieee.org)		("Mr. atdisk2")
+ *	Scott Snyder	(snyder@fnald0.fnal.gov)	(ATAPI IDE cd-rom)
+ *
+ *  This was a rewrite of just about everything from hd.c, though some original
+ *  code is still sprinkled about.  Think of it as a major evolution, with
+ *  inspiration from lots of linux users, esp.  hamish@zot.apana.org.au
+ *
+ *  Version 1.0 ALPHA	initial code, primary i/f working okay
+ *  Version 1.3 BETA	dual i/f on shared irq tested & working!
+ *  Version 1.4 BETA	added auto probing for irq(s)
+ *  Version 1.5 BETA	added ALPHA (untested) support for IDE cd-roms,
+ *  ...
+ * Version 5.50		allow values as small as 20 for idebus=
+ * Version 5.51		force non io_32bit in drive_cmd_intr()
+ *			change delay_10ms() to delay_50ms() to fix problems
+ * Version 5.52		fix incorrect invalidation of removable devices
+ *			add "hdx=slow" command line option
+ * Version 5.60		start to modularize the driver; the disk and ATAPI
+ *			 drivers can be compiled as loadable modules.
+ *			move IDE probe code to ide-probe.c
+ *			move IDE disk code to ide-disk.c
+ *			add support for generic IDE device subdrivers
+ *			add m68k code from Geert Uytterhoeven
+ *			probe all interfaces by default
+ *			add ioctl to (re)probe an interface
+ * Version 6.00		use per device request queues
+ *			attempt to optimize shared hwgroup performance
+ *			add ioctl to manually adjust bandwidth algorithms
+ *			add kerneld support for the probe module
+ *			fix bug in ide_error()
+ *			fix bug in the first ide_get_lock() call for Atari
+ *			don't flush leftover data for ATAPI devices
+ * Version 6.01		clear hwgroup->active while the hwgroup sleeps
+ *			support HDIO_GETGEO for floppies
+ * Version 6.02		fix ide_ack_intr() call
+ *			check partition table on floppies
+ * Version 6.03		handle bad status bit sequencing in ide_wait_stat()
+ * Version 6.10		deleted old entries from this list of updates
+ *			replaced triton.c with ide-dma.c generic PCI DMA
+ *			added support for BIOS-enabled UltraDMA
+ *			rename all "promise" things to "pdc4030"
+ *			fix EZ-DRIVE handling on small disks
+ * Version 6.11		fix probe error in ide_scan_devices()
+ *			fix ancient "jiffies" polling bugs
+ *			mask all hwgroup interrupts on each irq entry
+ * Version 6.12		integrate ioctl and proc interfaces
+ *			fix parsing of "idex=" command line parameter
+ * Version 6.13		add support for ide4/ide5 courtesy rjones@orchestream.com
+ * Version 6.14		fixed IRQ sharing among PCI devices
+ * Version 6.15		added SMP awareness to IDE drivers
+ * Version 6.16		fixed various bugs; even more SMP friendly
+ * Version 6.17		fix for newest EZ-Drive problem
+ * Version 6.18		default unpartitioned-disk translation now "BIOS LBA"
+ * Version 6.19		Re-design for a UNIFORM driver for all platforms,
+ *			  model based on suggestions from Russell King and
+ *			  Geert Uytterhoeven
+ *			Promise DC4030VL now supported.
+ *			add support for ide6/ide7
+ *			delay_50ms() changed to ide_delay_50ms() and exported.
+ * Version 6.20		Added/Fixed Generic ATA-66 support and hwif detection.
+ *			Added hdx=flash to allow for second flash disk
+ *			  detection w/o the hang loop.
+ *			Added support for ide8/ide9
+ *			Added idex=ata66 for the quirky chipsets that are
+ *			  ATA-66 compliant, but have yet to determine a method
+ *			  of verification of the 80c cable presence.
+ *			  Specifically Promise's PDC20262 chipset.
+ * Version 6.21		Fixing/Fixed SMP spinlock issue with insight from an old
+ *			  hat that clarified original low level driver design.
+ * Version 6.30		Added SMP support; fixed multmode issues.  -ml
+ * Version 6.31		Debug Share INTR's and request queue streaming
+ *			Native ATA-100 support
+ *			Prep for Cascades Project
+ * Version 7.00alpha	First named revision of ide rearrange
+ *
+ *  Some additional driver compile-time options are in ./include/linux/ide.h
+ *
+ *  To do, in likely order of completion:
+ *	- modify kernel to obtain BIOS geometry for drives on 2nd/3rd/4th i/f
+ *
+ */
+
+#define	REVISION	"Revision: 7.00alpha2"
+#define	VERSION		"Id: ide.c 7.00a2 20020906"
+
+#undef REALLY_SLOW_IO		/* most systems can safely undef this */
+
+#define _IDE_C			/* Tell ide.h it's really us */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/timer.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/major.h>
+#include <linux/errno.h>
+#include <linux/genhd.h>
+#include <linux/blkpg.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/ide.h>
+#include <linux/devfs_fs_kernel.h>
+#include <linux/completion.h>
+#include <linux/reboot.h>
+#include <linux/cdrom.h>
+#include <linux/seq_file.h>
+#include <linux/device.h>
+#include <linux/bitops.h>
+
+#include <asm/byteorder.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+
+/* default maximum number of failures */
+#define IDE_DEFAULT_MAX_FAILURES 	1
+
+static const u8 ide_hwif_to_major[] = { IDE0_MAJOR, IDE1_MAJOR,
+					IDE2_MAJOR, IDE3_MAJOR,
+					IDE4_MAJOR, IDE5_MAJOR,
+					IDE6_MAJOR, IDE7_MAJOR,
+					IDE8_MAJOR, IDE9_MAJOR };
+
+static int idebus_parameter;	/* holds the "idebus=" parameter */
+static int system_bus_speed;	/* holds what we think is VESA/PCI bus speed */
+static int initializing;	/* set while initializing built-in drivers */
+
+DECLARE_MUTEX(ide_cfg_sem);
+ __cacheline_aligned_in_smp DEFINE_SPINLOCK(ide_lock);
+
+#ifdef CONFIG_BLK_DEV_IDEPCI
+static int ide_scan_direction; /* THIS was formerly 2.2.x pci=reverse */
+#endif
+
+#ifdef CONFIG_IDEDMA_AUTO
+int noautodma = 0;
+#else
+int noautodma = 1;
+#endif
+
+EXPORT_SYMBOL(noautodma);
+
+/*
+ * This is declared extern in ide.h, for access by other IDE modules:
+ */
+ide_hwif_t ide_hwifs[MAX_HWIFS];	/* master data repository */
+
+EXPORT_SYMBOL(ide_hwifs);
+
+/*
+ * Do not even *think* about calling this!
+ */
+static void init_hwif_data(ide_hwif_t *hwif, unsigned int index)
+{
+	unsigned int unit;
+
+	/* bulk initialize hwif & drive info with zeros */
+	memset(hwif, 0, sizeof(ide_hwif_t));
+
+	/* fill in any non-zero initial values */
+	hwif->index	= index;
+	hwif->major	= ide_hwif_to_major[index];
+
+	hwif->name[0]	= 'i';
+	hwif->name[1]	= 'd';
+	hwif->name[2]	= 'e';
+	hwif->name[3]	= '0' + index;
+
+	hwif->bus_state	= BUSSTATE_ON;
+
+	hwif->atapi_dma = 0;		/* disable all atapi dma */ 
+	hwif->ultra_mask = 0x80;	/* disable all ultra */
+	hwif->mwdma_mask = 0x80;	/* disable all mwdma */
+	hwif->swdma_mask = 0x80;	/* disable all swdma */
+
+	init_completion(&hwif->gendev_rel_comp);
+
+	default_hwif_iops(hwif);
+	default_hwif_transport(hwif);
+	for (unit = 0; unit < MAX_DRIVES; ++unit) {
+		ide_drive_t *drive = &hwif->drives[unit];
+
+		drive->media			= ide_disk;
+		drive->select.all		= (unit<<4)|0xa0;
+		drive->hwif			= hwif;
+		drive->ctl			= 0x08;
+		drive->ready_stat		= READY_STAT;
+		drive->bad_wstat		= BAD_W_STAT;
+		drive->special.b.recalibrate	= 1;
+		drive->special.b.set_geometry	= 1;
+		drive->name[0]			= 'h';
+		drive->name[1]			= 'd';
+		drive->name[2]			= 'a' + (index * MAX_DRIVES) + unit;
+		drive->max_failures		= IDE_DEFAULT_MAX_FAILURES;
+		drive->using_dma		= 0;
+		drive->vdma			= 0;
+		INIT_LIST_HEAD(&drive->list);
+		init_completion(&drive->gendev_rel_comp);
+	}
+}
+
+static void init_hwif_default(ide_hwif_t *hwif, unsigned int index)
+{
+	hw_regs_t hw;
+
+	memset(&hw, 0, sizeof(hw_regs_t));
+
+	ide_init_hwif_ports(&hw, ide_default_io_base(index), 0, &hwif->irq);
+
+	memcpy(&hwif->hw, &hw, sizeof(hw));
+	memcpy(hwif->io_ports, hw.io_ports, sizeof(hw.io_ports));
+
+	hwif->noprobe = !hwif->io_ports[IDE_DATA_OFFSET];
+#ifdef CONFIG_BLK_DEV_HD
+	if (hwif->io_ports[IDE_DATA_OFFSET] == HD_DATA)
+		hwif->noprobe = 1;	/* may be overridden by ide_setup() */
+#endif
+}
+
+extern void ide_arm_init(void);
+
+/*
+ * init_ide_data() sets reasonable default values into all fields
+ * of all instances of the hwifs and drives, but only on the first call.
+ * Subsequent calls have no effect (they don't wipe out anything).
+ *
+ * This routine is normally called at driver initialization time,
+ * but may also be called MUCH earlier during kernel "command-line"
+ * parameter processing.  As such, we cannot depend on any other parts
+ * of the kernel (such as memory allocation) to be functioning yet.
+ *
+ * This is too bad, as otherwise we could dynamically allocate the
+ * ide_drive_t structs as needed, rather than always consuming memory
+ * for the max possible number (MAX_HWIFS * MAX_DRIVES) of them.
+ *
+ * FIXME: We should stuff the setup data into __init and copy the
+ * relevant hwifs/allocate them properly during boot.
+ */
+#define MAGIC_COOKIE 0x12345678
+static void __init init_ide_data (void)
+{
+	ide_hwif_t *hwif;
+	unsigned int index;
+	static unsigned long magic_cookie = MAGIC_COOKIE;
+
+	if (magic_cookie != MAGIC_COOKIE)
+		return;		/* already initialized */
+	magic_cookie = 0;
+
+	/* Initialise all interface structures */
+	for (index = 0; index < MAX_HWIFS; ++index) {
+		hwif = &ide_hwifs[index];
+		init_hwif_data(hwif, index);
+		init_hwif_default(hwif, index);
+#if !defined(CONFIG_PPC32) || !defined(CONFIG_PCI)
+		hwif->irq = hwif->hw.irq =
+			ide_init_default_irq(hwif->io_ports[IDE_DATA_OFFSET]);
+#endif
+	}
+#ifdef CONFIG_IDE_ARM
+	initializing = 1;
+	ide_arm_init();
+	initializing = 0;
+#endif
+}
+
+/**
+ *	ide_system_bus_speed	-	guess bus speed
+ *
+ *	ide_system_bus_speed() returns what we think is the system VESA/PCI
+ *	bus speed (in MHz). This is used for calculating interface PIO timings.
+ *	The default is 40 for known PCI systems, 50 otherwise.
+ *	The "idebus=xx" parameter can be used to override this value.
+ *	The actual value to be used is computed/displayed the first time
+ *	through. Drivers should only use this as a last resort.
+ *
+ *	Returns a guessed speed in MHz.
+ */
+
+static int ide_system_bus_speed(void)
+{
+#ifdef CONFIG_PCI
+	static struct pci_device_id pci_default[] = {
+		{ PCI_DEVICE(PCI_ANY_ID, PCI_ANY_ID) },
+		{ }
+	};
+#else
+#define pci_default 0
+#endif /* CONFIG_PCI */
+
+	if (!system_bus_speed) {
+		if (idebus_parameter) {
+			/* user supplied value */
+			system_bus_speed = idebus_parameter;
+		} else if (pci_dev_present(pci_default)) {
+			/* safe default value for PCI */
+			system_bus_speed = 33;
+		} else {
+			/* safe default value for VESA and PCI */
+			system_bus_speed = 50;
+		}
+		printk(KERN_INFO "ide: Assuming %dMHz system bus speed "
+			"for PIO modes%s\n", system_bus_speed,
+			idebus_parameter ? "" : "; override with idebus=xx");
+	}
+	return system_bus_speed;
+}
+
+#ifdef CONFIG_PROC_FS
+struct proc_dir_entry *proc_ide_root;
+#endif
+
+static struct resource* hwif_request_region(ide_hwif_t *hwif,
+					    unsigned long addr, int num)
+{
+	struct resource *res = request_region(addr, num, hwif->name);
+
+	if (!res)
+		printk(KERN_ERR "%s: I/O resource 0x%lX-0x%lX not free.\n",
+				hwif->name, addr, addr+num-1);
+	return res;
+}
+
+/**
+ *	ide_hwif_request_regions - request resources for IDE
+ *	@hwif: interface to use
+ *
+ *	Requests all the needed resources for an interface.
+ *	Right now core IDE code does this work which is deeply wrong.
+ *	MMIO leaves it to the controller driver,
+ *	PIO will migrate this way over time.
+ */
+
+int ide_hwif_request_regions(ide_hwif_t *hwif)
+{
+	unsigned long addr;
+	unsigned int i;
+
+	if (hwif->mmio == 2)
+		return 0;
+	BUG_ON(hwif->mmio == 1);
+	addr = hwif->io_ports[IDE_CONTROL_OFFSET];
+	if (addr && !hwif_request_region(hwif, addr, 1))
+		goto control_region_busy;
+	hwif->straight8 = 0;
+	addr = hwif->io_ports[IDE_DATA_OFFSET];
+	if ((addr | 7) == hwif->io_ports[IDE_STATUS_OFFSET]) {
+		if (!hwif_request_region(hwif, addr, 8))
+			goto data_region_busy;
+		hwif->straight8 = 1;
+		return 0;
+	}
+	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
+		addr = hwif->io_ports[i];
+		if (!hwif_request_region(hwif, addr, 1)) {
+			while (--i)
+				release_region(addr, 1);
+			goto data_region_busy;
+		}
+	}
+	return 0;
+
+data_region_busy:
+	addr = hwif->io_ports[IDE_CONTROL_OFFSET];
+	if (addr)
+		release_region(addr, 1);
+control_region_busy:
+	/* If any errors are return, we drop the hwif interface. */
+	return -EBUSY;
+}
+
+/**
+ *	ide_hwif_release_regions - free IDE resources
+ *
+ *	Note that we only release the standard ports,
+ *	and do not even try to handle any extra ports
+ *	allocated for weird IDE interface chipsets.
+ *
+ *	Note also that we don't yet handle mmio resources here. More
+ *	importantly our caller should be doing this so we need to 
+ *	restructure this as a helper function for drivers.
+ */
+
+void ide_hwif_release_regions(ide_hwif_t *hwif)
+{
+	u32 i = 0;
+
+	if (hwif->mmio == 2)
+		return;
+	if (hwif->io_ports[IDE_CONTROL_OFFSET])
+		release_region(hwif->io_ports[IDE_CONTROL_OFFSET], 1);
+	if (hwif->straight8) {
+		release_region(hwif->io_ports[IDE_DATA_OFFSET], 8);
+		return;
+	}
+	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++)
+		if (hwif->io_ports[i])
+			release_region(hwif->io_ports[i], 1);
+}
+
+/**
+ *	ide_hwif_restore	-	restore hwif to template
+ *	@hwif: hwif to update
+ *	@tmp_hwif: template
+ *
+ *	Restore hwif to a previous state by copying most settngs
+ *	from the template.
+ */
+
+static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
+{
+	hwif->hwgroup			= tmp_hwif->hwgroup;
+
+	hwif->gendev.parent		= tmp_hwif->gendev.parent;
+
+	hwif->proc			= tmp_hwif->proc;
+
+	hwif->major			= tmp_hwif->major;
+	hwif->straight8			= tmp_hwif->straight8;
+	hwif->bus_state			= tmp_hwif->bus_state;
+
+	hwif->atapi_dma			= tmp_hwif->atapi_dma;
+	hwif->ultra_mask		= tmp_hwif->ultra_mask;
+	hwif->mwdma_mask		= tmp_hwif->mwdma_mask;
+	hwif->swdma_mask		= tmp_hwif->swdma_mask;
+
+	hwif->chipset			= tmp_hwif->chipset;
+	hwif->hold			= tmp_hwif->hold;
+
+#ifdef CONFIG_BLK_DEV_IDEPCI
+	hwif->pci_dev			= tmp_hwif->pci_dev;
+	hwif->cds			= tmp_hwif->cds;
+#endif
+
+	hwif->tuneproc			= tmp_hwif->tuneproc;
+	hwif->speedproc			= tmp_hwif->speedproc;
+	hwif->selectproc		= tmp_hwif->selectproc;
+	hwif->reset_poll		= tmp_hwif->reset_poll;
+	hwif->pre_reset			= tmp_hwif->pre_reset;
+	hwif->resetproc			= tmp_hwif->resetproc;
+	hwif->intrproc			= tmp_hwif->intrproc;
+	hwif->maskproc			= tmp_hwif->maskproc;
+	hwif->quirkproc			= tmp_hwif->quirkproc;
+	hwif->busproc			= tmp_hwif->busproc;
+
+	hwif->ata_input_data		= tmp_hwif->ata_input_data;
+	hwif->ata_output_data		= tmp_hwif->ata_output_data;
+	hwif->atapi_input_bytes		= tmp_hwif->atapi_input_bytes;
+	hwif->atapi_output_bytes	= tmp_hwif->atapi_output_bytes;
+
+	hwif->dma_setup			= tmp_hwif->dma_setup;
+	hwif->dma_exec_cmd		= tmp_hwif->dma_exec_cmd;
+	hwif->dma_start			= tmp_hwif->dma_start;
+	hwif->ide_dma_end		= tmp_hwif->ide_dma_end;
+	hwif->ide_dma_check		= tmp_hwif->ide_dma_check;
+	hwif->ide_dma_on		= tmp_hwif->ide_dma_on;
+	hwif->ide_dma_off_quietly	= tmp_hwif->ide_dma_off_quietly;
+	hwif->ide_dma_test_irq		= tmp_hwif->ide_dma_test_irq;
+	hwif->ide_dma_host_on		= tmp_hwif->ide_dma_host_on;
+	hwif->ide_dma_host_off		= tmp_hwif->ide_dma_host_off;
+	hwif->ide_dma_lostirq		= tmp_hwif->ide_dma_lostirq;
+	hwif->ide_dma_timeout		= tmp_hwif->ide_dma_timeout;
+
+	hwif->OUTB			= tmp_hwif->OUTB;
+	hwif->OUTBSYNC			= tmp_hwif->OUTBSYNC;
+	hwif->OUTW			= tmp_hwif->OUTW;
+	hwif->OUTL			= tmp_hwif->OUTL;
+	hwif->OUTSW			= tmp_hwif->OUTSW;
+	hwif->OUTSL			= tmp_hwif->OUTSL;
+
+	hwif->INB			= tmp_hwif->INB;
+	hwif->INW			= tmp_hwif->INW;
+	hwif->INL			= tmp_hwif->INL;
+	hwif->INSW			= tmp_hwif->INSW;
+	hwif->INSL			= tmp_hwif->INSL;
+
+	hwif->sg_max_nents		= tmp_hwif->sg_max_nents;
+
+	hwif->mmio			= tmp_hwif->mmio;
+	hwif->rqsize			= tmp_hwif->rqsize;
+	hwif->no_lba48			= tmp_hwif->no_lba48;
+
+#ifndef CONFIG_BLK_DEV_IDECS
+	hwif->irq			= tmp_hwif->irq;
+#endif
+
+	hwif->dma_base			= tmp_hwif->dma_base;
+	hwif->dma_master		= tmp_hwif->dma_master;
+	hwif->dma_command		= tmp_hwif->dma_command;
+	hwif->dma_vendor1		= tmp_hwif->dma_vendor1;
+	hwif->dma_status		= tmp_hwif->dma_status;
+	hwif->dma_vendor3		= tmp_hwif->dma_vendor3;
+	hwif->dma_prdtable		= tmp_hwif->dma_prdtable;
+
+	hwif->dma_extra			= tmp_hwif->dma_extra;
+	hwif->config_data		= tmp_hwif->config_data;
+	hwif->select_data		= tmp_hwif->select_data;
+	hwif->autodma			= tmp_hwif->autodma;
+	hwif->udma_four			= tmp_hwif->udma_four;
+	hwif->no_dsc			= tmp_hwif->no_dsc;
+
+	hwif->hwif_data			= tmp_hwif->hwif_data;
+}
+
+/**
+ *	ide_unregister		-	free an ide interface
+ *	@index: index of interface (will change soon to a pointer)
+ *
+ *	Perform the final unregister of an IDE interface. At the moment
+ *	we don't refcount interfaces so this will also get split up.
+ *
+ *	Locking:
+ *	The caller must not hold the IDE locks
+ *	The drive present/vanishing is not yet properly locked
+ *	Take care with the callbacks. These have been split to avoid
+ *	deadlocking the IDE layer. The shutdown callback is called
+ *	before we take the lock and free resources. It is up to the
+ *	caller to be sure there is no pending I/O here, and that
+ *	the interfce will not be reopened (present/vanishing locking
+ *	isnt yet done btw). After we commit to the final kill we
+ *	call the cleanup callback with the ide locks held.
+ *
+ *	Unregister restores the hwif structures to the default state.
+ *	This is raving bonkers.
+ */
+
+void ide_unregister(unsigned int index)
+{
+	ide_drive_t *drive;
+	ide_hwif_t *hwif, *g;
+	static ide_hwif_t tmp_hwif; /* protected by ide_cfg_sem */
+	ide_hwgroup_t *hwgroup;
+	int irq_count = 0, unit;
+
+	BUG_ON(index >= MAX_HWIFS);
+
+	BUG_ON(in_interrupt());
+	BUG_ON(irqs_disabled());
+	down(&ide_cfg_sem);
+	spin_lock_irq(&ide_lock);
+	hwif = &ide_hwifs[index];
+	if (!hwif->present)
+		goto abort;
+	for (unit = 0; unit < MAX_DRIVES; ++unit) {
+		drive = &hwif->drives[unit];
+		if (!drive->present) {
+			if (drive->devfs_name[0] != '\0') {
+				devfs_remove(drive->devfs_name);
+				drive->devfs_name[0] = '\0';
+			}
+			continue;
+		}
+		spin_unlock_irq(&ide_lock);
+		device_unregister(&drive->gendev);
+		wait_for_completion(&drive->gendev_rel_comp);
+		spin_lock_irq(&ide_lock);
+	}
+	hwif->present = 0;
+
+	spin_unlock_irq(&ide_lock);
+
+	destroy_proc_ide_interface(hwif);
+
+	hwgroup = hwif->hwgroup;
+	/*
+	 * free the irq if we were the only hwif using it
+	 */
+	g = hwgroup->hwif;
+	do {
+		if (g->irq == hwif->irq)
+			++irq_count;
+		g = g->next;
+	} while (g != hwgroup->hwif);
+	if (irq_count == 1)
+		free_irq(hwif->irq, hwgroup);
+
+	spin_lock_irq(&ide_lock);
+	/*
+	 * Note that we only release the standard ports,
+	 * and do not even try to handle any extra ports
+	 * allocated for weird IDE interface chipsets.
+	 */
+	ide_hwif_release_regions(hwif);
+
+	/*
+	 * Remove us from the hwgroup, and free
+	 * the hwgroup if we were the only member
+	 */
+	if (hwif->next == hwif) {
+		BUG_ON(hwgroup->hwif != hwif);
+		kfree(hwgroup);
+	} else {
+		/* There is another interface in hwgroup.
+		 * Unlink us, and set hwgroup->drive and ->hwif to
+		 * something sane.
+		 */
+		g = hwgroup->hwif;
+		while (g->next != hwif)
+			g = g->next;
+		g->next = hwif->next;
+		if (hwgroup->hwif == hwif) {
+			/* Chose a random hwif for hwgroup->hwif.
+			 * It's guaranteed that there are no drives
+			 * left in the hwgroup.
+			 */
+			BUG_ON(hwgroup->drive != NULL);
+			hwgroup->hwif = g;
+		}
+		BUG_ON(hwgroup->hwif == hwif);
+	}
+
+	/* More messed up locking ... */
+	spin_unlock_irq(&ide_lock);
+	device_unregister(&hwif->gendev);
+	wait_for_completion(&hwif->gendev_rel_comp);
+
+	/*
+	 * Remove us from the kernel's knowledge
+	 */
+	blk_unregister_region(MKDEV(hwif->major, 0), MAX_DRIVES<<PARTN_BITS);
+	kfree(hwif->sg_table);
+	unregister_blkdev(hwif->major, hwif->name);
+	spin_lock_irq(&ide_lock);
+
+	if (hwif->dma_base) {
+		(void) ide_release_dma(hwif);
+
+		hwif->dma_base = 0;
+		hwif->dma_master = 0;
+		hwif->dma_command = 0;
+		hwif->dma_vendor1 = 0;
+		hwif->dma_status = 0;
+		hwif->dma_vendor3 = 0;
+		hwif->dma_prdtable = 0;
+	}
+
+	/* copy original settings */
+	tmp_hwif = *hwif;
+
+	/* restore hwif data to pristine status */
+	init_hwif_data(hwif, index);
+	init_hwif_default(hwif, index);
+
+	ide_hwif_restore(hwif, &tmp_hwif);
+
+abort:
+	spin_unlock_irq(&ide_lock);
+	up(&ide_cfg_sem);
+}
+
+EXPORT_SYMBOL(ide_unregister);
+
+
+/**
+ *	ide_setup_ports 	-	set up IDE interface ports
+ *	@hw: register descriptions
+ *	@base: base register
+ *	@offsets: table of register offsets
+ *	@ctrl: control register
+ *	@ack_irq: IRQ ack
+ *	@irq: interrupt lie
+ *
+ *	Setup hw_regs_t structure described by parameters.  You
+ *	may set up the hw structure yourself OR use this routine to
+ *	do it for you. This is basically a helper
+ *
+ */
+ 
+void ide_setup_ports (	hw_regs_t *hw,
+			unsigned long base, int *offsets,
+			unsigned long ctrl, unsigned long intr,
+			ide_ack_intr_t *ack_intr,
+/*
+ *			ide_io_ops_t *iops,
+ */
+			int irq)
+{
+	int i;
+
+	for (i = 0; i < IDE_NR_PORTS; i++) {
+		if (offsets[i] == -1) {
+			switch(i) {
+				case IDE_CONTROL_OFFSET:
+					hw->io_ports[i] = ctrl;
+					break;
+#if defined(CONFIG_AMIGA) || defined(CONFIG_MAC)
+				case IDE_IRQ_OFFSET:
+					hw->io_ports[i] = intr;
+					break;
+#endif /* (CONFIG_AMIGA) || (CONFIG_MAC) */
+				default:
+					hw->io_ports[i] = 0;
+					break;
+			}
+		} else {
+			hw->io_ports[i] = base + offsets[i];
+		}
+	}
+	hw->irq = irq;
+	hw->dma = NO_DMA;
+	hw->ack_intr = ack_intr;
+/*
+ *	hw->iops = iops;
+ */
+}
+
+/**
+ *	ide_register_hw_with_fixup	-	register IDE interface
+ *	@hw: hardware registers
+ *	@hwifp: pointer to returned hwif
+ *	@fixup: fixup function
+ *
+ *	Register an IDE interface, specifying exactly the registers etc.
+ *	Set init=1 iff calling before probes have taken place.
+ *
+ *	Returns -1 on error.
+ */
+
+int ide_register_hw_with_fixup(hw_regs_t *hw, ide_hwif_t **hwifp, void(*fixup)(ide_hwif_t *hwif))
+{
+	int index, retry = 1;
+	ide_hwif_t *hwif;
+
+	do {
+		for (index = 0; index < MAX_HWIFS; ++index) {
+			hwif = &ide_hwifs[index];
+			if (hwif->hw.io_ports[IDE_DATA_OFFSET] == hw->io_ports[IDE_DATA_OFFSET])
+				goto found;
+		}
+		for (index = 0; index < MAX_HWIFS; ++index) {
+			hwif = &ide_hwifs[index];
+			if (hwif->hold)
+				continue;
+			if ((!hwif->present && !hwif->mate && !initializing) ||
+			    (!hwif->hw.io_ports[IDE_DATA_OFFSET] && initializing))
+				goto found;
+		}
+		for (index = 0; index < MAX_HWIFS; index++)
+			ide_unregister(index);
+	} while (retry--);
+	return -1;
+found:
+	if (hwif->present)
+		ide_unregister(index);
+	else if (!hwif->hold) {
+		init_hwif_data(hwif, index);
+		init_hwif_default(hwif, index);
+	}
+	if (hwif->present)
+		return -1;
+	memcpy(&hwif->hw, hw, sizeof(*hw));
+	memcpy(hwif->io_ports, hwif->hw.io_ports, sizeof(hwif->hw.io_ports));
+	hwif->irq = hw->irq;
+	hwif->noprobe = 0;
+	hwif->chipset = hw->chipset;
+	hwif->gendev.parent = hw->dev;
+
+	if (!initializing) {
+		probe_hwif_init_with_fixup(hwif, fixup);
+		create_proc_ide_interfaces();
+	}
+
+	if (hwifp)
+		*hwifp = hwif;
+
+	return (initializing || hwif->present) ? index : -1;
+}
+
+EXPORT_SYMBOL(ide_register_hw_with_fixup);
+
+int ide_register_hw(hw_regs_t *hw, ide_hwif_t **hwifp)
+{
+	return ide_register_hw_with_fixup(hw, hwifp, NULL);
+}
+
+EXPORT_SYMBOL(ide_register_hw);
+
+/*
+ *	Locks for IDE setting functionality
+ */
+
+DECLARE_MUTEX(ide_setting_sem);
+
+/**
+ *	__ide_add_setting	-	add an ide setting option
+ *	@drive: drive to use
+ *	@name: setting name
+ *	@rw: true if the function is read write
+ *	@read_ioctl: function to call on read
+ *	@write_ioctl: function to call on write
+ *	@data_type: type of data
+ *	@min: range minimum
+ *	@max: range maximum
+ *	@mul_factor: multiplication scale
+ *	@div_factor: divison scale
+ *	@data: private data field
+ *	@set: setting
+ *	@auto_remove: setting auto removal flag
+ *
+ *	Removes the setting named from the device if it is present.
+ *	The function takes the settings_lock to protect against 
+ *	parallel changes. This function must not be called from IRQ
+ *	context. Returns 0 on success or -1 on failure.
+ *
+ *	BUGS: This code is seriously over-engineered. There is also
+ *	magic about how the driver specific features are setup. If
+ *	a driver is attached we assume the driver settings are auto
+ *	remove.
+ */
+
+static int __ide_add_setting(ide_drive_t *drive, const char *name, int rw, int read_ioctl, int write_ioctl, int data_type, int min, int max, int mul_factor, int div_factor, void *data, ide_procset_t *set, int auto_remove)
+{
+	ide_settings_t **p = (ide_settings_t **) &drive->settings, *setting = NULL;
+
+	down(&ide_setting_sem);
+	while ((*p) && strcmp((*p)->name, name) < 0)
+		p = &((*p)->next);
+	if ((setting = kzalloc(sizeof(*setting), GFP_KERNEL)) == NULL)
+		goto abort;
+	if ((setting->name = kmalloc(strlen(name) + 1, GFP_KERNEL)) == NULL)
+		goto abort;
+	strcpy(setting->name, name);
+	setting->rw = rw;
+	setting->read_ioctl = read_ioctl;
+	setting->write_ioctl = write_ioctl;
+	setting->data_type = data_type;
+	setting->min = min;
+	setting->max = max;
+	setting->mul_factor = mul_factor;
+	setting->div_factor = div_factor;
+	setting->data = data;
+	setting->set = set;
+	
+	setting->next = *p;
+	if (auto_remove)
+		setting->auto_remove = 1;
+	*p = setting;
+	up(&ide_setting_sem);
+	return 0;
+abort:
+	up(&ide_setting_sem);
+	kfree(setting);
+	return -1;
+}
+
+int ide_add_setting(ide_drive_t *drive, const char *name, int rw, int read_ioctl, int write_ioctl, int data_type, int min, int max, int mul_factor, int div_factor, void *data, ide_procset_t *set)
+{
+	return __ide_add_setting(drive, name, rw, read_ioctl, write_ioctl, data_type, min, max, mul_factor, div_factor, data, set, 1);
+}
+
+EXPORT_SYMBOL(ide_add_setting);
+
+/**
+ *	__ide_remove_setting	-	remove an ide setting option
+ *	@drive: drive to use
+ *	@name: setting name
+ *
+ *	Removes the setting named from the device if it is present.
+ *	The caller must hold the setting semaphore.
+ */
+ 
+static void __ide_remove_setting (ide_drive_t *drive, char *name)
+{
+	ide_settings_t **p, *setting;
+
+	p = (ide_settings_t **) &drive->settings;
+
+	while ((*p) && strcmp((*p)->name, name))
+		p = &((*p)->next);
+	if ((setting = (*p)) == NULL)
+		return;
+
+	(*p) = setting->next;
+	
+	kfree(setting->name);
+	kfree(setting);
+}
+
+/**
+ *	ide_find_setting_by_ioctl	-	find a drive specific ioctl
+ *	@drive: drive to scan
+ *	@cmd: ioctl command to handle
+ *
+ *	Scan's the device setting table for a matching entry and returns
+ *	this or NULL if no entry is found. The caller must hold the
+ *	setting semaphore
+ */
+ 
+static ide_settings_t *ide_find_setting_by_ioctl (ide_drive_t *drive, int cmd)
+{
+	ide_settings_t *setting = drive->settings;
+
+	while (setting) {
+		if (setting->read_ioctl == cmd || setting->write_ioctl == cmd)
+			break;
+		setting = setting->next;
+	}
+	
+	return setting;
+}
+
+/**
+ *	ide_find_setting_by_name	-	find a drive specific setting
+ *	@drive: drive to scan
+ *	@name: setting name
+ *
+ *	Scan's the device setting table for a matching entry and returns
+ *	this or NULL if no entry is found. The caller must hold the
+ *	setting semaphore
+ */
+ 
+ide_settings_t *ide_find_setting_by_name (ide_drive_t *drive, char *name)
+{
+	ide_settings_t *setting = drive->settings;
+
+	while (setting) {
+		if (strcmp(setting->name, name) == 0)
+			break;
+		setting = setting->next;
+	}
+	return setting;
+}
+
+/**
+ *	auto_remove_settings	-	remove driver specific settings
+ *	@drive: drive
+ *
+ *	Automatically remove all the driver specific settings for this
+ *	drive. This function may sleep and must not be called from IRQ
+ *	context. The caller must hold ide_setting_sem.
+ */
+ 
+static void auto_remove_settings (ide_drive_t *drive)
+{
+	ide_settings_t *setting;
+repeat:
+	setting = drive->settings;
+	while (setting) {
+		if (setting->auto_remove) {
+			__ide_remove_setting(drive, setting->name);
+			goto repeat;
+		}
+		setting = setting->next;
+	}
+}
+
+/**
+ *	ide_read_setting	-	read an IDE setting
+ *	@drive: drive to read from
+ *	@setting: drive setting
+ *
+ *	Read a drive setting and return the value. The caller
+ *	must hold the ide_setting_sem when making this call.
+ *
+ *	BUGS: the data return and error are the same return value
+ *	so an error -EINVAL and true return of the same value cannot
+ *	be told apart
+ */
+ 
+int ide_read_setting (ide_drive_t *drive, ide_settings_t *setting)
+{
+	int		val = -EINVAL;
+	unsigned long	flags;
+
+	if ((setting->rw & SETTING_READ)) {
+		spin_lock_irqsave(&ide_lock, flags);
+		switch(setting->data_type) {
+			case TYPE_BYTE:
+				val = *((u8 *) setting->data);
+				break;
+			case TYPE_SHORT:
+				val = *((u16 *) setting->data);
+				break;
+			case TYPE_INT:
+			case TYPE_INTA:
+				val = *((u32 *) setting->data);
+				break;
+		}
+		spin_unlock_irqrestore(&ide_lock, flags);
+	}
+	return val;
+}
+
+/**
+ *	ide_spin_wait_hwgroup	-	wait for group
+ *	@drive: drive in the group
+ *
+ *	Wait for an IDE device group to go non busy and then return
+ *	holding the ide_lock which guards the hwgroup->busy status
+ *	and right to use it.
+ */
+
+int ide_spin_wait_hwgroup (ide_drive_t *drive)
+{
+	ide_hwgroup_t *hwgroup = HWGROUP(drive);
+	unsigned long timeout = jiffies + (3 * HZ);
+
+	spin_lock_irq(&ide_lock);
+
+	while (hwgroup->busy) {
+		unsigned long lflags;
+		spin_unlock_irq(&ide_lock);
+		local_irq_set(lflags);
+		if (time_after(jiffies, timeout)) {
+			local_irq_restore(lflags);
+			printk(KERN_ERR "%s: channel busy\n", drive->name);
+			return -EBUSY;
+		}
+		local_irq_restore(lflags);
+		spin_lock_irq(&ide_lock);
+	}
+	return 0;
+}
+
+EXPORT_SYMBOL(ide_spin_wait_hwgroup);
+
+/**
+ *	ide_write_setting	-	read an IDE setting
+ *	@drive: drive to read from
+ *	@setting: drive setting
+ *	@val: value
+ *
+ *	Write a drive setting if it is possible. The caller
+ *	must hold the ide_setting_sem when making this call.
+ *
+ *	BUGS: the data return and error are the same return value
+ *	so an error -EINVAL and true return of the same value cannot
+ *	be told apart
+ *
+ *	FIXME:  This should be changed to enqueue a special request
+ *	to the driver to change settings, and then wait on a sema for completion.
+ *	The current scheme of polling is kludgy, though safe enough.
+ */
+
+int ide_write_setting (ide_drive_t *drive, ide_settings_t *setting, int val)
+{
+	int i;
+	u32 *p;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EACCES;
+	if (!(setting->rw & SETTING_WRITE))
+		return -EPERM;
+	if (val < setting->min || val > setting->max)
+		return -EINVAL;
+	if (setting->set)
+		return setting->set(drive, val);
+	if (ide_spin_wait_hwgroup(drive))
+		return -EBUSY;
+	switch (setting->data_type) {
+		case TYPE_BYTE:
+			*((u8 *) setting->data) = val;
+			break;
+		case TYPE_SHORT:
+			*((u16 *) setting->data) = val;
+			break;
+		case TYPE_INT:
+			*((u32 *) setting->data) = val;
+			break;
+		case TYPE_INTA:
+			p = (u32 *) setting->data;
+			for (i = 0; i < 1 << PARTN_BITS; i++, p++)
+				*p = val;
+			break;
+	}
+	spin_unlock_irq(&ide_lock);
+	return 0;
+}
+
+static int set_io_32bit(ide_drive_t *drive, int arg)
+{
+	drive->io_32bit = arg;
+#ifdef CONFIG_BLK_DEV_DTC2278
+	if (HWIF(drive)->chipset == ide_dtc2278)
+		HWIF(drive)->drives[!drive->select.b.unit].io_32bit = arg;
+#endif /* CONFIG_BLK_DEV_DTC2278 */
+	return 0;
+}
+
+static int set_using_dma (ide_drive_t *drive, int arg)
+{
+#ifdef CONFIG_BLK_DEV_IDEDMA
+	if (!drive->id || !(drive->id->capability & 1))
+		return -EPERM;
+	if (HWIF(drive)->ide_dma_check == NULL)
+		return -EPERM;
+	if (arg) {
+		if (HWIF(drive)->ide_dma_check(drive)) return -EIO;
+		if (HWIF(drive)->ide_dma_on(drive)) return -EIO;
+	} else {
+		if (__ide_dma_off(drive))
+			return -EIO;
+	}
+	return 0;
+#else
+	return -EPERM;
+#endif
+}
+
+static int set_pio_mode (ide_drive_t *drive, int arg)
+{
+	struct request rq;
+
+	if (!HWIF(drive)->tuneproc)
+		return -ENOSYS;
+	if (drive->special.b.set_tune)
+		return -EBUSY;
+	ide_init_drive_cmd(&rq);
+	drive->tune_req = (u8) arg;
+	drive->special.b.set_tune = 1;
+	(void) ide_do_drive_cmd(drive, &rq, ide_wait);
+	return 0;
+}
+
+static int set_xfer_rate (ide_drive_t *drive, int arg)
+{
+	int err = ide_wait_cmd(drive,
+			WIN_SETFEATURES, (u8) arg,
+			SETFEATURES_XFER, 0, NULL);
+
+	if (!err && arg) {
+		ide_set_xfer_rate(drive, (u8) arg);
+		ide_driveid_update(drive);
+	}
+	return err;
+}
+
+/**
+ *	ide_add_generic_settings	-	generic ide settings
+ *	@drive: drive being configured
+ *
+ *	Add the generic parts of the system settings to the /proc files and
+ *	ioctls for this IDE device. The caller must not be holding the
+ *	ide_setting_sem.
+ */
+
+void ide_add_generic_settings (ide_drive_t *drive)
+{
+/*
+ *			  drive		setting name		read/write access				read ioctl		write ioctl		data type	min	max				mul_factor	div_factor	data pointer			set function
+ */
+	__ide_add_setting(drive,	"io_32bit",		drive->no_io_32bit ? SETTING_READ : SETTING_RW,	HDIO_GET_32BIT,		HDIO_SET_32BIT,		TYPE_BYTE,	0,	1 + (SUPPORT_VLB_SYNC << 1),	1,		1,		&drive->io_32bit,		set_io_32bit,	0);
+	__ide_add_setting(drive,	"keepsettings",		SETTING_RW,					HDIO_GET_KEEPSETTINGS,	HDIO_SET_KEEPSETTINGS,	TYPE_BYTE,	0,	1,				1,		1,		&drive->keep_settings,		NULL,		0);
+	__ide_add_setting(drive,	"nice1",		SETTING_RW,					-1,			-1,			TYPE_BYTE,	0,	1,				1,		1,		&drive->nice1,			NULL,		0);
+	__ide_add_setting(drive,	"pio_mode",		SETTING_WRITE,					-1,			HDIO_SET_PIO_MODE,	TYPE_BYTE,	0,	255,				1,		1,		NULL,				set_pio_mode,	0);
+	__ide_add_setting(drive,	"unmaskirq",		drive->no_unmask ? SETTING_READ : SETTING_RW,	HDIO_GET_UNMASKINTR,	HDIO_SET_UNMASKINTR,	TYPE_BYTE,	0,	1,				1,		1,		&drive->unmask,			NULL,		0);
+	__ide_add_setting(drive,	"using_dma",		SETTING_RW,					HDIO_GET_DMA,		HDIO_SET_DMA,		TYPE_BYTE,	0,	1,				1,		1,		&drive->using_dma,		set_using_dma,	0);
+	__ide_add_setting(drive,	"init_speed",		SETTING_RW,					-1,			-1,			TYPE_BYTE,	0,	70,				1,		1,		&drive->init_speed,		NULL,		0);
+	__ide_add_setting(drive,	"current_speed",	SETTING_RW,					-1,			-1,			TYPE_BYTE,	0,	70,				1,		1,		&drive->current_speed,		set_xfer_rate,	0);
+	__ide_add_setting(drive,	"number",		SETTING_RW,					-1,			-1,			TYPE_BYTE,	0,	3,				1,		1,		&drive->dn,			NULL,		0);
+}
+
+/**
+ *	system_bus_clock	-	clock guess
+ *
+ *	External version of the bus clock guess used by very old IDE drivers
+ *	for things like VLB timings. Should not be used.
+ */
+
+int system_bus_clock (void)
+{
+	return((int) ((!system_bus_speed) ? ide_system_bus_speed() : system_bus_speed ));
+}
+
+EXPORT_SYMBOL(system_bus_clock);
+
+static int generic_ide_suspend(struct device *dev, pm_message_t state)
+{
+	ide_drive_t *drive = dev->driver_data;
+	struct request rq;
+	struct request_pm_state rqpm;
+	ide_task_t args;
+
+	memset(&rq, 0, sizeof(rq));
+	memset(&rqpm, 0, sizeof(rqpm));
+	memset(&args, 0, sizeof(args));
+	rq.flags = REQ_PM_SUSPEND;
+	rq.special = &args;
+	rq.pm = &rqpm;
+	rqpm.pm_step = ide_pm_state_start_suspend;
+	rqpm.pm_state = state.event;
+
+	return ide_do_drive_cmd(drive, &rq, ide_wait);
+}
+
+static int generic_ide_resume(struct device *dev)
+{
+	ide_drive_t *drive = dev->driver_data;
+	struct request rq;
+	struct request_pm_state rqpm;
+	ide_task_t args;
+
+	memset(&rq, 0, sizeof(rq));
+	memset(&rqpm, 0, sizeof(rqpm));
+	memset(&args, 0, sizeof(args));
+	rq.flags = REQ_PM_RESUME;
+	rq.special = &args;
+	rq.pm = &rqpm;
+	rqpm.pm_step = ide_pm_state_start_resume;
+	rqpm.pm_state = PM_EVENT_ON;
+
+	return ide_do_drive_cmd(drive, &rq, ide_head_wait);
+}
+
+int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device *bdev,
+			unsigned int cmd, unsigned long arg)
+{
+	ide_settings_t *setting;
+	ide_driver_t *drv;
+	int err = 0;
+	void __user *p = (void __user *)arg;
+
+	down(&ide_setting_sem);
+	if ((setting = ide_find_setting_by_ioctl(drive, cmd)) != NULL) {
+		if (cmd == setting->read_ioctl) {
+			err = ide_read_setting(drive, setting);
+			up(&ide_setting_sem);
+			return err >= 0 ? put_user(err, (long __user *)arg) : err;
+		} else {
+			if (bdev != bdev->bd_contains)
+				err = -EINVAL;
+			else
+				err = ide_write_setting(drive, setting, arg);
+			up(&ide_setting_sem);
+			return err;
+		}
+	}
+	up(&ide_setting_sem);
+
+	switch (cmd) {
+		case HDIO_OBSOLETE_IDENTITY:
+		case HDIO_GET_IDENTITY:
+			if (bdev != bdev->bd_contains)
+				return -EINVAL;
+			if (drive->id_read == 0)
+				return -ENOMSG;
+			if (copy_to_user(p, drive->id, (cmd == HDIO_GET_IDENTITY) ? sizeof(*drive->id) : 142))
+				return -EFAULT;
+			return 0;
+
+		case HDIO_GET_NICE:
+			return put_user(drive->dsc_overlap	<<	IDE_NICE_DSC_OVERLAP	|
+					drive->atapi_overlap	<<	IDE_NICE_ATAPI_OVERLAP	|
+					drive->nice0		<< 	IDE_NICE_0		|
+					drive->nice1		<<	IDE_NICE_1		|
+					drive->nice2		<<	IDE_NICE_2,
+					(long __user *) arg);
+
+#ifdef CONFIG_IDE_TASK_IOCTL
+		case HDIO_DRIVE_TASKFILE:
+		        if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))
+				return -EACCES;
+			switch(drive->media) {
+				case ide_disk:
+					return ide_taskfile_ioctl(drive, cmd, arg);
+				default:
+					return -ENOMSG;
+			}
+#endif /* CONFIG_IDE_TASK_IOCTL */
+
+		case HDIO_DRIVE_CMD:
+			if (!capable(CAP_SYS_RAWIO))
+				return -EACCES;
+			return ide_cmd_ioctl(drive, cmd, arg);
+
+		case HDIO_DRIVE_TASK:
+			if (!capable(CAP_SYS_RAWIO))
+				return -EACCES;
+			return ide_task_ioctl(drive, cmd, arg);
+
+		case HDIO_SCAN_HWIF:
+		{
+			hw_regs_t hw;
+			int args[3];
+			if (!capable(CAP_SYS_RAWIO)) return -EACCES;
+			if (copy_from_user(args, p, 3 * sizeof(int)))
+				return -EFAULT;
+			memset(&hw, 0, sizeof(hw));
+			ide_init_hwif_ports(&hw, (unsigned long) args[0],
+					    (unsigned long) args[1], NULL);
+			hw.irq = args[2];
+			if (ide_register_hw(&hw, NULL) == -1)
+				return -EIO;
+			return 0;
+		}
+	        case HDIO_UNREGISTER_HWIF:
+			if (!capable(CAP_SYS_RAWIO)) return -EACCES;
+			/* (arg > MAX_HWIFS) checked in function */
+			ide_unregister(arg);
+			return 0;
+		case HDIO_SET_NICE:
+			if (!capable(CAP_SYS_ADMIN)) return -EACCES;
+			if (arg != (arg & ((1 << IDE_NICE_DSC_OVERLAP) | (1 << IDE_NICE_1))))
+				return -EPERM;
+			drive->dsc_overlap = (arg >> IDE_NICE_DSC_OVERLAP) & 1;
+			drv = *(ide_driver_t **)bdev->bd_disk->private_data;
+			if (drive->dsc_overlap && !drv->supports_dsc_overlap) {
+				drive->dsc_overlap = 0;
+				return -EPERM;
+			}
+			drive->nice1 = (arg >> IDE_NICE_1) & 1;
+			return 0;
+		case HDIO_DRIVE_RESET:
+		{
+			unsigned long flags;
+			if (!capable(CAP_SYS_ADMIN)) return -EACCES;
+			
+			/*
+			 *	Abort the current command on the
+			 *	group if there is one, taking
+			 *	care not to allow anything else
+			 *	to be queued and to die on the
+			 *	spot if we miss one somehow
+			 */
+
+			spin_lock_irqsave(&ide_lock, flags);
+
+			ide_abort(drive, "drive reset");
+
+			if(HWGROUP(drive)->handler)
+				BUG();
+				
+			/* Ensure nothing gets queued after we
+			   drop the lock. Reset will clear the busy */
+		   
+			HWGROUP(drive)->busy = 1;
+			spin_unlock_irqrestore(&ide_lock, flags);
+			(void) ide_do_reset(drive);
+
+			return 0;
+		}
+
+		case CDROMEJECT:
+		case CDROMCLOSETRAY:
+			return scsi_cmd_ioctl(file, bdev->bd_disk, cmd, p);
+
+		case HDIO_GET_BUSSTATE:
+			if (!capable(CAP_SYS_ADMIN))
+				return -EACCES;
+			if (put_user(HWIF(drive)->bus_state, (long __user *)arg))
+				return -EFAULT;
+			return 0;
+
+		case HDIO_SET_BUSSTATE:
+			if (!capable(CAP_SYS_ADMIN))
+				return -EACCES;
+			if (HWIF(drive)->busproc)
+				return HWIF(drive)->busproc(drive, (int)arg);
+			return -EOPNOTSUPP;
+		default:
+			return -EINVAL;
+	}
+}
+
+EXPORT_SYMBOL(generic_ide_ioctl);
+
+/*
+ * stridx() returns the offset of c within s,
+ * or -1 if c is '\0' or not found within s.
+ */
+static int __init stridx (const char *s, char c)
+{
+	char *i = strchr(s, c);
+	return (i && c) ? i - s : -1;
+}
+
+/*
+ * match_parm() does parsing for ide_setup():
+ *
+ * 1. the first char of s must be '='.
+ * 2. if the remainder matches one of the supplied keywords,
+ *     the index (1 based) of the keyword is negated and returned.
+ * 3. if the remainder is a series of no more than max_vals numbers
+ *     separated by commas, the numbers are saved in vals[] and a
+ *     count of how many were saved is returned.  Base10 is assumed,
+ *     and base16 is allowed when prefixed with "0x".
+ * 4. otherwise, zero is returned.
+ */
+static int __init match_parm (char *s, const char *keywords[], int vals[], int max_vals)
+{
+	static const char *decimal = "0123456789";
+	static const char *hex = "0123456789abcdef";
+	int i, n;
+
+	if (*s++ == '=') {
+		/*
+		 * Try matching against the supplied keywords,
+		 * and return -(index+1) if we match one
+		 */
+		if (keywords != NULL) {
+			for (i = 0; *keywords != NULL; ++i) {
+				if (!strcmp(s, *keywords++))
+					return -(i+1);
+			}
+		}
+		/*
+		 * Look for a series of no more than "max_vals"
+		 * numeric values separated by commas, in base10,
+		 * or base16 when prefixed with "0x".
+		 * Return a count of how many were found.
+		 */
+		for (n = 0; (i = stridx(decimal, *s)) >= 0;) {
+			vals[n] = i;
+			while ((i = stridx(decimal, *++s)) >= 0)
+				vals[n] = (vals[n] * 10) + i;
+			if (*s == 'x' && !vals[n]) {
+				while ((i = stridx(hex, *++s)) >= 0)
+					vals[n] = (vals[n] * 0x10) + i;
+			}
+			if (++n == max_vals)
+				break;
+			if (*s == ',' || *s == ';')
+				++s;
+		}
+		if (!*s)
+			return n;
+	}
+	return 0;	/* zero = nothing matched */
+}
+
+#ifdef CONFIG_BLK_DEV_ALI14XX
+static int __initdata probe_ali14xx;
+extern int ali14xx_init(void);
+#endif
+#ifdef CONFIG_BLK_DEV_UMC8672
+static int __initdata probe_umc8672;
+extern int umc8672_init(void);
+#endif
+#ifdef CONFIG_BLK_DEV_DTC2278
+static int __initdata probe_dtc2278;
+extern int dtc2278_init(void);
+#endif
+#ifdef CONFIG_BLK_DEV_HT6560B
+static int __initdata probe_ht6560b;
+extern int ht6560b_init(void);
+#endif
+#ifdef CONFIG_BLK_DEV_QD65XX
+static int __initdata probe_qd65xx;
+extern int qd65xx_init(void);
+#endif
+
+static int __initdata is_chipset_set[MAX_HWIFS];
+
+/*
+ * ide_setup() gets called VERY EARLY during initialization,
+ * to handle kernel "command line" strings beginning with "hdx=" or "ide".
+ *
+ * Remember to update Documentation/ide.txt if you change something here.
+ */
+static int __init ide_setup(char *s)
+{
+	int i, vals[3];
+	ide_hwif_t *hwif;
+	ide_drive_t *drive;
+	unsigned int hw, unit;
+	const char max_drive = 'a' + ((MAX_HWIFS * MAX_DRIVES) - 1);
+	const char max_hwif  = '0' + (MAX_HWIFS - 1);
+
+	
+	if (strncmp(s,"hd",2) == 0 && s[2] == '=')	/* hd= is for hd.c   */
+		return 0;				/* driver and not us */
+
+	if (strncmp(s,"ide",3) && strncmp(s,"idebus",6) && strncmp(s,"hd",2))
+		return 0;
+
+	printk(KERN_INFO "ide_setup: %s", s);
+	init_ide_data ();
+
+#ifdef CONFIG_BLK_DEV_IDEDOUBLER
+	if (!strcmp(s, "ide=doubler")) {
+		extern int ide_doubler;
+
+		printk(" : Enabled support for IDE doublers\n");
+		ide_doubler = 1;
+		return 1;
+	}
+#endif /* CONFIG_BLK_DEV_IDEDOUBLER */
+
+	if (!strcmp(s, "ide=nodma")) {
+		printk(" : Prevented DMA\n");
+		noautodma = 1;
+		return 1;
+	}
+
+#ifdef CONFIG_BLK_DEV_IDEPCI
+	if (!strcmp(s, "ide=reverse")) {
+		ide_scan_direction = 1;
+		printk(" : Enabled support for IDE inverse scan order.\n");
+		return 1;
+	}
+#endif /* CONFIG_BLK_DEV_IDEPCI */
+
+	/*
+	 * Look for drive options:  "hdx="
+	 */
+	if (s[0] == 'h' && s[1] == 'd' && s[2] >= 'a' && s[2] <= max_drive) {
+		const char *hd_words[] = {
+			"none", "noprobe", "nowerr", "cdrom", "serialize",
+			"autotune", "noautotune", "minus8", "swapdata", "bswap",
+			"minus11", "remap", "remap63", "scsi", NULL };
+		unit = s[2] - 'a';
+		hw   = unit / MAX_DRIVES;
+		unit = unit % MAX_DRIVES;
+		hwif = &ide_hwifs[hw];
+		drive = &hwif->drives[unit];
+		if (strncmp(s + 4, "ide-", 4) == 0) {
+			strlcpy(drive->driver_req, s + 4, sizeof(drive->driver_req));
+			goto done;
+		}
+		switch (match_parm(&s[3], hd_words, vals, 3)) {
+			case -1: /* "none" */
+			case -2: /* "noprobe" */
+				drive->noprobe = 1;
+				goto done;
+			case -3: /* "nowerr" */
+				drive->bad_wstat = BAD_R_STAT;
+				hwif->noprobe = 0;
+				goto done;
+			case -4: /* "cdrom" */
+				drive->present = 1;
+				drive->media = ide_cdrom;
+				/* an ATAPI device ignores DRDY */
+				drive->ready_stat = 0;
+				hwif->noprobe = 0;
+				goto done;
+			case -5: /* "serialize" */
+				printk(" -- USE \"ide%d=serialize\" INSTEAD", hw);
+				goto do_serialize;
+			case -6: /* "autotune" */
+				drive->autotune = IDE_TUNE_AUTO;
+				goto obsolete_option;
+			case -7: /* "noautotune" */
+				drive->autotune = IDE_TUNE_NOAUTO;
+				goto obsolete_option;
+			case -9: /* "swapdata" */
+			case -10: /* "bswap" */
+				drive->bswap = 1;
+				goto done;
+			case -12: /* "remap" */
+				drive->remap_0_to_1 = 1;
+				goto done;
+			case -13: /* "remap63" */
+				drive->sect0 = 63;
+				goto done;
+			case -14: /* "scsi" */
+				drive->scsi = 1;
+				goto done;
+			case 3: /* cyl,head,sect */
+				drive->media	= ide_disk;
+				drive->ready_stat = READY_STAT;
+				drive->cyl	= drive->bios_cyl  = vals[0];
+				drive->head	= drive->bios_head = vals[1];
+				drive->sect	= drive->bios_sect = vals[2];
+				drive->present	= 1;
+				drive->forced_geom = 1;
+				hwif->noprobe = 0;
+				goto done;
+			default:
+				goto bad_option;
+		}
+	}
+
+	if (s[0] != 'i' || s[1] != 'd' || s[2] != 'e')
+		goto bad_option;
+	/*
+	 * Look for bus speed option:  "idebus="
+	 */
+	if (s[3] == 'b' && s[4] == 'u' && s[5] == 's') {
+		if (match_parm(&s[6], NULL, vals, 1) != 1)
+			goto bad_option;
+		if (vals[0] >= 20 && vals[0] <= 66) {
+			idebus_parameter = vals[0];
+		} else
+			printk(" -- BAD BUS SPEED! Expected value from 20 to 66");
+		goto done;
+	}
+	/*
+	 * Look for interface options:  "idex="
+	 */
+	if (s[3] >= '0' && s[3] <= max_hwif) {
+		/*
+		 * Be VERY CAREFUL changing this: note hardcoded indexes below
+		 * (-8, -9, -10) are reserved to ease the hardcoding.
+		 */
+		static const char *ide_words[] = {
+			"noprobe", "serialize", "autotune", "noautotune", 
+			"reset", "dma", "ata66", "minus8", "minus9",
+			"minus10", "four", "qd65xx", "ht6560b", "cmd640_vlb",
+			"dtc2278", "umc8672", "ali14xx", NULL };
+		hw = s[3] - '0';
+		hwif = &ide_hwifs[hw];
+		i = match_parm(&s[4], ide_words, vals, 3);
+
+		/*
+		 * Cryptic check to ensure chipset not already set for hwif.
+		 * Note: we can't depend on hwif->chipset here.
+		 */
+		if ((i >= -18 && i <= -11) || (i > 0 && i <= 3)) {
+			/* chipset already specified */
+			if (is_chipset_set[hw])
+				goto bad_option;
+			if (i > -18 && i <= -11) {
+				/* these drivers are for "ide0=" only */
+				if (hw != 0)
+					goto bad_hwif;
+				/* chipset already specified for 2nd port */
+				if (is_chipset_set[hw+1])
+					goto bad_option;
+			}
+			is_chipset_set[hw] = 1;
+			printk("\n");
+		}
+
+		switch (i) {
+#ifdef CONFIG_BLK_DEV_ALI14XX
+			case -17: /* "ali14xx" */
+				probe_ali14xx = 1;
+				goto done;
+#endif
+#ifdef CONFIG_BLK_DEV_UMC8672
+			case -16: /* "umc8672" */
+				probe_umc8672 = 1;
+				goto done;
+#endif
+#ifdef CONFIG_BLK_DEV_DTC2278
+			case -15: /* "dtc2278" */
+				probe_dtc2278 = 1;
+				goto done;
+#endif
+#ifdef CONFIG_BLK_DEV_CMD640
+			case -14: /* "cmd640_vlb" */
+			{
+				extern int cmd640_vlb; /* flag for cmd640.c */
+				cmd640_vlb = 1;
+				goto done;
+			}
+#endif
+#ifdef CONFIG_BLK_DEV_HT6560B
+			case -13: /* "ht6560b" */
+				probe_ht6560b = 1;
+				goto done;
+#endif
+#ifdef CONFIG_BLK_DEV_QD65XX
+			case -12: /* "qd65xx" */
+				probe_qd65xx = 1;
+				goto done;
+#endif
+#ifdef CONFIG_BLK_DEV_4DRIVES
+			case -11: /* "four" drives on one set of ports */
+			{
+				ide_hwif_t *mate = &ide_hwifs[hw^1];
+				mate->drives[0].select.all ^= 0x20;
+				mate->drives[1].select.all ^= 0x20;
+				hwif->chipset = mate->chipset = ide_4drives;
+				mate->irq = hwif->irq;
+				memcpy(mate->io_ports, hwif->io_ports, sizeof(hwif->io_ports));
+				goto do_serialize;
+			}
+#endif /* CONFIG_BLK_DEV_4DRIVES */
+			case -10: /* minus10 */
+			case -9: /* minus9 */
+			case -8: /* minus8 */
+				goto bad_option;
+			case -7: /* ata66 */
+#ifdef CONFIG_BLK_DEV_IDEPCI
+				hwif->udma_four = 1;
+				goto obsolete_option;
+#else
+				goto bad_hwif;
+#endif
+			case -6: /* dma */
+				hwif->autodma = 1;
+				goto obsolete_option;
+			case -5: /* "reset" */
+				hwif->reset = 1;
+				goto obsolete_option;
+			case -4: /* "noautotune" */
+				hwif->drives[0].autotune = IDE_TUNE_NOAUTO;
+				hwif->drives[1].autotune = IDE_TUNE_NOAUTO;
+				goto obsolete_option;
+			case -3: /* "autotune" */
+				hwif->drives[0].autotune = IDE_TUNE_AUTO;
+				hwif->drives[1].autotune = IDE_TUNE_AUTO;
+				goto obsolete_option;
+			case -2: /* "serialize" */
+			do_serialize:
+				hwif->mate = &ide_hwifs[hw^1];
+				hwif->mate->mate = hwif;
+				hwif->serialized = hwif->mate->serialized = 1;
+				goto obsolete_option;
+
+			case -1: /* "noprobe" */
+				hwif->noprobe = 1;
+				goto done;
+
+			case 1:	/* base */
+				vals[1] = vals[0] + 0x206; /* default ctl */
+			case 2: /* base,ctl */
+				vals[2] = 0;	/* default irq = probe for it */
+			case 3: /* base,ctl,irq */
+				hwif->hw.irq = vals[2];
+				ide_init_hwif_ports(&hwif->hw, (unsigned long) vals[0], (unsigned long) vals[1], &hwif->irq);
+				memcpy(hwif->io_ports, hwif->hw.io_ports, sizeof(hwif->io_ports));
+				hwif->irq      = vals[2];
+				hwif->noprobe  = 0;
+				hwif->chipset  = ide_forced;
+				goto obsolete_option;
+
+			case 0: goto bad_option;
+			default:
+				printk(" -- SUPPORT NOT CONFIGURED IN THIS KERNEL\n");
+				return 1;
+		}
+	}
+bad_option:
+	printk(" -- BAD OPTION\n");
+	return 1;
+obsolete_option:
+	printk(" -- OBSOLETE OPTION, WILL BE REMOVED SOON!\n");
+	return 1;
+bad_hwif:
+	printk("-- NOT SUPPORTED ON ide%d", hw);
+done:
+	printk("\n");
+	return 1;
+}
+
+extern void pnpide_init(void);
+extern void h8300_ide_init(void);
+
+/*
+ * probe_for_hwifs() finds/initializes "known" IDE interfaces
+ */
+static void __init probe_for_hwifs (void)
+{
+#ifdef CONFIG_BLK_DEV_IDEPCI
+	ide_scan_pcibus(ide_scan_direction);
+#endif /* CONFIG_BLK_DEV_IDEPCI */
+
+#ifdef CONFIG_ETRAX_IDE
+	{
+		extern void init_e100_ide(void);
+		init_e100_ide();
+	}
+#endif /* CONFIG_ETRAX_IDE */
+#ifdef CONFIG_BLK_DEV_CMD640
+	{
+		extern void ide_probe_for_cmd640x(void);
+		ide_probe_for_cmd640x();
+	}
+#endif /* CONFIG_BLK_DEV_CMD640 */
+#ifdef CONFIG_BLK_DEV_IDE_PMAC
+	{
+		extern void pmac_ide_probe(void);
+		pmac_ide_probe();
+	}
+#endif /* CONFIG_BLK_DEV_IDE_PMAC */
+#ifdef CONFIG_BLK_DEV_GAYLE
+	{
+		extern void gayle_init(void);
+		gayle_init();
+	}
+#endif /* CONFIG_BLK_DEV_GAYLE */
+#ifdef CONFIG_BLK_DEV_FALCON_IDE
+	{
+		extern void falconide_init(void);
+		falconide_init();
+	}
+#endif /* CONFIG_BLK_DEV_FALCON_IDE */
+#ifdef CONFIG_BLK_DEV_MAC_IDE
+	{
+		extern void macide_init(void);
+		macide_init();
+	}
+#endif /* CONFIG_BLK_DEV_MAC_IDE */
+#ifdef CONFIG_BLK_DEV_Q40IDE
+	{
+		extern void q40ide_init(void);
+		q40ide_init();
+	}
+#endif /* CONFIG_BLK_DEV_Q40IDE */
+#ifdef CONFIG_BLK_DEV_BUDDHA
+	{
+		extern void buddha_init(void);
+		buddha_init();
+	}
+#endif /* CONFIG_BLK_DEV_BUDDHA */
+#ifdef CONFIG_BLK_DEV_IDEPNP
+	pnpide_init();
+#endif
+#ifdef CONFIG_H8300
+	h8300_ide_init();
+#endif
+}
+
+void ide_register_subdriver(ide_drive_t *drive, ide_driver_t *driver)
+{
+#ifdef CONFIG_PROC_FS
+	ide_add_proc_entries(drive->proc, driver->proc, drive);
+#endif
+}
+
+EXPORT_SYMBOL(ide_register_subdriver);
+
+/**
+ *	ide_unregister_subdriver	-	disconnect drive from driver
+ *	@drive: drive to unplug
+ *	@driver: driver
+ *
+ *	Disconnect a drive from the driver it was attached to and then
+ *	clean up the various proc files and other objects attached to it.
+ *
+ *	Takes ide_setting_sem and ide_lock.
+ *	Caller must hold none of the locks.
+ */
+
+void ide_unregister_subdriver(ide_drive_t *drive, ide_driver_t *driver)
+{
+	unsigned long flags;
+	
+	down(&ide_setting_sem);
+	spin_lock_irqsave(&ide_lock, flags);
+#ifdef CONFIG_PROC_FS
+	ide_remove_proc_entries(drive->proc, driver->proc);
+#endif
+	auto_remove_settings(drive);
+	spin_unlock_irqrestore(&ide_lock, flags);
+	up(&ide_setting_sem);
+}
+
+EXPORT_SYMBOL(ide_unregister_subdriver);
+
+/*
+ * Probe module
+ */
+
+EXPORT_SYMBOL(ide_lock);
+
+static int ide_bus_match(struct device *dev, struct device_driver *drv)
+{
+	return 1;
+}
+
+static char *media_string(ide_drive_t *drive)
+{
+	switch (drive->media) {
+	case ide_disk:
+		return "disk";
+	case ide_cdrom:
+		return "cdrom";
+	case ide_tape:
+		return "tape";
+	case ide_floppy:
+		return "floppy";
+	default:
+		return "UNKNOWN";
+	}
+}
+
+static ssize_t media_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ide_drive_t *drive = to_ide_device(dev);
+	return sprintf(buf, "%s\n", media_string(drive));
+}
+
+static ssize_t drivename_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ide_drive_t *drive = to_ide_device(dev);
+	return sprintf(buf, "%s\n", drive->name);
+}
+
+static ssize_t modalias_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ide_drive_t *drive = to_ide_device(dev);
+	return sprintf(buf, "ide:m-%s\n", media_string(drive));
+}
+
+static struct device_attribute ide_dev_attrs[] = {
+	__ATTR_RO(media),
+	__ATTR_RO(drivename),
+	__ATTR_RO(modalias),
+	__ATTR_NULL
+};
+
+static int ide_uevent(struct device *dev, char **envp, int num_envp,
+		      char *buffer, int buffer_size)
+{
+	ide_drive_t *drive = to_ide_device(dev);
+	int i = 0;
+	int length = 0;
+
+	add_uevent_var(envp, num_envp, &i, buffer, buffer_size, &length,
+		       "MEDIA=%s", media_string(drive));
+	add_uevent_var(envp, num_envp, &i, buffer, buffer_size, &length,
+		       "DRIVENAME=%s", drive->name);
+	add_uevent_var(envp, num_envp, &i, buffer, buffer_size, &length,
+		       "MODALIAS=ide:m-%s", media_string(drive));
+	envp[i] = NULL;
+	return 0;
+}
+
+static int generic_ide_probe(struct device *dev)
+{
+	ide_drive_t *drive = to_ide_device(dev);
+	ide_driver_t *drv = to_ide_driver(dev->driver);
+
+	return drv->probe ? drv->probe(drive) : -ENODEV;
+}
+
+static int generic_ide_remove(struct device *dev)
+{
+	ide_drive_t *drive = to_ide_device(dev);
+	ide_driver_t *drv = to_ide_driver(dev->driver);
+
+	if (drv->remove)
+		drv->remove(drive);
+
+	return 0;
+}
+
+static void generic_ide_shutdown(struct device *dev)
+{
+	ide_drive_t *drive = to_ide_device(dev);
+	ide_driver_t *drv = to_ide_driver(dev->driver);
+
+	if (dev->driver && drv->shutdown)
+		drv->shutdown(drive);
+}
+
+struct bus_type ide_bus_type = {
+	.name		= "ide",
+	.match		= ide_bus_match,
+	.uevent		= ide_uevent,
+	.probe		= generic_ide_probe,
+	.remove		= generic_ide_remove,
+	.shutdown	= generic_ide_shutdown,
+	.dev_attrs	= ide_dev_attrs,
+	.suspend	= generic_ide_suspend,
+	.resume		= generic_ide_resume,
+};
+
+EXPORT_SYMBOL_GPL(ide_bus_type);
+
+/*
+ * This is gets invoked once during initialization, to set *everything* up
+ */
+static int __init ide_init(void)
+{
+	printk(KERN_INFO "Uniform Multi-Platform E-IDE driver " REVISION "\n");
+	devfs_mk_dir("ide");
+	system_bus_speed = ide_system_bus_speed();
+
+	bus_register(&ide_bus_type);
+
+	init_ide_data();
+
+#ifdef CONFIG_PROC_FS
+	proc_ide_root = proc_mkdir("ide", NULL);
+#endif
+
+#ifdef CONFIG_BLK_DEV_ALI14XX
+	if (probe_ali14xx)
+		(void)ali14xx_init();
+#endif
+#ifdef CONFIG_BLK_DEV_UMC8672
+	if (probe_umc8672)
+		(void)umc8672_init();
+#endif
+#ifdef CONFIG_BLK_DEV_DTC2278
+	if (probe_dtc2278)
+		(void)dtc2278_init();
+#endif
+#ifdef CONFIG_BLK_DEV_HT6560B
+	if (probe_ht6560b)
+		(void)ht6560b_init();
+#endif
+#ifdef CONFIG_BLK_DEV_QD65XX
+	if (probe_qd65xx)
+		(void)qd65xx_init();
+#endif
+
+	initializing = 1;
+	/* Probe for special PCI and other "known" interface chipsets. */
+	probe_for_hwifs();
+	initializing = 0;
+
+#ifdef CONFIG_PROC_FS
+	proc_ide_create();
+#endif
+	return 0;
+}
+
+#ifdef MODULE
+static char *options = NULL;
+module_param(options, charp, 0);
+MODULE_LICENSE("GPL");
+
+static void __init parse_options (char *line)
+{
+	char *next = line;
+
+	if (line == NULL || !*line)
+		return;
+	while ((line = next) != NULL) {
+ 		if ((next = strchr(line,' ')) != NULL)
+			*next++ = 0;
+		if (!ide_setup(line))
+			printk (KERN_INFO "Unknown option '%s'\n", line);
+	}
+}
+
+int init_module (void)
+{
+	parse_options(options);
+	return ide_init();
+}
+
+void cleanup_module (void)
+{
+	int index;
+
+	for (index = 0; index < MAX_HWIFS; ++index)
+		ide_unregister(index);
+
+#ifdef CONFIG_PROC_FS
+	proc_ide_destroy();
+#endif
+	devfs_remove("ide");
+
+	bus_unregister(&ide_bus_type);
+}
+
+#else /* !MODULE */
+
+__setup("", ide_setup);
+
+module_init(ide_init);
+
+#endif /* MODULE */
diff -urN linux-2.6.16.orig/drivers/ide/Kconfig linux-2.6.16/drivers/ide/Kconfig
--- linux-2.6.16.orig/drivers/ide/Kconfig	2006-03-20 00:53:29.000000000 -0500
+++ linux-2.6.16/drivers/ide/Kconfig	2006-04-05 16:24:26.000000000 -0400
@@ -850,6 +850,16 @@
 	  Say Y here if you want to support the onboard IDE channels on the
 	  Simtec BAST or the Thorcom VR1000
 
+config BLK_DEV_IDE_AVILA
+	bool "Gateworks Avila IDE/CF Interface"
+	depends on (ARCH_IXDP425 || ARCH_AVILA  || MACH_LOFT) && BLK_DEV_IDEDISK && IDE_GENERIC
+	help
+		Say Y here if you want to build support for the Gateworks Avila
+		IDE/CF interface attached to the IXP4XX Expansion Bus. The IDE/CF
+		interface will allow Linux to see an inserted Compact Flash Card
+		as an ATA device which can be mounted and used as a normal hard
+		drive.
+
 config BLK_DEV_GAYLE
 	bool "Amiga Gayle IDE interface support"
 	depends on AMIGA
diff -urN linux-2.6.16.orig/drivers/ide/Kconfig.orig linux-2.6.16/drivers/ide/Kconfig.orig
--- linux-2.6.16.orig/drivers/ide/Kconfig.orig	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.16/drivers/ide/Kconfig.orig	2006-03-20 00:53:29.000000000 -0500
@@ -0,0 +1,1090 @@
+#
+# IDE ATA ATAPI Block device driver configuration
+#
+# Andre Hedrick <andre@linux-ide.org>
+#
+
+menu "ATA/ATAPI/MFM/RLL support"
+
+config IDE
+	tristate "ATA/ATAPI/MFM/RLL support"
+	---help---
+	  If you say Y here, your kernel will be able to manage low cost mass
+	  storage units such as ATA/(E)IDE and ATAPI units. The most common
+	  cases are IDE hard drives and ATAPI CD-ROM drives.
+
+	  If your system is pure SCSI and doesn't use these interfaces, you
+	  can say N here.
+
+	  Integrated Disk Electronics (IDE aka ATA-1) is a connecting standard
+	  for mass storage units such as hard disks. It was designed by
+	  Western Digital and Compaq Computer in 1984. It was then named
+	  ST506. Quite a number of disks use the IDE interface.
+
+	  AT Attachment (ATA) is the superset of the IDE specifications.
+	  ST506 was also called ATA-1.
+
+	  Fast-IDE is ATA-2 (also named Fast ATA), Enhanced IDE (EIDE) is
+	  ATA-3. It provides support for larger disks (up to 8.4GB by means of
+	  the LBA standard), more disks (4 instead of 2) and for other mass
+	  storage units such as tapes and cdrom. UDMA/33 (aka UltraDMA/33) is
+	  ATA-4 and provides faster (and more CPU friendly) transfer modes
+	  than previous PIO (Programmed processor Input/Output) from previous
+	  ATA/IDE standards by means of fast DMA controllers.
+
+	  ATA Packet Interface (ATAPI) is a protocol used by EIDE tape and
+	  CD-ROM drives, similar in many respects to the SCSI protocol.
+
+	  SMART IDE (Self Monitoring, Analysis and Reporting Technology) was
+	  designed in order to prevent data corruption and disk crash by
+	  detecting pre hardware failure conditions (heat, access time, and
+	  the like...). Disks built since June 1995 may follow this standard.
+	  The kernel itself doesn't manage this; however there are quite a
+	  number of user programs such as smart that can query the status of
+	  SMART parameters from disk drives.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ide.
+
+	  For further information, please read <file:Documentation/ide.txt>.
+
+	  If unsure, say Y.
+
+if IDE
+
+config IDE_MAX_HWIFS
+	int "Max IDE interfaces"
+	depends on ALPHA || SUPERH || IA64
+	default 4
+	help
+	  This is the maximum number of IDE hardware interfaces that will
+	  be supported by the driver. Make sure it is at least as high as
+	  the number of IDE interfaces in your system.
+
+config BLK_DEV_IDE
+	tristate "Enhanced IDE/MFM/RLL disk/cdrom/tape/floppy support"
+	---help---
+	  If you say Y here, you will use the full-featured IDE driver to
+	  control up to ten ATA/IDE interfaces, each being able to serve a
+	  "master" and a "slave" device, for a total of up to twenty ATA/IDE
+	  disk/cdrom/tape/floppy drives.
+
+	  Useful information about large (>540 MB) IDE disks, multiple
+	  interfaces, what to do if ATA/IDE devices are not automatically
+	  detected, sound card ATA/IDE ports, module support, and other
+	  topics, is contained in <file:Documentation/ide.txt>. For detailed
+	  information about hard drives, consult the Disk-HOWTO and the
+	  Multi-Disk-HOWTO, available from
+	  <http://www.tldp.org/docs.html#howto>.
+
+	  To fine-tune ATA/IDE drive/interface parameters for improved
+	  performance, look for the hdparm package at
+	  <ftp://ibiblio.org/pub/Linux/system/hardware/>.
+
+	  To compile this driver as a module, choose M here and read
+	  <file:Documentation/ide.txt>. The module will be called ide-mod.
+	  Do not compile this driver as a module if your root file system (the
+	  one containing the directory /) is located on an IDE device.
+
+	  If you have one or more IDE drives, say Y or M here. If your system
+	  has no IDE drives, or if memory requirements are really tight, you
+	  could say N here, and select the "Old hard disk driver" below
+	  instead to save about 13 KB of memory in the kernel.
+
+if BLK_DEV_IDE
+
+comment "Please see Documentation/ide.txt for help/info on IDE drives"
+
+config BLK_DEV_IDE_SATA
+	bool "Support for SATA (deprecated; conflicts with libata SATA driver)"
+	default n
+	---help---
+	  There are two drivers for Serial ATA controllers.
+
+	  The main driver, "libata", exists inside the SCSI subsystem
+	  and supports most modern SATA controllers.
+
+	  The IDE driver (which you are currently configuring) supports
+	  a few first-generation SATA controllers.
+
+	  In order to eliminate conflicts between the two subsystems,
+	  this config option enables the IDE driver's SATA support.
+	  Normally this is disabled, as it is preferred that libata
+	  supports SATA controllers, and this (IDE) driver supports
+	  PATA controllers.
+
+	  If unsure, say N.
+
+config BLK_DEV_HD_IDE
+	bool "Use old disk-only driver on primary interface"
+	depends on (X86 || SH_MPC1211)
+	---help---
+	  There are two drivers for MFM/RLL/IDE disks.  Most people use just
+	  the new enhanced driver by itself.  This option however installs the
+	  old hard disk driver to control the primary IDE/disk interface in
+	  the system, leaving the new enhanced IDE driver to take care of only
+	  the 2nd/3rd/4th IDE interfaces.  Doing this will prevent you from
+	  having an IDE/ATAPI CD-ROM or tape drive connected to the primary
+	  IDE interface.  Choosing this option may be useful for older systems
+	  which have MFM/RLL/ESDI controller+drives at the primary port
+	  address (0x1f0), along with IDE drives at the secondary/3rd/4th port
+	  addresses.
+
+	  Normally, just say N here; you will then use the new driver for all
+	  4 interfaces.
+
+config BLK_DEV_IDEDISK
+	tristate "Include IDE/ATA-2 DISK support"
+	---help---
+	  This will include enhanced support for MFM/RLL/IDE hard disks.  If
+	  you have a MFM/RLL/IDE disk, and there is no special reason to use
+	  the old hard disk driver instead, say Y.  If you have an SCSI-only
+	  system, you can say N here.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ide-disk.
+	  Do not compile this driver as a module if your root file system
+	  (the one containing the directory /) is located on the IDE disk.
+
+	  If unsure, say Y.
+
+config IDEDISK_MULTI_MODE
+	bool "Use multi-mode by default"
+	help
+	  If you get this error, try to say Y here:
+
+	  hda: set_multmode: status=0x51 { DriveReady SeekComplete Error }
+	  hda: set_multmode: error=0x04 { DriveStatusError }
+
+	  If in doubt, say N.
+
+config BLK_DEV_IDECS
+	tristate "PCMCIA IDE support"
+	depends on PCMCIA
+	help
+	  Support for Compact Flash cards, outboard IDE disks, tape drives,
+	  and CD-ROM drives connected through a PCMCIA card.
+
+config BLK_DEV_IDECD
+	tristate "Include IDE/ATAPI CDROM support"
+	---help---
+	  If you have a CD-ROM drive using the ATAPI protocol, say Y. ATAPI is
+	  a newer protocol used by IDE CD-ROM and TAPE drives, similar to the
+	  SCSI protocol. Most new CD-ROM drives use ATAPI, including the
+	  NEC-260, Mitsumi FX400, Sony 55E, and just about all non-SCSI
+	  double(2X) or better speed drives.
+
+	  If you say Y here, the CD-ROM drive will be identified at boot time
+	  along with other IDE devices, as "hdb" or "hdc", or something
+	  similar (check the boot messages with dmesg). If this is your only
+	  CD-ROM drive, you can say N to all other CD-ROM options, but be sure
+	  to say Y or M to "ISO 9660 CD-ROM file system support".
+
+	  Note that older versions of LILO (LInux LOader) cannot properly deal
+	  with IDE/ATAPI CD-ROMs, so install LILO 16 or higher, available from
+	  <http://lilo.go.dyndns.org/>.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ide-cd.
+
+config BLK_DEV_IDETAPE
+	tristate "Include IDE/ATAPI TAPE support (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	help
+	  If you have an IDE tape drive using the ATAPI protocol, say Y.
+	  ATAPI is a newer protocol used by IDE tape and CD-ROM drives,
+	  similar to the SCSI protocol.  If you have an SCSI tape drive
+	  however, you can say N here.
+
+	  You should also say Y if you have an OnStream DI-30 tape drive; this
+	  will not work with the SCSI protocol, until there is support for the
+	  SC-30 and SC-50 versions.
+
+	  If you say Y here, the tape drive will be identified at boot time
+	  along with other IDE devices, as "hdb" or "hdc", or something
+	  similar, and will be mapped to a character device such as "ht0"
+	  (check the boot messages with dmesg).  Be sure to consult the
+	  <file:drivers/ide/ide-tape.c> and <file:Documentation/ide.txt> files
+	  for usage information.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ide-tape.
+
+config BLK_DEV_IDEFLOPPY
+	tristate "Include IDE/ATAPI FLOPPY support"
+	---help---
+	  If you have an IDE floppy drive which uses the ATAPI protocol,
+	  answer Y.  ATAPI is a newer protocol used by IDE CD-ROM/tape/floppy
+	  drives, similar to the SCSI protocol.
+
+	  The LS-120 and the IDE/ATAPI Iomega ZIP drive are also supported by
+	  this driver. For information about jumper settings and the question
+	  of when a ZIP drive uses a partition table, see
+	  <http://www.win.tue.nl/~aeb/linux/zip/zip-1.html>.
+	  (ATAPI PD-CD/CDR drives are not supported by this driver; support
+	  for PD-CD/CDR drives is available if you answer Y to
+	  "SCSI emulation support", below).
+
+	  If you say Y here, the FLOPPY drive will be identified along with
+	  other IDE devices, as "hdb" or "hdc", or something similar (check
+	  the boot messages with dmesg).
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ide-floppy.
+
+config BLK_DEV_IDESCSI
+	tristate "SCSI emulation support"
+	depends on SCSI
+	---help---
+	  WARNING: ide-scsi is no longer needed for cd writing applications!
+	  The 2.6 kernel supports direct writing to ide-cd, which eliminates
+	  the need for ide-scsi + the entire scsi stack just for writing a
+	  cd. The new method is more efficient in every way.
+
+	  This will provide SCSI host adapter emulation for IDE ATAPI devices,
+	  and will allow you to use a SCSI device driver instead of a native
+	  ATAPI driver.
+
+	  This is useful if you have an ATAPI device for which no native
+	  driver has been written (for example, an ATAPI PD-CD drive);
+	  you can then use this emulation together with an appropriate SCSI
+	  device driver. In order to do this, say Y here and to "SCSI support"
+	  and "SCSI generic support", below. You must then provide the kernel
+	  command line "hdx=ide-scsi" (try "man bootparam" or see the
+	  documentation of your boot loader (lilo or loadlin) about how to
+	  pass options to the kernel at boot time) for devices if you want the
+	  native EIDE sub-drivers to skip over the native support, so that
+	  this SCSI emulation can be used instead.
+
+	  Note that this option does NOT allow you to attach SCSI devices to a
+	  box that doesn't have a SCSI host adapter installed.
+
+	  If both this SCSI emulation and native ATAPI support are compiled
+	  into the kernel, the native support will be used.
+
+config IDE_TASK_IOCTL
+	bool "IDE Taskfile Access"
+	help
+	  This is a direct raw access to the media.  It is a complex but
+	  elegant solution to test and validate the domain of the hardware and
+	  perform below the driver data recovery if needed.  This is the most
+	  basic form of media-forensics.
+
+	  If you are unsure, say N here.
+
+comment "IDE chipset support/bugfixes"
+
+config IDE_GENERIC
+	tristate "generic/default IDE chipset support"
+	default y
+	help
+	  If unsure, say Y.
+
+config BLK_DEV_CMD640
+	bool "CMD640 chipset bugfix/support"
+	depends on X86
+	---help---
+	  The CMD-Technologies CMD640 IDE chip is used on many common 486 and
+	  Pentium motherboards, usually in combination with a "Neptune" or
+	  "SiS" chipset. Unfortunately, it has a number of rather nasty
+	  design flaws that can cause severe data corruption under many common
+	  conditions. Say Y here to include code which tries to automatically
+	  detect and correct the problems under Linux. This option also
+	  enables access to the secondary IDE ports in some CMD640 based
+	  systems.
+
+	  This driver will work automatically in PCI based systems (most new
+	  systems have PCI slots). But if your system uses VESA local bus
+	  (VLB) instead of PCI, you must also supply a kernel boot parameter
+	  to enable the CMD640 bugfix/support: "ide0=cmd640_vlb". (Try "man
+	  bootparam" or see the documentation of your boot loader about how to
+	  pass options to the kernel.)
+
+	  The CMD640 chip is also used on add-in cards by Acculogic, and on
+	  the "CSA-6400E PCI to IDE controller" that some people have. For
+	  details, read <file:Documentation/ide.txt>.
+
+config BLK_DEV_CMD640_ENHANCED
+	bool "CMD640 enhanced support"
+	depends on BLK_DEV_CMD640
+	help
+	  This option includes support for setting/autotuning PIO modes and
+	  prefetch on CMD640 IDE interfaces.  For details, read
+	  <file:Documentation/ide.txt>. If you have a CMD640 IDE interface
+	  and your BIOS does not already do this for you, then say Y here.
+	  Otherwise say N.
+
+config BLK_DEV_IDEPNP
+	bool "PNP EIDE support"
+	depends on PNP
+	help
+	  If you have a PnP (Plug and Play) compatible EIDE card and
+	  would like the kernel to automatically detect and activate
+	  it, say Y here.
+
+config BLK_DEV_IDEPCI
+	bool "PCI IDE chipset support" if PCI
+	default BLK_DEV_IDEDMA_PMAC if PPC_PMAC && BLK_DEV_IDEDMA_PMAC
+	help
+	  Say Y here for PCI systems which use IDE drive(s).
+	  This option helps the IDE driver to automatically detect and
+	  configure all PCI-based IDE interfaces in your system.
+
+config IDEPCI_SHARE_IRQ
+	bool "Sharing PCI IDE interrupts support"
+	depends on PCI && BLK_DEV_IDEPCI
+	help
+	  Some ATA/IDE chipsets have hardware support which allows for
+	  sharing a single IRQ with other cards. To enable support for
+	  this in the ATA/IDE driver, say Y here.
+
+	  It is safe to say Y to this question, in most cases.
+	  If unsure, say N.
+
+config BLK_DEV_OFFBOARD
+	bool "Boot off-board chipsets first support"
+	depends on PCI && BLK_DEV_IDEPCI
+	help
+	  Normally, IDE controllers built into the motherboard (on-board
+	  controllers) are assigned to ide0 and ide1 while those on add-in PCI
+	  cards (off-board controllers) are relegated to ide2 and ide3.
+	  Answering Y here will allow you to reverse the situation, with
+	  off-board controllers on ide0/1 and on-board controllers on ide2/3.
+	  This can improve the usability of some boot managers such as lilo
+	  when booting from a drive on an off-board controller.
+
+	  If you say Y here, and you actually want to reverse the device scan
+	  order as explained above, you also need to issue the kernel command
+	  line option "ide=reverse". (Try "man bootparam" or see the
+	  documentation of your boot loader (lilo or loadlin) about how to
+	  pass options to the kernel at boot time.)
+
+	  Note that, if you do this, the order of the hd* devices will be
+	  rearranged which may require modification of fstab and other files.
+
+	  If in doubt, say N.
+
+config BLK_DEV_GENERIC
+	tristate "Generic PCI IDE Chipset Support"
+	depends on BLK_DEV_IDEPCI
+
+config BLK_DEV_OPTI621
+	tristate "OPTi 82C621 chipset enhanced support (EXPERIMENTAL)"
+	depends on PCI && BLK_DEV_IDEPCI && EXPERIMENTAL
+	help
+	  This is a driver for the OPTi 82C621 EIDE controller.
+	  Please read the comments at the top of <file:drivers/ide/pci/opti621.c>.
+
+config BLK_DEV_RZ1000
+	tristate "RZ1000 chipset bugfix/support"
+	depends on PCI && BLK_DEV_IDEPCI && X86
+	help
+	  The PC-Technologies RZ1000 IDE chip is used on many common 486 and
+	  Pentium motherboards, usually along with the "Neptune" chipset.
+	  Unfortunately, it has a rather nasty design flaw that can cause
+	  severe data corruption under many conditions. Say Y here to include
+	  code which automatically detects and corrects the problem under
+	  Linux. This may slow disk throughput by a few percent, but at least
+	  things will operate 100% reliably.
+
+config BLK_DEV_SL82C105
+	tristate "Winbond SL82c105 support"
+	depends on PCI && (PPC || ARM) && BLK_DEV_IDEPCI
+	help
+	  If you have a Winbond SL82c105 IDE controller, say Y here to enable
+	  special configuration for this chip. This is common on various CHRP
+	  motherboards, but could be used elsewhere. If in doubt, say Y.
+
+config BLK_DEV_IDEDMA_PCI
+	bool "Generic PCI bus-master DMA support"
+	depends on PCI && BLK_DEV_IDEPCI
+	---help---
+	  If your PCI system uses IDE drive(s) (as opposed to SCSI, say) and
+	  is capable of bus-master DMA operation (most Pentium PCI systems),
+	  you will want to say Y here to reduce CPU overhead. You can then use
+	  the "hdparm" utility to enable DMA for drives for which it was not
+	  enabled automatically. By default, DMA is not enabled automatically
+	  for these drives, but you can change that by saying Y to the
+	  following question "Use DMA by default when available". You can get
+	  the latest version of the hdparm utility from
+	  <ftp://ibiblio.org/pub/Linux/system/hardware/>.
+
+	  Read the comments at the beginning of <file:drivers/ide/ide-dma.c>
+	  and the file <file:Documentation/ide.txt> for more information.
+
+	  It is safe to say Y to this question.
+
+if BLK_DEV_IDEDMA_PCI
+
+config BLK_DEV_IDEDMA_FORCED
+	bool "Force enable legacy 2.0.X HOSTS to use DMA"
+	help
+	  This is an old piece of lost code from Linux 2.0 Kernels.
+
+	  Generally say N here.
+
+config IDEDMA_PCI_AUTO
+	bool "Use PCI DMA by default when available"
+	---help---
+	  Prior to kernel version 2.1.112, Linux used to automatically use
+	  DMA for IDE drives and chipsets which support it. Due to concerns
+	  about a couple of cases where buggy hardware may have caused damage,
+	  the default is now to NOT use DMA automatically. To revert to the
+	  previous behaviour, say Y to this question.
+
+	  If you suspect your hardware is at all flakey, say N here.
+	  Do NOT email the IDE kernel people regarding this issue!
+
+	  It is normally safe to answer Y to this question unless your
+	  motherboard uses a VIA VP2 chipset, in which case you should say N.
+
+config IDEDMA_ONLYDISK
+	bool "Enable DMA only for disks "
+	depends on IDEDMA_PCI_AUTO
+	help
+	  This is used if you know your ATAPI Devices are going to fail DMA
+	  Transfers.
+
+	  Generally say N here.
+
+config BLK_DEV_AEC62XX
+	tristate "AEC62XX chipset support"
+	help
+	  This driver adds explicit support for Acard AEC62xx (Artop ATP8xx)
+	  IDE controllers. This allows the kernel to change PIO, DMA and UDMA
+	  speeds and to configure the chip to optimum performance.
+
+config BLK_DEV_ALI15X3
+	tristate "ALI M15x3 chipset support"
+	help
+	  This driver ensures (U)DMA support for ALI 1533, 1543 and 1543C
+	  onboard chipsets.  It also tests for Simplex mode and enables
+	  normal dual channel support.
+
+	  If you say Y here, you also need to say Y to "Use DMA by default
+	  when available", above.  Please read the comments at the top of
+	  <file:drivers/ide/pci/alim15x3.c>.
+
+	  If unsure, say N.
+
+config WDC_ALI15X3
+	bool "ALI M15x3 WDC support (DANGEROUS)"
+	depends on BLK_DEV_ALI15X3
+	---help---
+	  This allows for UltraDMA support for WDC drives that ignore CRC
+	  checking. You are a fool for enabling this option, but there have
+	  been requests. DO NOT COMPLAIN IF YOUR DRIVE HAS FS CORRUPTION, IF
+	  YOU ENABLE THIS! No one will listen, just laugh for ignoring this
+	  SERIOUS WARNING.
+
+	  Using this option can allow WDC drives to run at ATA-4/5 transfer
+	  rates with only an ATA-2 support structure.
+
+	  SAY N!
+
+config BLK_DEV_AMD74XX
+	tristate "AMD and nVidia IDE support"
+	help
+	  This driver adds explicit support for AMD-7xx and AMD-8111 chips
+	  and also for the nVidia nForce chip.  This allows the kernel to
+	  change PIO, DMA and UDMA speeds and to configure the chip to
+	  optimum performance.
+
+config BLK_DEV_ATIIXP
+	tristate "ATI IXP chipset IDE support"
+	depends on X86
+	help
+	  This driver adds explicit support for ATI IXP chipset.
+	  This allows the kernel to change PIO, DMA and UDMA speeds
+	  and to configure the chip to optimum performance.
+
+	  Say Y here if you have an ATI IXP chipset IDE controller.
+
+config BLK_DEV_CMD64X
+	tristate "CMD64{3|6|8|9} chipset support"
+	help
+	  Say Y here if you have an IDE controller which uses any of these
+	  chipsets: CMD643, CMD646, or CMD648.
+
+config BLK_DEV_TRIFLEX
+	tristate "Compaq Triflex IDE support"
+	help
+	  Say Y here if you have a Compaq Triflex IDE controller, such
+	  as those commonly found on Compaq Pentium-Pro systems
+
+config BLK_DEV_CY82C693
+	tristate "CY82C693 chipset support"
+	help
+	  This driver adds detection and support for the CY82C693 chipset
+	  used on Digital's PC-Alpha 164SX boards.
+
+	  If you say Y here, you need to say Y to "Use DMA by default
+	  when available" as well.
+
+config BLK_DEV_CS5520
+	tristate "Cyrix CS5510/20 MediaGX chipset support (VERY EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	help
+	  Include support for PIO tuning and virtual DMA on the Cyrix MediaGX
+	  5510/5520 chipset. This will automatically be detected and
+	  configured if found.
+
+	  It is safe to say Y to this question.
+
+config BLK_DEV_CS5530
+	tristate "Cyrix/National Semiconductor CS5530 MediaGX chipset support"
+	help
+	  Include support for UDMA on the Cyrix MediaGX 5530 chipset. This
+	  will automatically be detected and configured if found.
+
+	  It is safe to say Y to this question.
+
+config BLK_DEV_CS5535
+	tristate "AMD CS5535 chipset support"
+	depends on X86 && !X86_64
+	help
+	  Include support for UDMA on the NSC/AMD CS5535 companion chipset.
+	  This will automatically be detected and configured if found.
+
+	  It is safe to say Y to this question.
+
+config BLK_DEV_HPT34X
+	tristate "HPT34X chipset support"
+	help
+	  This driver adds up to 4 more EIDE devices sharing a single
+	  interrupt. The HPT343 chipset in its current form is a non-bootable
+	  controller; the HPT345/HPT363 chipset is a bootable (needs BIOS FIX)
+	  PCI UDMA controllers. This driver requires dynamic tuning of the
+	  chipset during the ide-probe at boot time. It is reported to support
+	  DVD II drives, by the manufacturer.
+
+config HPT34X_AUTODMA
+	bool "HPT34X AUTODMA support (EXPERIMENTAL)"
+	depends on BLK_DEV_HPT34X && EXPERIMENTAL
+	help
+	  This is a dangerous thing to attempt currently! Please read the
+	  comments at the top of <file:drivers/ide/pci/hpt34x.c>.  If you say Y
+	  here, then say Y to "Use DMA by default when available" as well.
+
+	  If unsure, say N.
+
+config BLK_DEV_HPT366
+	tristate "HPT36X/37X chipset support"
+	---help---
+	  HPT366 is an Ultra DMA chipset for ATA-66.
+	  HPT368 is an Ultra DMA chipset for ATA-66 RAID Based.
+	  HPT370 is an Ultra DMA chipset for ATA-100.
+	  HPT372 is an Ultra DMA chipset for ATA-100.
+	  HPT374 is an Ultra DMA chipset for ATA-100.
+
+	  This driver adds up to 4 more EIDE devices sharing a single
+	  interrupt.
+
+	  The HPT366 chipset in its current form is bootable. One solution
+	  for this problem are special LILO commands for redirecting the
+	  reference to device 0x80. The other solution is to say Y to "Boot
+	  off-board chipsets first support" (CONFIG_BLK_DEV_OFFBOARD) unless
+	  your mother board has the chipset natively mounted. Regardless one
+	  should use the fore mentioned option and call at LILO or include
+	  "ide=reverse" in LILO's append-line.
+
+	  This driver requires dynamic tuning of the chipset during the
+	  ide-probe at boot. It is reported to support DVD II drives, by the
+	  manufacturer.
+
+config BLK_DEV_SC1200
+	tristate "National SCx200 chipset support"
+	help
+	  This driver adds support for the built in IDE on the National
+	  SCx200 series of embedded x86 "Geode" systems
+
+config BLK_DEV_PIIX
+	tristate "Intel PIIXn chipsets support"
+	help
+	  This driver adds explicit support for Intel PIIX and ICH chips
+	  and also for the Efar Victory66 (slc90e66) chip.  This allows
+	  the kernel to change PIO, DMA and UDMA speeds and to configure
+	  the chip to optimum performance.
+
+config BLK_DEV_IT8172
+	bool "IT8172 IDE support"
+	depends on (MIPS_ITE8172 || MIPS_IVR)
+	help
+	  Say Y here to support the on-board IDE controller on the Integrated
+	  Technology Express, Inc. ITE8172 SBC.  Vendor page at
+	  <http://www.ite.com.tw/ia/brief_it8172bsp.htm>; picture of the
+	  board at <http://www.mvista.com/partners/semiconductor/ite.html>.
+
+config BLK_DEV_IT821X
+	tristate "IT821X IDE support"
+	help
+	  This driver adds support for the ITE 8211 IDE controller and the
+	  IT 8212 IDE RAID controller in both RAID and pass-through mode.
+
+config BLK_DEV_NS87415
+	tristate "NS87415 chipset support"
+	help
+	  This driver adds detection and support for the NS87415 chip
+	  (used mainly on SPARC64 and PA-RISC machines).
+
+	  Please read the comments at the top of <file:drivers/ide/pci/ns87415.c>.
+
+config BLK_DEV_PDC202XX_OLD
+	tristate "PROMISE PDC202{46|62|65|67} support"
+	help
+	  Promise Ultra33 or PDC20246
+	  Promise Ultra66 or PDC20262
+	  Promise Ultra100 or PDC20265/PDC20267/PDC20268
+
+	  This driver adds up to 4 more EIDE devices sharing a single
+	  interrupt. This add-on card is a bootable PCI UDMA controller. Since
+	  multiple cards can be installed and there are BIOS ROM problems that
+	  happen if the BIOS revisions of all installed cards (three-max) do
+	  not match, the driver attempts to do dynamic tuning of the chipset
+	  at boot-time for max-speed.  Ultra33 BIOS 1.25 or newer is required
+	  for more than one card. This card may require that you say Y to
+	  "Special UDMA Feature".
+
+	  If you say Y here, you need to say Y to "Use DMA by default when
+	  available" as well.
+
+	  Please read the comments at the top of
+	  <file:drivers/ide/pci/pdc202xx_old.c>.
+
+	  If unsure, say N.
+
+config PDC202XX_BURST
+	bool "Special UDMA Feature"
+	depends on BLK_DEV_PDC202XX_OLD
+	help
+	  This option causes the pdc202xx driver to enable UDMA modes on the
+	  PDC202xx even when the PDC202xx BIOS has not done so.
+
+	  It was originally designed for the PDC20246/Ultra33, whose BIOS will
+	  only setup UDMA on the first two PDC20246 cards.  It has also been
+	  used successfully on a PDC20265/Ultra100, allowing use of UDMA modes
+	  when the PDC20265 BIOS has been disabled (for faster boot up).
+
+	  Please read the comments at the top of
+	  <file:drivers/ide/pci/pdc202xx_old.c>.
+
+	  If unsure, say N.
+
+config BLK_DEV_PDC202XX_NEW
+	tristate "PROMISE PDC202{68|69|70|71|75|76|77} support"
+
+config BLK_DEV_SVWKS
+	tristate "ServerWorks OSB4/CSB5/CSB6 chipsets support"
+	help
+	  This driver adds PIO/(U)DMA support for the ServerWorks OSB4/CSB5
+	  chipsets.
+
+config BLK_DEV_SGIIOC4
+	tristate "Silicon Graphics IOC4 chipset ATA/ATAPI support"
+	depends on (IA64_SGI_SN2 || IA64_GENERIC) && SGI_IOC4
+	help
+	  This driver adds PIO & MultiMode DMA-2 support for the SGI IOC4
+	  chipset, which has one channel and can support two devices.
+	  Please say Y here if you have an Altix System from SGI.
+
+config BLK_DEV_SIIMAGE
+	tristate "Silicon Image chipset support"
+	help
+	  This driver adds PIO/(U)DMA support for the SI CMD680 and SII
+	  3112 (Serial ATA) chips.
+
+config BLK_DEV_SIS5513
+	tristate "SiS5513 chipset support"
+	depends on X86
+	---help---
+	  This driver ensures (U)DMA support for SIS5513 chipset family based
+	  mainboards.
+
+	  The following chipsets are supported:
+	  ATA16:  SiS5511, SiS5513
+	  ATA33:  SiS5591, SiS5597, SiS5598, SiS5600
+	  ATA66:  SiS530, SiS540, SiS620, SiS630, SiS640
+	  ATA100: SiS635, SiS645, SiS650, SiS730, SiS735, SiS740,
+	  SiS745, SiS750
+
+	  If you say Y here, you need to say Y to "Use DMA by default when
+	  available" as well.
+
+	  Please read the comments at the top of <file:drivers/ide/pci/sis5513.c>.
+
+config BLK_DEV_SLC90E66
+	tristate "SLC90E66 chipset support"
+	help
+	  This driver ensures (U)DMA support for Victory66 SouthBridges for
+	  SMsC with Intel NorthBridges.  This is an Ultra66 based chipset.
+	  The nice thing about it is that you can mix Ultra/DMA/PIO devices
+	  and it will handle timing cycles.  Since this is an improved
+	  look-a-like to the PIIX4 it should be a nice addition.
+
+	  If you say Y here, you need to say Y to "Use DMA by default when
+	  available" as well.
+
+	  Please read the comments at the top of
+	  <file:drivers/ide/pci/slc90e66.c>.
+
+config BLK_DEV_TRM290
+	tristate "Tekram TRM290 chipset support"
+	help
+	  This driver adds support for bus master DMA transfers
+	  using the Tekram TRM290 PCI IDE chip. Volunteers are
+	  needed for further tweaking and development.
+	  Please read the comments at the top of <file:drivers/ide/pci/trm290.c>.
+
+config BLK_DEV_VIA82CXXX
+	tristate "VIA82CXXX chipset support"
+	help
+	  This driver adds explicit support for VIA BusMastering IDE chips.
+	  This allows the kernel to change PIO, DMA and UDMA speeds and to
+	  configure the chip to optimum performance.
+
+endif
+
+config BLK_DEV_IDE_PMAC
+	bool "Builtin PowerMac IDE support"
+	depends on PPC_PMAC && IDE=y
+	help
+	  This driver provides support for the built-in IDE controller on
+	  most of the recent Apple Power Macintoshes and PowerBooks.
+	  If unsure, say Y.
+
+config BLK_DEV_IDE_PMAC_ATA100FIRST
+	bool "Probe internal ATA/100 (Kauai) first"
+	depends on BLK_DEV_IDE_PMAC
+	help
+	  This option will cause the ATA/100 controller found in UniNorth2
+	  based machines (Windtunnel PowerMac, Aluminium PowerBooks, ...)
+	  to be probed before the ATA/66 and ATA/33 controllers. Without
+	  these, those machine used to have the hard disk on hdc and the
+	  CD-ROM on hda. This option changes this to more natural hda for
+	  hard disk and hdc for CD-ROM.
+
+config BLK_DEV_IDEDMA_PMAC
+	bool "PowerMac IDE DMA support"
+	depends on BLK_DEV_IDE_PMAC
+	select BLK_DEV_IDEDMA_PCI
+	help
+	  This option allows the driver for the built-in IDE controller on
+	  Power Macintoshes and PowerBooks to use DMA (direct memory access)
+	  to transfer data to and from memory.  Saying Y is safe and improves
+	  performance.
+
+config BLK_DEV_IDE_PMAC_BLINK
+	bool "Blink laptop LED on drive activity"
+	depends on BLK_DEV_IDE_PMAC && ADB_PMU
+	help
+	  This option enables the use of the sleep LED as a hard drive
+	  activity LED.
+
+config BLK_DEV_IDE_SWARM
+	tristate "IDE for Sibyte evaluation boards"
+	depends on SIBYTE_SB1xxx_SOC
+
+config BLK_DEV_IDE_AU1XXX
+       bool "IDE for AMD Alchemy Au1200"
+       depends on SOC_AU1200
+choice
+       prompt "IDE Mode for AMD Alchemy Au1200"
+       default CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA
+       depends on SOC_AU1200 && BLK_DEV_IDE_AU1XXX
+
+config BLK_DEV_IDE_AU1XXX_PIO_DBDMA
+       bool "PIO+DbDMA IDE for AMD Alchemy Au1200"
+
+config BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+       bool "MDMA2+DbDMA IDE for AMD Alchemy Au1200"
+       depends on SOC_AU1200 && BLK_DEV_IDE_AU1XXX
+endchoice
+
+config BLK_DEV_IDE_AU1XXX_SEQTS_PER_RQ
+       int "Maximum transfer size (KB) per request (up to 128)"
+       default "128"
+       depends BLK_DEV_IDE_AU1XXX
+
+config IDE_ARM
+	def_bool ARM && (ARCH_A5K || ARCH_CLPS7500 || ARCH_RPC || ARCH_SHARK)
+
+config BLK_DEV_IDE_ICSIDE
+	tristate "ICS IDE interface support"
+	depends on ARM && ARCH_ACORN
+	help
+	  On Acorn systems, say Y here if you wish to use the ICS IDE
+	  interface card.  This is not required for ICS partition support.
+	  If you are unsure, say N to this.
+
+config BLK_DEV_IDEDMA_ICS
+	bool "ICS DMA support"
+	depends on BLK_DEV_IDE_ICSIDE
+	help
+	  Say Y here if you want to add DMA (Direct Memory Access) support to
+	  the ICS IDE driver.
+
+config IDEDMA_ICS_AUTO
+	bool "Use ICS DMA by default"
+	depends on BLK_DEV_IDEDMA_ICS
+	help
+	  Prior to kernel version 2.1.112, Linux used to automatically use
+	  DMA for IDE drives and chipsets which support it. Due to concerns
+	  about a couple of cases where buggy hardware may have caused damage,
+	  the default is now to NOT use DMA automatically. To revert to the
+	  previous behaviour, say Y to this question.
+
+	  If you suspect your hardware is at all flakey, say N here.
+	  Do NOT email the IDE kernel people regarding this issue!
+
+config BLK_DEV_IDE_RAPIDE
+	tristate "RapIDE interface support"
+	depends on ARM && ARCH_ACORN
+	help
+	  Say Y here if you want to support the Yellowstone RapIDE controller
+	  manufactured for use with Acorn computers.
+
+config BLK_DEV_IDE_BAST
+	tristate "Simtec BAST / Thorcom VR1000 IDE support"
+	depends on ARM && (ARCH_BAST || MACH_VR1000)
+	help
+	  Say Y here if you want to support the onboard IDE channels on the
+	  Simtec BAST or the Thorcom VR1000
+
+config BLK_DEV_GAYLE
+	bool "Amiga Gayle IDE interface support"
+	depends on AMIGA
+	help
+	  This is the IDE driver for the Amiga Gayle IDE interface. It supports
+	  both the `A1200 style' and `A4000 style' of the Gayle IDE interface,
+	  This includes builtin IDE interfaces on some Amiga models (A600,
+	  A1200, A4000, and A4000T), and IDE interfaces on the Zorro expansion
+	  bus (M-Tech E-Matrix 530 expansion card).
+	  Say Y if you have an Amiga with a Gayle IDE interface and want to use
+	  IDE devices (hard disks, CD-ROM drives, etc.) that are connected to
+	  it.
+	  Note that you also have to enable Zorro bus support if you want to
+	  use Gayle IDE interfaces on the Zorro expansion bus.
+
+config BLK_DEV_IDEDOUBLER
+	bool "Amiga IDE Doubler support (EXPERIMENTAL)"
+	depends on BLK_DEV_GAYLE && EXPERIMENTAL
+	---help---
+	  This driver provides support for the so-called `IDE doublers' (made
+	  by various manufacturers, e.g. Eyetech) that can be connected to the
+	  builtin IDE interface of some Amiga models. Using such an IDE
+	  doubler, you can connect up to four instead of two IDE devices on
+	  the Amiga's builtin IDE interface.
+
+	  Note that the normal Amiga Gayle IDE driver may not work correctly
+	  if you have an IDE doubler and don't enable this driver!
+
+	  Say Y if you have an IDE doubler.  The driver is enabled at kernel
+	  runtime using the "ide=doubler" kernel boot parameter.
+
+config BLK_DEV_BUDDHA
+	bool "Buddha/Catweasel/X-Surf IDE interface support (EXPERIMENTAL)"
+	depends on ZORRO && EXPERIMENTAL
+	help
+	  This is the IDE driver for the IDE interfaces on the Buddha, 
+	  Catweasel and X-Surf expansion boards.  It supports up to two interfaces 
+	  on the Buddha, three on the Catweasel and two on the X-Surf.
+
+	  Say Y if you have a Buddha or Catweasel expansion board and want to
+	  use IDE devices (hard disks, CD-ROM drives, etc.) that are connected
+	  to one of its IDE interfaces.
+
+config BLK_DEV_FALCON_IDE
+	bool "Falcon IDE interface support"
+	depends on ATARI
+	help
+	  This is the IDE driver for the builtin IDE interface on the Atari
+	  Falcon. Say Y if you have a Falcon and want to use IDE devices (hard
+	  disks, CD-ROM drives, etc.) that are connected to the builtin IDE
+	  interface.
+
+config BLK_DEV_MAC_IDE
+	bool "Macintosh Quadra/Powerbook IDE interface support"
+	depends on MAC
+	help
+	  This is the IDE driver for the builtin IDE interface on some m68k
+	  Macintosh models. It supports both the `Quadra style' (used in
+	  Quadra/ Centris 630 and Performa 588 models) and `Powerbook style'
+	  (used in the Powerbook 150 and 190 models) IDE interface.
+
+	  Say Y if you have such an Macintosh model and want to use IDE
+	  devices (hard disks, CD-ROM drives, etc.) that are connected to the
+	  builtin IDE interface.
+
+config BLK_DEV_Q40IDE
+	bool "Q40/Q60 IDE interface support"
+	depends on Q40
+	help
+	  Enable the on-board IDE controller in the Q40/Q60.  This should
+	  normally be on; disable it only if you are running a custom hard
+	  drive subsystem through an expansion card.
+
+config BLK_DEV_MPC8xx_IDE
+	bool "MPC8xx IDE support"
+	depends on 8xx && IDE=y && BLK_DEV_IDE=y
+	help
+	  This option provides support for IDE on Motorola MPC8xx Systems.
+	  Please see 'Type of MPC8xx IDE interface' for details.
+
+	  If unsure, say N.
+
+choice
+	prompt "Type of MPC8xx IDE interface"
+	depends on BLK_DEV_MPC8xx_IDE
+	default IDE_8xx_PCCARD
+
+config IDE_8xx_PCCARD
+	bool "8xx_PCCARD"
+	---help---
+	  Select how the IDE devices are connected to the MPC8xx system:
+
+	  8xx_PCCARD uses the 8xx internal PCMCIA interface in combination
+	  with a PC Card (e.g. ARGOSY portable Hard Disk Adapter),
+	  ATA PC Card HDDs or ATA PC Flash Cards (example: TQM8xxL
+	  systems)
+
+	  8xx_DIRECT is used for directly connected IDE devices using the 8xx
+	  internal PCMCIA interface (example: IVMS8 systems)
+
+	  EXT_DIRECT is used for IDE devices directly connected to the 8xx
+	  bus using some glue logic, but _not_ the 8xx internal
+	  PCMCIA interface (example: IDIF860 systems)
+
+config IDE_8xx_DIRECT
+	bool "8xx_DIRECT"
+
+config IDE_EXT_DIRECT
+	bool "EXT_DIRECT"
+
+endchoice
+
+# no isa -> no vlb
+config IDE_CHIPSETS
+	bool "Other IDE chipset support"
+	depends on ISA
+	---help---
+	  Say Y here if you want to include enhanced support for various IDE
+	  interface chipsets used on motherboards and add-on cards. You can
+	  then pick your particular IDE chip from among the following options.
+	  This enhanced support may be necessary for Linux to be able to
+	  access the 3rd/4th drives in some systems. It may also enable
+	  setting of higher speed I/O rates to improve system performance with
+	  these chipsets. Most of these also require special kernel boot
+	  parameters to actually turn on the support at runtime; you can find
+	  a list of these in the file <file:Documentation/ide.txt>.
+
+	  People with SCSI-only systems can say N here.
+
+if IDE_CHIPSETS
+
+comment "Note: most of these also require special kernel boot parameters"
+
+config BLK_DEV_4DRIVES
+	bool "Generic 4 drives/port support"
+	help
+	  Certain older chipsets, including the Tekram 690CD, use a single set
+	  of I/O ports at 0x1f0 to control up to four drives, instead of the
+	  customary two drives per port. Support for this can be enabled at
+	  runtime using the "ide0=four" kernel boot parameter if you say Y
+	  here.
+
+config BLK_DEV_ALI14XX
+	tristate "ALI M14xx support"
+	help
+	  This driver is enabled at runtime using the "ide0=ali14xx" kernel
+	  boot parameter.  It enables support for the secondary IDE interface
+	  of the ALI M1439/1443/1445/1487/1489 chipsets, and permits faster
+	  I/O speeds to be set as well.  See the files
+	  <file:Documentation/ide.txt> and <file:drivers/ide/legacy/ali14xx.c> for
+	  more info.
+
+config BLK_DEV_DTC2278
+	tristate "DTC-2278 support"
+	help
+	  This driver is enabled at runtime using the "ide0=dtc2278" kernel
+	  boot parameter. It enables support for the secondary IDE interface
+	  of the DTC-2278 card, and permits faster I/O speeds to be set as
+	  well. See the <file:Documentation/ide.txt> and
+	  <file:drivers/ide/legacy/dtc2278.c> files for more info.
+
+config BLK_DEV_HT6560B
+	tristate "Holtek HT6560B support"
+	help
+	  This driver is enabled at runtime using the "ide0=ht6560b" kernel
+	  boot parameter. It enables support for the secondary IDE interface
+	  of the Holtek card, and permits faster I/O speeds to be set as well.
+	  See the <file:Documentation/ide.txt> and
+	  <file:drivers/ide/legacy/ht6560b.c> files for more info.
+
+config BLK_DEV_QD65XX
+	tristate "QDI QD65xx support"
+	help
+	  This driver is enabled at runtime using the "ide0=qd65xx" kernel
+	  boot parameter.  It permits faster I/O speeds to be set.  See the
+	  <file:Documentation/ide.txt> and <file:drivers/ide/legacy/qd65xx.c> for
+	  more info.
+
+config BLK_DEV_UMC8672
+	tristate "UMC-8672 support"
+	help
+	  This driver is enabled at runtime using the "ide0=umc8672" kernel
+	  boot parameter. It enables support for the secondary IDE interface
+	  of the UMC-8672, and permits faster I/O speeds to be set as well.
+	  See the files <file:Documentation/ide.txt> and
+	  <file:drivers/ide/legacy/umc8672.c> for more info.
+
+endif
+
+config BLK_DEV_IDEDMA
+	def_bool BLK_DEV_IDEDMA_PCI || BLK_DEV_IDEDMA_PMAC || BLK_DEV_IDEDMA_ICS || BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+
+config IDEDMA_IVB
+	bool "IGNORE word93 Validation BITS"
+	depends on BLK_DEV_IDEDMA_PCI || BLK_DEV_IDEDMA_PMAC || BLK_DEV_IDEDMA_ICS
+	---help---
+	  There are unclear terms in ATA-4 and ATA-5 standards how certain
+	  hardware (an 80c ribbon) should be detected. Different interpretations
+	  of the standards have been released in hardware. This causes problems:
+	  for example, a host with Ultra Mode 4 (or higher) will not run
+	  in that mode with an 80c ribbon.
+
+	  If you are experiencing compatibility or performance problems, you
+	  MAY try to answer Y here. However, it does not necessarily solve
+	  any of your problems, it could even cause more of them.
+
+	  It is normally safe to answer Y; however, the default is N.
+
+config IDEDMA_AUTO
+	def_bool IDEDMA_PCI_AUTO || IDEDMA_ICS_AUTO
+
+endif
+
+config BLK_DEV_HD_ONLY
+	bool "Old hard disk (MFM/RLL/IDE) driver"
+	depends on BLK_DEV_IDE=n
+	help
+	  There are two drivers for MFM/RLL/IDE hard disks. Most people use
+	  the newer enhanced driver, but this old one is still around for two
+	  reasons. Some older systems have strange timing problems and seem to
+	  work only with the old driver (which itself does not work with some
+	  newer systems). The other reason is that the old driver is smaller,
+	  since it lacks the enhanced functionality of the new one. This makes
+	  it a good choice for systems with very tight memory restrictions, or
+	  for systems with only older MFM/RLL/ESDI drives. Choosing the old
+	  driver can save 13 KB or so of kernel memory.
+
+	  If you are unsure, then just choose the Enhanced IDE/MFM/RLL driver
+	  instead of this one. For more detailed information, read the
+	  Disk-HOWTO, available from
+	  <http://www.tldp.org/docs.html#howto>.
+
+config BLK_DEV_HD
+	def_bool BLK_DEV_HD_IDE || BLK_DEV_HD_ONLY
+
+endif
+
+endmenu
