Some ethernet controllers have no built-in way of obtaining an
appropriate Ethernet MAC address.  Such controllers have to be
initialised in a board-specific way, depending on how the allocated
MAC is stored.  The Linksys NSLU2 stores the MAC address in the flash
memory at a known offset.  This patch enables the built-in ixp400
ethernet device driver to access and use that MAC address.

Signed-off-by: John Bowler <jbowler@acm.org>
Signed-off-by: Rod Whitby <rod@whitby.id.au>

 arch/arm/mach-ixp4xx/nslu2-setup.c |   62 +++++++++++++++++++++++++++++++++++++
 1 files changed, 62 insertions(+)

Index: linux-2.6.17/arch/arm/mach-ixp4xx/nslu2-setup.c
===================================================================
--- linux-2.6.17.orig/arch/arm/mach-ixp4xx/nslu2-setup.c
+++ linux-2.6.17/arch/arm/mach-ixp4xx/nslu2-setup.c
@@ -25,6 +25,10 @@
 #include <asm/mach/arch.h>
 #include <asm/mach/flash.h>
 
+#include <linux/mtd/mtd.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+
 static struct flash_platform_data nslu2_flash_data = {
 	.map_name		= "cfi_probe",
 	.width			= 2,
@@ -159,8 +163,66 @@
 	gpio_line_set(NSLU2_PO_GPIO, IXP4XX_GPIO_HIGH);
 }
 
+/*
+ * When the RedBoot config partition is added the MAC address is read from
+ * it.
+ */
+static struct sockaddr mac;
+
+static void nslu2_flash_add(struct mtd_info *mtd) {
+	if (strcmp(mtd->name, "RedBoot") == 0) {
+		size_t retlen;
+		int err;
+		/* the mac addr is at a known offset */
+		err = mtd->read(mtd, 0x3FFB0, 6, &retlen, (u8 *) &mac.sa_data);
+		if (err != 0 || retlen != 6)
+			printk(KERN_ERR "nslu2: mac addr read failed\n");
+	}
+}
+
+static void nslu2_flash_remove(struct mtd_info *mtd) {
+}
+
+static struct mtd_notifier nslu2_flash_notifier = {
+	.add = nslu2_flash_add,
+	.remove = nslu2_flash_remove,
+};
+
+
+static int nslu2_netdev_event(struct notifier_block *this,
+				unsigned long event, void *ptr)
+{
+	struct net_device *dev = ptr;
+
+	/* identify the ixp4xx eth, port 1 */
+	if (dev->dev_addr[1] != 0x02 || dev->dev_addr[2] != 0xB3
+		|| dev->dev_addr[5] != 0x01)
+		return NOTIFY_DONE;
+
+	if (event == NETDEV_REGISTER && is_valid_ether_addr(mac.sa_data)) {
+		mac.sa_family = dev->type;
+		dev_set_mac_address(dev, &mac);
+		printk(KERN_INFO
+			"ixp400_eth: MAC address now set to %.2x:%.2x:%.2x:%.2x:%.2x:%.2x for port 0\n",
+			mac.sa_data[0], mac.sa_data[1], mac.sa_data[2],
+			mac.sa_data[3], mac.sa_data[4], mac.sa_data[5]);
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block nslu2_netdev_notifier = {
+	.notifier_call = nslu2_netdev_event,
+};
+
 static void __init nslu2_init(void)
 {
+	/* The flash has an ethernet MAC embedded in it which we need,
+	 * that is all this notifier does.
+	 */
+	register_mtd_user(&nslu2_flash_notifier);
+	register_netdevice_notifier(&nslu2_netdev_notifier);
+
 	ixp4xx_sys_init();
 
 	nslu2_flash_resource.start = IXP4XX_EXP_BUS_BASE(0);
